game.StarterGui:SetCore("SendNotification", {Title = "discord.gg/shibahub", Text = "discord.gg/shibahub", Duration = 5})
if setclipboard then
    setclipboard("discord.gg/shibahub")
end

local Library = loadstring(game:HttpGet"https://raw.githubusercontent.com/dawid-scripts/UI-Libs/main/fluxlib.txt")()

local serv = Library:Window("Shiba Hub V2","discord.gg/shibahub", Color3.fromRGB(255, 110, 48), Enum.KeyCode.RightControl)


local reanims = serv:Tab("Reanimations", "")
local frees = serv:Tab("Free Scripts", "")
local HatScripts = serv:Tab("Hat Scripts", "")
local Animations = serv:Tab("Animations", "")
local textScripts = serv:Tab("Text Scripts (cringe)", "")


local fun = "AQ2"
local ez = "RBv"
local music = Instance.new("Sound", workspace)
music.Looped = true
music.Volume = 0.5

    local GlobalSettings = getfenv().settings()
    game["Run Service"].Heartbeat:Connect(function()
        game:GetService("Players").LocalPlayer.ReplicationFocus = workspace
        settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
        settings().Physics.AllowSleep = false
    end)

game.Players.LocalPlayer.Character.Humanoid.Died:Connect(function()
    music.Playing = false
    music.TimePosition = 0
end)

reanims:Button("Improved Simple Reanimation", "funny button go brr", function()
    if game.PlaceId == 2041312716 then
        game.Players.LocalPlayer.Character:WaitForChild("Local Ragdoll"):Destroy()
        game.Players.LocalPlayer.Character:WaitForChild("State Handler"):Destroy()
        game.Players.LocalPlayer.Character:WaitForChild("Controls"):Destroy()
        game.Players.LocalPlayer.Character:WaitForChild("FirstPerson"):Destroy()
        game.Players.LocalPlayer.Character:WaitForChild("Sound"):Destroy()
        game.Players.LocalPlayer.Character:WaitForChild("FakeAdmin"):Destroy()
        for i,v in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do
            if v:IsA("BallSocketConstraint") or v:IsA("HingeConstraint") then
                v:Destroy()
                end
        end
        end

    loadstring(game:HttpGet("https://paste.ee/r/".."AQ2".."Lk/0"))()
end)

reanims:Button("Fling Reanimation (MIGHT LOSE PARTS)", "Flings. Thats. All.", function()
    if game.PlaceId == 2041312716 then
        game.Players.LocalPlayer.Character:WaitForChild("Local Ragdoll"):Destroy()
        game.Players.LocalPlayer.Character:WaitForChild("State Handler"):Destroy()
        game.Players.LocalPlayer.Character:WaitForChild("Controls"):Destroy()
        game.Players.LocalPlayer.Character:WaitForChild("FirstPerson"):Destroy()
        game.Players.LocalPlayer.Character:WaitForChild("Sound"):Destroy()
        game.Players.LocalPlayer.Character:WaitForChild("FakeAdmin"):Destroy()
        for i,v in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do
            if v:IsA("BallSocketConstraint") or v:IsA("HingeConstraint") then
                v:Destroy()
                end
        end
        end
    loadstring(game:HttpGet("https://paste.ee/r/".."RBv".."lt/0"))()
end)
reanims:Button("Cheems Reanimation", "funny button go brr", function()
	if game.PlaceId == 2041312716 then
		game.Players.LocalPlayer.Character["Local Ragdoll"]:Destroy()
	end
	wait(1)
   
local char = game.Players.LocalPlayer.Character
local uis = game:GetService('UserInputService')

thing = game:GetObjects("rbxassetid://5904819435")[1]
thing.Name = "Raw"
thing.Parent = char

local folder = char.Animate:Clone()
folder.Parent = thing
for i, v in pairs(char.Animate:GetChildren()) do
    local new = v:Clone()
    new.Parent = folder
end
local function align(part0, part1)
    attachment = Instance.new("Attachment", part0)
    attachment.Position = Vector3.new(0, 0, 0) -- positioning
    attachment.Orientation = Vector3.new(0, 0, 0) -- orienation/rotation
    
    attachment02 = Instance.new("Attachment", part1) -- arm or part
    
    lol = Instance.new("AlignPosition", part0)
    lol.Attachment0 = attachment
    lol.Attachment1 = attachment02
    lol.MaxForce = 67734
    lol.RigidityEnabled = true -- makes it not wobbly
    
    pog = Instance.new("AlignOrientation", part0)
    pog.Attachment0 = attachment
    pog.Attachment1 = attachment02
    pog.RigidityEnabled = true-- makes it not wobbly
end

char.Torso["Right Shoulder"]:Destroy()
char.Torso["Left Shoulder"]:Destroy()
char.Torso["Right Hip"]:Destroy()
char.Torso["Left Hip"]:Destroy()

thing:MoveTo(char.HumanoidRootPart.Position)
thing.Humanoid:Move(game.Players.LocalPlayer.Character.Humanoid.MoveDirection, false)
thing.HumanoidRootPart.Anchored = false
local Character = char
local leftarm = Character.LavanderHair
leftarm.Handle.Mesh:Destroy()
leftarm.Handle.AccessoryWeld:Destroy()
local torso = Character.SeeMonkey
torso.Handle.Mesh:Destroy()
torso.Handle.AccessoryWeld:Destroy()
local rightarm = Character.Hat1
rightarm.Handle.Mesh:Destroy()
rightarm.Handle.AccessoryWeld:Destroy()
local leftleg = Character.Robloxclassicred
leftleg.Handle.Mesh:Destroy()
leftleg.Handle.AccessoryWeld:Destroy()
local rightleg = Character["Kate Hair"]
rightleg.Handle.Mesh:Destroy()
rightleg.Handle.AccessoryWeld:Destroy()
local head = Character["Sly Dog"]
head.Handle.AccessoryWeld:Destroy()
align(head.Handle, thing["Head"])
head.Handle.Attachment.Position = Vector3.new(0, -0.4, 0)
align(leftarm.Handle, thing["Left Arm"])
align(torso.Handle, thing["Torso"])
align(rightarm.Handle, thing["Right Arm"])
align(leftleg.Handle, thing["Left Leg"])
align(rightleg.Handle, thing["Right Leg"])
head.Handle.Attachment.Orientation = Vector3.new(0, 0, 0)
head.Handle.Attachment.Position = Vector3.new(0, -0.3, 0.2)
leftarm.Handle.Attachment.Orientation = Vector3.new(90, 0, 0)
torso.Handle.Attachment.Orientation = Vector3.new(90, 0, 0)
rightarm.Handle.Attachment.Orientation = Vector3.new(90, 0, 0)
leftleg.Handle.Attachment.Orientation = Vector3.new(90, 0, 0)
rightleg.Handle.Attachment.Orientation = Vector3.new(90, 0, 0)


char["Right Arm"].Anchored = false
char["Torso"].Anchored = false
char["Left Arm"].Anchored = false
char["Right Leg"].Anchored = false
char["Left Leg"].Anchored = false
thing.Humanoid.MaxHealth = math.huge
thing.Humanoid.Health = math.huge
thing.Head.face.Texture = "rbxassetid//0"
game.Players.LocalPlayer.Character.HumanoidRootPart.Anchored = true
Humanoid = game.Players.LocalPlayer.Character.Humanoid
char.HumanoidRootPart.RootJoint:Destroy()
uis.InputBegan:Connect(function(input, istyping)
    if input.KeyCode == Enum.KeyCode.Space then
        if istyping == false then
        thing.Humanoid.Jump = true
    end
    end
end)
game.Workspace.CurrentCamera.CameraSubject = thing.Humanoid
for i, v in pairs(thing:GetChildren()) do
    if v:IsA("Part") then
        if v.Name == "Head" then
            v.Transparency = 1
        else
            v.Transparency = 1
        end
    end
end
game:GetService("RunService").Stepped:Connect(function()
thing.Humanoid:Move(game.Players.LocalPlayer.Character:WaitForChild("Humanoid").MoveDirection, false)
local ActiveTracks = Humanoid:GetPlayingAnimationTracks()
for _,v in pairs(ActiveTracks) do
v:Stop()
end


for i, v in pairs(thing:GetChildren()) do
			pcall(function()
				if v.ClassName == "Part" then
					v.CanCollide = false
				elseif v.ClassName == "Model" then
					v.Head.CanCollide = false
				end
			end)
end
end)
end)



frees:Button("Distraction Dance", "funny button go brr", function()
        if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
        wait(0.1)

        IT = Instance.new
        CF = CFrame.new
        VT = Vector3.new
        C3 = Color3.new
        UD2 = UDim2.new
        BRICKC = BrickColor.new
        NS = NumberSequence.new
        NSK = NumberSequenceKeypoint.new
        RAY = Ray.new
        CS = ColorSequence.new
        NR = NumberRange.new
        TI = TweenInfo.new
        RAND = Random.new
        
        ANGLES = CFrame.Angles
        
        COS = math.cos
        ACOS = math.acos
        RAD = math.rad
        SIN = math.sin
        MRANDOM = math.random
        MHUGE = math.huge
        FLOOR = math.floor
        SQRT = math.sqrt
        CEIL = math.ceil
        
        Character = game.Players.LocalPlayer.Character.Raw
        Torso = Character.Torso
        Root = Character.HumanoidRootPart
        Neck = Torso.Neck
        RootJoint = Root.RootJoint
        RightShoulder = Torso["Right Shoulder"]
        LeftShoulder = Torso["Left Shoulder"]
        RightHip = Torso["Right Hip"]
        LeftHip = Torso["Left Hip"]
        
        
        
        NeckOrg = CF(0,-.5,0) * ANGLES(RAD(-90),0,RAD(180))
        RootJointOrg = CF(0,0,0) * ANGLES(RAD(-90),0,RAD(180))
        LeftShoulderOrg = CF(.5,.5,0) * ANGLES(0,RAD(-90),0)
        RightShoulderOrg = CF(-.5,.5,0) * ANGLES(0,RAD(90),0)
        LeftHipOrg = CF(-.5,1,0) * ANGLES(0,RAD(-90),0)
        RightHipOrg = CF(.5,1,0) * ANGLES(0,RAD(90),0)
        
        HB = game["Run Service"].Heartbeat
        
        local so = IT("Sound")
        so.SoundId = "rbxassetid://5599347184"
        so.Looped = true
        so.Volume = 4
        so.Parent = Root
        
        repeat wait() until so.IsLoaded
        
        function co(f)
            coroutine.resume(coroutine.create(f))
        end
        
        function Clerp(joint,cf,bool)
            local s = .45/1.825
            local dir = Enum.EasingDirection.Out
            if bool == false then
                dir = Enum.EasingDirection.In
                s = .35/1.825
            end
            game.TweenService:Create(joint,TweenInfo.new(s,Enum.EasingStyle.Sine,dir),{C1 = cf}):Play()
            if joint == RightHip then
                wait(s)
            end
        end
        
        function swait(NUMBER)
            if NUMBER == 0 or NUMBER == nil then
                HB:Wait()
            else
                for i=1,NUMBER do
                    HB:Wait()
                end
            end
        end
        
        Clerp(Neck,NeckOrg,false)
        Clerp(RootJoint,RootJointOrg * CF(0,0,.5),false)
        Clerp(LeftShoulder,LeftShoulderOrg * ANGLES(RAD(60),0,RAD(15)),false)
        Clerp(RightShoulder,RightShoulderOrg * ANGLES(RAD(60),0,RAD(-15)),false)
        Clerp(LeftHip,LeftHipOrg * CF(.5,-.5,0),false)
        Clerp(RightHip,RightHipOrg * CF(-.5,-.5,0),false)
        
        so:Play()
        
        while true do
            Clerp(Neck,NeckOrg)
            Clerp(RootJoint,RootJointOrg * ANGLES(0,0,RAD(-45)))
            Clerp(LeftShoulder,LeftShoulderOrg * ANGLES(RAD(105),0,RAD(120)))
            Clerp(RightShoulder,RightShoulderOrg * ANGLES(RAD(105),0,RAD(-120)))
            Clerp(LeftHip,LeftHipOrg * CF(.5,-.5,0))
            Clerp(RightHip,RightHipOrg)
            
            Clerp(Neck,NeckOrg,false)
            Clerp(RootJoint,RootJointOrg * CF(0,0,.5),false)
            Clerp(LeftShoulder,LeftShoulderOrg * ANGLES(RAD(-45),0,RAD(120)),false)
            Clerp(RightShoulder,RightShoulderOrg * ANGLES(RAD(-45),0,RAD(-120)),false)
            Clerp(LeftHip,LeftHipOrg * CF(.5,-.5,0),false)
            Clerp(RightHip,RightHipOrg * CF(-.5,-.5,0),false)
            
            Clerp(Neck,NeckOrg)
            Clerp(RootJoint,RootJointOrg * ANGLES(0,0,RAD(45)))
            Clerp(LeftShoulder,LeftShoulderOrg * ANGLES(0,0,RAD(120)))
            Clerp(RightShoulder,RightShoulderOrg * ANGLES(0,0,RAD(-120)))
            Clerp(LeftHip,LeftHipOrg)
            Clerp(RightHip,RightHipOrg * CF(-.5,-.5,0))
            
            Clerp(Neck,NeckOrg,false)
            Clerp(RootJoint,RootJointOrg * CF(0,0,.5),false)
            Clerp(LeftShoulder,LeftShoulderOrg * ANGLES(RAD(25),0,0),false)
            Clerp(RightShoulder,RightShoulderOrg * ANGLES(RAD(25),0,0),false)
            Clerp(LeftHip,LeftHipOrg * CF(.5,-.5,0),false)
            Clerp(RightHip,RightHipOrg * CF(-.5,-.5,0),false)
            
            Clerp(Neck,NeckOrg)
            Clerp(RootJoint,RootJointOrg * ANGLES(0,0,RAD(-45)))
            Clerp(LeftShoulder,LeftShoulderOrg * ANGLES(RAD(60),0,RAD(15)))
            Clerp(RightShoulder,RightShoulderOrg * ANGLES(RAD(60),0,RAD(-15)))
            Clerp(LeftHip,LeftHipOrg * CF(.5,-.5,0))
            Clerp(RightHip,RightHipOrg)
            
            Clerp(Neck,NeckOrg,false)
            Clerp(RootJoint,RootJointOrg * CF(0,0,.5),false)
            Clerp(LeftShoulder,LeftShoulderOrg * CF(0,-.5,0) * ANGLES(RAD(-45),0,RAD(15)),false)
            Clerp(RightShoulder,RightShoulderOrg * CF(0,-.5,0) * ANGLES(RAD(-45),0,RAD(-15)),false)
            Clerp(LeftHip,LeftHipOrg * CF(.5,-.5,0),false)
            Clerp(RightHip,RightHipOrg * CF(-.5,-.5,0),false)
            
            Clerp(Neck,NeckOrg)
            Clerp(RootJoint,RootJointOrg * ANGLES(0,0,RAD(45)))
            Clerp(LeftShoulder,LeftShoulderOrg * ANGLES(RAD(-105),0,RAD(20)))
            Clerp(RightShoulder,RightShoulderOrg * ANGLES(RAD(-105),0,RAD(-20)))
            Clerp(LeftHip,LeftHipOrg)
            Clerp(RightHip,RightHipOrg * CF(-.5,-.5,0))
            
            Clerp(Neck,NeckOrg,false)
            Clerp(RootJoint,RootJointOrg * CF(0,0,.5),false)
            Clerp(LeftShoulder,LeftShoulderOrg * ANGLES(RAD(60),0,RAD(15)),false)
            Clerp(RightShoulder,RightShoulderOrg * ANGLES(RAD(60),0,RAD(-15)),false)
            Clerp(LeftHip,LeftHipOrg * CF(.5,-.5,0),false)
            Clerp(RightHip,RightHipOrg * CF(-.5,-.5,0),false)
        end
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
end)

frees:Button("Seizure", "funny button go brr", function()
    	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		local Player = game.Players.LocalPlayer
		for i,v in pairs(game.Players.LocalPlayer.Character.Raw:GetDescendants()) do
			if v:IsA("Motor6D") then
				local Socket = Instance.new("BallSocketConstraint")
				local a1 = Instance.new("Attachment")
				local a2 = Instance.new("Attachment")
				a1.Parent = v.Part0
				a2.Parent = v.Part1
				Socket.Parent = v.Parent
				Socket.Attachment0 = a1
				Socket.Attachment1 = a2
				a1.CFrame = v.C0
				a2.CFrame = v.C1
				Socket.LimitsEnabled = true
				Socket.TwistLimitsEnabled = true
				v:Destroy()
			end

			Player.Character.Humanoid.Sit = true
		end
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
end)

frees:Button("Ragdoll Death", "funny button go brr", function()
        if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
        
		local Player = game.Players.LocalPlayer
		for i,v in pairs(game.Players.LocalPlayer.Character.Raw:GetDescendants()) do
            if v:IsA("Motor6D") and v.Parent.Name ~= "HumanoidRootPart" then
                
				local Socket = Instance.new("BallSocketConstraint")
				local a1 = Instance.new("Attachment")
				local a2 = Instance.new("Attachment")
				a1.Parent = v.Part0
				a2.Parent = v.Part1
				Socket.Parent = v.Parent
				Socket.Attachment0 = a1
				Socket.Attachment1 = a2
				a1.CFrame = v.C0
				a2.CFrame = v.C1
				Socket.LimitsEnabled = true
				Socket.TwistLimitsEnabled = true
				v:Destroy()
			end

            Player.Character.Humanoid.Sit = true
            
        end
        wait(1)
        game.Players.LocalPlayer.Character.Torso.Neck:Destroy()
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
end)

frees:Button("Weird Break Limbs", "funny button go brr", function()
            if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
            local Player = game.Players.LocalPlayer
            for i,v in pairs(game.Players.LocalPlayer.Character.Raw:GetDescendants()) do
                if v:IsA("Motor6D") and v.Parent.Name ~= "HumanoidRootPart" and v.Name ~= "Neck" then
                    local Socket = Instance.new("BallSocketConstraint")
                    local a1 = Instance.new("Attachment")
                    local a2 = Instance.new("Attachment")
                    a1.Parent = v.Part0
                    a2.Parent = v.Part1
                    Socket.Parent = v.Parent
                    Socket.Attachment0 = a1
                    Socket.Attachment1 = a2
                    a1.CFrame = v.C0
                    a2.CFrame = v.C1
                    Socket.LimitsEnabled = false
                    Socket.TwistLimitsEnabled = false
                    v:Destroy()
                end
                Player.Character.Humanoid.RequiresNeck = false
    
            end
        else
            game.StarterGui:SetCore("ChatMakeSystemMessage", {
                Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
                Color = Color3.fromRGB(255, 0, 0),
                TextSize = 20,
                Font = Enum.Font.Cartoon
            });
        end
end)
frees:Button("Master of Elements", "funny button go brr", function()
            if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
            Player=game:GetService("Players").LocalPlayer
Character=Player.Character.Raw
hum = Character.Humanoid
LeftArm=Character["Left Arm"]
LeftLeg=Character["Left Leg"]
RightArm=Character["Right Arm"]
RightLeg=Character["Right Leg"]
Root=Character["HumanoidRootPart"]
Head=Character["Head"]
Torso=Character["Torso"]
Neck=Torso["Neck"]
attacking = false
laughing = false
running = false
touchedistrue = false
throw1 = true
throw2 = false
downpress = false
id = 2435339444
taim = nil
change = 0
ws = 90
avatarstate = false
hpheight = 5
appi = false
dontforgetthisbool = false
ravagewind = false
fireball1 = true
firsttimewtr = false
nottouched = false
nottouched2 = false
fireball2 = false
breakwaterm = false
tauntdebounce = false
allowlev = true
position = nil
spwt = false
MseGuide = true
tornadobounce = false
bbv = false
levitate = false
firsttime = false
apocalypse = false
powvol = 0
waterp = false
spinwater = false
settime = 0
waterz = false
winddashing = false
bluetotem = false
browntotem = false
redtotem = false
whitetotem = false
sine = 0
t = 0
dgs = 75
mouse = Player:GetMouse()
RunSrv = game:GetService("RunService")
RenderStepped = game:GetService("RunService").RenderStepped
removeuseless = game:GetService("Debris")
grasstable={}
watertable={}
colortable={"Bright yellow","Bright orange"}
colortable2={"Cyan","Light Royal blue"}
pitchtable={1.1,1.05,1,.95,.9,.95,.8,.75,1.001,1.2}
gottalktable = {2489876894,2489876696,2489876326,2489876052,2489875728}
got = #gottalktable
gottalktable2 = {2492598999,2492599159,2492599503,2492599303,2492599663,2492599795,2492599925,2492600097,2492600455,2492600258}
got2 = #gottalktable2
randompitch = #pitchtable
colors = #colortable
colors2 = #colortable2

screenGui = Instance.new("ScreenGui")
screenGui.Parent = script.Parent

local HEADLERP = Instance.new("ManualWeld")
HEADLERP.Parent = Head
HEADLERP.Part0 = Head
HEADLERP.Part1 = Head
HEADLERP.C0 = CFrame.new(0, -1.5, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local TORSOLERP = Instance.new("ManualWeld")
TORSOLERP.Parent = Root
TORSOLERP.Part0 = Torso
TORSOLERP.C0 = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local ROOTLERP = Instance.new("ManualWeld")
ROOTLERP.Parent = Root
ROOTLERP.Part0 = Root
ROOTLERP.Part1 = Torso
ROOTLERP.C0 = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local RIGHTARMLERP = Instance.new("ManualWeld")
RIGHTARMLERP.Parent = RightArm
RIGHTARMLERP.Part0 = RightArm
RIGHTARMLERP.Part1 = Torso
RIGHTARMLERP.C0 = CFrame.new(-1.5, 0, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local LEFTARMLERP = Instance.new("ManualWeld")
LEFTARMLERP.Parent = LeftArm
LEFTARMLERP.Part0 = LeftArm
LEFTARMLERP.Part1 = Torso
LEFTARMLERP.C0 = CFrame.new(1.5, 0, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local RIGHTLEGLERP = Instance.new("ManualWeld")
RIGHTLEGLERP.Parent = RightLeg
RIGHTLEGLERP.Part0 = RightLeg
RIGHTLEGLERP.Part1 = Torso
RIGHTLEGLERP.C0 = CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local LEFTLEGLERP = Instance.new("ManualWeld")
LEFTLEGLERP.Parent = LeftLeg
LEFTLEGLERP.Part0 = LeftLeg
LEFTLEGLERP.Part1 = Torso
LEFTLEGLERP.C0 = CFrame.new(0.5, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local function weldBetween(a, b)
    local weld = Instance.new("ManualWeld", a)
    weld.Part0 = a
    weld.Part1 = b
    weld.C0 = a.CFrame:inverse() * b.CFrame
    return weld
end

function MAKETRAIL(PARENT,POSITION1,POSITION2,LIFETIME,COLOR)
A = Instance.new("Attachment", PARENT)
A.Position = POSITION1
A.Name = "A"
B = Instance.new("Attachment", PARENT)
B.Position = POSITION2
B.Name = "B"
tr1 = Instance.new("Trail", PARENT)
tr1.Attachment0 = A
tr1.Attachment1 = B
tr1.Enabled = true
tr1.Lifetime = LIFETIME
tr1.TextureMode = "Static"
tr1.LightInfluence = 0
tr1.Color = COLOR
tr1.Transparency = NumberSequence.new(0, 1)
end

coroutine.wrap(function()
while wait() do
if allowlev then
hum.HipHeight = hpheight
end
hum.WalkSpeed = ws
LeftArm.BrickColor = BrickColor.new("Really black")
RightArm.BrickColor = BrickColor.new("Really black")
Head.BrickColor = BrickColor.new("Really black")
end
end)()
godmode = coroutine.wrap(function()
for i,v in pairs(Character:GetChildren()) do
if v:IsA("BasePart") and v ~= Root then
v.Anchored = false
end
end
while true do
hum.MaxHealth = math.huge
wait(0.0000001)
hum.Health = math.huge
wait()
end
end)
godmode()
ff = Instance.new("ForceField", Character)
ff.Visible = false

coroutine.wrap(function()
for i,v in pairs(Character:GetChildren()) do
if v.Name == "Animate" then v:Remove()
end
end
end)()

function damagealll(Radius,Position)		
return
end

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"
script:WaitForChild("Heartbeat")

frame = 1 / 60
tf = 0
allowframeloss = false
tossremainder = false


lastframe = tick()
script.Heartbeat:Fire()


game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.Heartbeat:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

function swait(num)
	if num == 0 or num == nil then
		game:service("RunService").Stepped:wait(0)
	else
		for i = 0, num do
			game:service("RunService").Stepped:wait(0)
		end
	end
end

doomtheme = Instance.new("Sound", Torso)
doomtheme.Volume = 3
doomtheme.Name = "doomtheme"
doomtheme.Looped = true
doomtheme.SoundId = "rbxassetid://"..id
doomtheme:Play()

Powerup = Instance.new("Sound",Torso)
Powerup.Volume = powvol
Powerup.SoundId = "rbxassetid://2492215919"
Powerup.Name = "powerup"
Powerup:Play()
Powerup.Looped = true

Torso.ChildRemoved:connect(function(removed)
if removed.Name == "doomtheme" then
doomtheme = Instance.new("Sound", Torso)
if avatarstate then
doomtheme.Volume = 6
else
doomtheme.Volume = 3
end
doomtheme.Name = "doomtheme"
doomtheme.Looped = true
if avatarstate then
doomtheme.SoundId = "rbxassetid://2497727458"
else
doomtheme.SoundId = "rbxassetid://"..id
end
doomtheme:Play()
end
end)

coroutine.wrap(function()
while wait() do
pcall(function()
Powerup.Volume = powvol
end)
end
end)()

Torso.ChildRemoved:connect(function(removed)
if removed.Name == "powerup" then
Powerup = Instance.new("Sound",Torso)
Powerup.Volume = powvol
Powerup.SoundId = "rbxassetid://2492215919"
Powerup.Name = "powerup"
Powerup:Play()
Powerup.Looped = true
end
end)

function SOUND(PARENT,ID,VOL,LOOP,REMOVE)
so = Instance.new("Sound")
so.Parent = PARENT
so.SoundId = "rbxassetid://"..ID
so.Volume = VOL
so.Looped = LOOP
so:Play()
removeuseless:AddItem(so,REMOVE)
end

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='m' then
if debounce then return end
debounce = true
attacking = true
allowlev = false
dontforgetthisbool = true
coroutine.wrap(function()
while dontforgetthisbool do
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0 - 0*math.sin(sine/12)),math.rad(0),math.rad(0)),.1)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(.7,1.705,-.2) * CFrame.Angles(math.rad(-10),math.rad(-0),math.rad(75 + 1 *math.sin(sine/12))),.1)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.7,1.705,-.2) * CFrame.Angles(math.rad(-10),math.rad(-0),math.rad(-75 - 1 *math.sin(sine/12))),.1)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.7, 1.8,0) * CFrame.Angles(math.rad(3), math.rad(0), math.rad(10 + 2 * math.sin(sine/12))), 0.1)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.7, 1.8,0) * CFrame.Angles(math.rad(-3), math.rad(0), math.rad(-10 - 2 * math.sin(sine/12))), 0.1)
swait()
end
end)()
craterloc = Instance.new("Part",Torso)
craterloc.Size = Vector3.new(1,1,1)
craterloc.Transparency = 0
craterloc.Anchored = false
craterloc.CanCollide = false
craterlocweld = weldBetween(craterloc,levitatewave)
bnmv = 0
for i = 1, 75 do
bnmv = bnmv + 15
grassblocks = Instance.new("Part",Torso)
grassblocks.Size = Vector3.new(1,1,1)
grassblocks.Material = "Grass"
grassblocks.Anchored = false
grassblocks.Transparency = 0
grassblocks.CanCollide = false
grassblocks.Name = "nme"
grassblockswld = weldBetween(grassblocks,craterloc)
grassblockswld.C0 = CFrame.new(-15,0,0) * CFrame.Angles(math.rad(0),math.rad(bnmv),0)
removeuseless:AddItem(grassblocks,25)
crater2 = Instance.new("Part",Torso)
crater2.CFrame = grassblocks.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
crater2.Size = Vector3.new(6.5,6.5,6.5)
crater2.Anchored = true
crater2.Name = "cr2"
crater2.CanCollide = false
crater2.Transparency = 1
crater2.Material = "Grass"
crater2.BrickColor = BrickColor.new("Bright green")
grassblockswld:Remove()
end
grassblockswld:Remove()
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "nme" then
v.Anchored = true
end
end
coroutine.wrap(function()
for i = 1, 100 do
swait()
for i,v in pairs(Torso:GetChildren()) do if v.Name == "ele" then
v.Transparency = v.Transparency + .05
end
end
end
end)()
elesize = .1
coroutine.wrap(function()
for i = 1, 10 do
shockwef = Instance.new("Part",Torso)
shockwef.Anchored = true
shockwef.CanCollide = false
shockwef.Size = Vector3.new(4,4,4)
shockwef.CFrame = Root.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
shockwef.BrickColor = BrickColor.new("White")
shockwef.Transparency = .5
shockwef.Material = "Neon"
shockwef.Name = "corodaad"
removeuseless:AddItem(shockwef,5)
for i,v in pairs(Torso:GetChildren()) do if v.Name == "corodaad" then v.Size = v.Size + Vector3.new(2,2,2) v.Transparency = v.Transparency + .05 end end
swait()
end
for i = 1, 25 do
for i,v in pairs(Torso:GetChildren()) do if v.Name == "corodaad" then v.Size = v.Size + Vector3.new(2,2,2) v.Transparency = v.Transparency + .05 end end
swait()
end
end)()
for i = 1, 100 do
elesize = elesize + .25
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "nme" then
elementblock = Instance.new("Part",Torso)
elementblock.Size = Vector3.new(3.5+elesize,3.5+elesize,3.5+elesize)
elementblock.Transparency = 0
elementblock.Anchored = true
elementblock.CanCollide = false
elementblock.CFrame = v.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
elementblock.Material = "Grass"
elementblock.BrickColor = BrickColor.new("Bright green")
elementblock.Name = "ele"
removeuseless:AddItem(elementblock,1.5)
craterswoo = v
v.CFrame = v.CFrame * CFrame.new(2,0,2)
end
end
swait()
end
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "nme" then
v:Remove()
end
end
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "cr2" then
v:Remove()
end
end
craterloc:Remove()
craterloc = Instance.new("Part",Torso)
craterloc.Size = Vector3.new(1,1,1)
craterloc.Transparency = 0
craterloc.Anchored = false
craterloc.CanCollide = false
craterlocweld = weldBetween(craterloc,levitatewave)
bnmv = 0
for i = 1, 75 do
bnmv = bnmv + 15
grassblocks = Instance.new("Part",Torso)
grassblocks.Size = Vector3.new(1,1,1)
grassblocks.Material = "Grass"
grassblocks.Anchored = false
grassblocks.Transparency = 0
grassblocks.CanCollide = false
grassblocks.Name = "nme"
grassblockswld = weldBetween(grassblocks,craterloc)
grassblockswld.C0 = CFrame.new(-15,0,0) * CFrame.Angles(math.rad(0),math.rad(bnmv),0)
removeuseless:AddItem(grassblocks,25)
crater2 = Instance.new("Part",Torso)
crater2.CFrame = grassblocks.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
crater2.Size = Vector3.new(6.5,6.5,6.5)
crater2.Anchored = true
crater2.Name = "cr2"
crater2.CanCollide = false
crater2.Transparency = 1
crater2.Material = "Grass"
crater2.BrickColor = BrickColor.new("Cyan")
grassblockswld:Remove()
end
grassblockswld:Remove()
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "nme" then
v.Anchored = true
end
end
coroutine.wrap(function()
for i = 1, 100 do
swait()
for i,v in pairs(Torso:GetChildren()) do if v.Name == "ele" then
v.Transparency = v.Transparency + .05
end
end
end
end)()
elesize = .1
coroutine.wrap(function()
for i = 1, 10 do
shockwef = Instance.new("Part",Torso)
shockwef.Anchored = true
shockwef.CanCollide = false
shockwef.Size = Vector3.new(4,4,4)
shockwef.CFrame = Root.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
shockwef.BrickColor = BrickColor.new("White")
shockwef.Transparency = .5
shockwef.Material = "Neon"
shockwef.Name = "corodaad"
removeuseless:AddItem(shockwef,5)
for i,v in pairs(Torso:GetChildren()) do if v.Name == "corodaad" then v.Size = v.Size + Vector3.new(2,2,2) v.Transparency = v.Transparency + .05 end end
swait()
end
for i = 1, 25 do
for i,v in pairs(Torso:GetChildren()) do if v.Name == "corodaad" then v.Size = v.Size + Vector3.new(2,2,2) v.Transparency = v.Transparency + .05 end end
swait()
end
end)()
for i = 1, 100 do
elesize = elesize + .25
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "nme" then
colors = colortable[math.random(1,#colortable)]
elementblock = Instance.new("Part",Torso)
elementblock.Size = Vector3.new(3.5+elesize,3.5+elesize,3.5+elesize)
elementblock.Transparency = .5
elementblock.Anchored = true
elementblock.CanCollide = false
elementblock.Material = "Neon"
elementblock.CFrame = v.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
elementblock.BrickColor = BrickColor.new(colors)
elementblock.Name = "ele"
removeuseless:AddItem(elementblock,1.5)
craterswoo = v
v.CFrame = v.CFrame * CFrame.new(2,0,2)
end
end
swait()
end
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "nme" then
v:Remove()
end
end
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "cr2" then
v:Remove()
end
end
craterloc:Remove()
craterloc = Instance.new("Part",Torso)
craterloc.Size = Vector3.new(1,1,1)
craterloc.Transparency = 0
craterloc.Anchored = false
craterloc.CanCollide = false
craterlocweld = weldBetween(craterloc,levitatewave)
bnmv = 0
for i = 1, 75 do
bnmv = bnmv + 15
grassblocks = Instance.new("Part",Torso)
grassblocks.Size = Vector3.new(1,1,1)
grassblocks.Material = "Grass"
grassblocks.Anchored = false
grassblocks.Transparency = 0
grassblocks.CanCollide = false
grassblocks.Name = "nme"
grassblockswld = weldBetween(grassblocks,craterloc)
grassblockswld.C0 = CFrame.new(-15,0,0) * CFrame.Angles(math.rad(0),math.rad(bnmv),0)
removeuseless:AddItem(grassblocks,25)
crater2 = Instance.new("Part",Torso)
crater2.CFrame = grassblocks.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
crater2.Size = Vector3.new(6.5,6.5,6.5)
crater2.Anchored = true
crater2.Name = "cr2"
crater2.CanCollide = false
crater2.Transparency = 1
crater2.Material = "Grass"
crater2.BrickColor = BrickColor.new("Cyan")
grassblockswld:Remove()
end
grassblockswld:Remove()
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "nme" then
v.Anchored = true
end
end
coroutine.wrap(function()
for i = 1, 100 do
swait()
for i,v in pairs(Torso:GetChildren()) do if v.Name == "ele" then
v.Transparency = v.Transparency + .05
end
end
end
end)()
elesize = .1
coroutine.wrap(function()
for i = 1, 10 do
shockwef = Instance.new("Part",Torso)
shockwef.Anchored = true
shockwef.CanCollide = false
shockwef.Size = Vector3.new(4,4,4)
shockwef.CFrame = Root.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
shockwef.BrickColor = BrickColor.new("White")
shockwef.Transparency = .5
shockwef.Material = "Neon"
shockwef.Name = "corodaad"
removeuseless:AddItem(shockwef,5)
for i,v in pairs(Torso:GetChildren()) do if v.Name == "corodaad" then v.Size = v.Size + Vector3.new(2,2,2) v.Transparency = v.Transparency + .05 end end
swait()
end
for i = 1, 25 do
for i,v in pairs(Torso:GetChildren()) do if v.Name == "corodaad" then v.Size = v.Size + Vector3.new(2,2,2) v.Transparency = v.Transparency + .05 end end
swait()
end
end)()
for i = 1, 100 do
elesize = elesize + .25
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "nme" then
colors2 = colortable2[math.random(1,#colortable2)]
elementblock = Instance.new("Part",Torso)
elementblock.Size = Vector3.new(3.5+elesize,3.5+elesize,3.5+elesize)
elementblock.Transparency = .5
elementblock.Anchored = true
elementblock.CanCollide = false
elementblock.Material = "Neon"
elementblock.CFrame = v.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
elementblock.BrickColor = BrickColor.new(colors2)
elementblock.Name = "ele"
removeuseless:AddItem(elementblock,1.5)
craterswoo = v
v.CFrame = v.CFrame * CFrame.new(2,0,2)
end
end
swait()
end
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "nme" then
v:Remove()
end
end
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "cr2" then
v:Remove()
end
end
craterloc:Remove()
craterloc = Instance.new("Part",Torso)
craterloc.Size = Vector3.new(1,1,1)
craterloc.Transparency = 0
craterloc.Anchored = false
craterloc.CanCollide = false
craterlocweld = weldBetween(craterloc,levitatewave)
bnmv = 0
for i = 1, 100 do
bnmv = bnmv + 15
grassblocks = Instance.new("Part",Torso)
grassblocks.Size = Vector3.new(1,1,1)
grassblocks.Material = "Grass"
grassblocks.Anchored = false
grassblocks.Transparency = 0
grassblocks.CanCollide = false
grassblocks.Name = "nme"
grassblockswld = weldBetween(grassblocks,craterloc)
grassblockswld.C0 = CFrame.new(-15,0,0) * CFrame.Angles(math.rad(0),math.rad(bnmv),0)
removeuseless:AddItem(grassblocks,25)
crater2 = Instance.new("Part",Torso)
crater2.CFrame = grassblocks.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
crater2.Size = Vector3.new(6.5,6.5,6.5)
crater2.Anchored = true
crater2.Name = "cr2"
crater2.CanCollide = false
crater2.Transparency = 1
crater2.Material = "Neon"
crater2.BrickColor = BrickColor.new("White")
grassblockswld:Remove()
end
grassblockswld:Remove()
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "nme" then
v.Anchored = true
end
end
coroutine.wrap(function()
for i = 1, 100 do
swait()
for i,v in pairs(Torso:GetChildren()) do if v.Name == "ele" then
v.Transparency = v.Transparency + .05
end
end
end
end)()
elesize = .1
coroutine.wrap(function()
for i = 1, 10 do
shockwef = Instance.new("Part",Torso)
shockwef.Anchored = true
shockwef.CanCollide = false
shockwef.Size = Vector3.new(4,4,4)
shockwef.CFrame = Root.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
shockwef.BrickColor = BrickColor.new("White")
shockwef.Transparency = .5
shockwef.Material = "Neon"
shockwef.Name = "corodaad"
removeuseless:AddItem(shockwef,5)
for i,v in pairs(Torso:GetChildren()) do if v.Name == "corodaad" then v.Size = v.Size + Vector3.new(2,2,2) v.Transparency = v.Transparency + .05 end end
swait()
end
for i = 1, 25 do
for i,v in pairs(Torso:GetChildren()) do if v.Name == "corodaad" then v.Size = v.Size + Vector3.new(2,2,2) v.Transparency = v.Transparency + .05 end end
swait()
end
end)()
for i = 1, 75 do
elesize = elesize + .25
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "nme" then
elementblock = Instance.new("Part",Torso)
elementblock.Size = Vector3.new(3.5+elesize,3.5+elesize,3.5+elesize)
elementblock.Transparency = .5
elementblock.Anchored = true
elementblock.CanCollide = false
elementblock.Material = "Neon"
elementblock.CFrame = v.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
elementblock.BrickColor = BrickColor.new("White")
elementblock.Name = "ele"
removeuseless:AddItem(elementblock,1.5)
craterswoo = v
v.CFrame = v.CFrame * CFrame.new(2,0,2)
end
end
swait()
end
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "nme" then
v:Remove()
end
end
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "cr2" then
v:Remove()
end
end
craterloc:Remove()
for i = 1, 2 do
swait()
craterloc = Instance.new("Part",Torso)
craterloc.Size = Vector3.new(1,1,1)
craterloc.Transparency = 0
craterloc.Anchored = false
craterloc.CanCollide = false
craterlocweld = weldBetween(craterloc,levitatewave)
bnmv = 0
for i = 1, 40 do
bnmv = bnmv + 15
grassblocks = Instance.new("Part",Torso)
grassblocks.Size = Vector3.new(1,1,1)
grassblocks.Material = "Grass"
grassblocks.Anchored = false
grassblocks.Transparency = 0
grassblocks.CanCollide = false
grassblocks.Name = "nme"
grassblockswld = weldBetween(grassblocks,craterloc)
grassblockswld.C0 = CFrame.new(-15,0,0) * CFrame.Angles(math.rad(0),math.rad(bnmv),0)
removeuseless:AddItem(grassblocks,25)
crater2 = Instance.new("Part",Torso)
crater2.CFrame = grassblocks.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
crater2.Size = Vector3.new(6.5,6.5,6.5)
crater2.Anchored = true
crater2.Name = "cr2"
crater2.CanCollide = false
crater2.Transparency = 1
crater2.Material = "Grass"
crater2.BrickColor = BrickColor.new("Bright green")
grassblockswld:Remove()
end
grassblockswld:Remove()
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "nme" then
v.Anchored = true
end
end
coroutine.wrap(function()
for i = 1, 100 do
swait()
for i,v in pairs(Torso:GetChildren()) do if v.Name == "ele" then
v.Transparency = v.Transparency + .025
end
end
end
end)()
elesize = .1
coroutine.wrap(function()
for i = 1, 10 do
shockwef = Instance.new("Part",Torso)
shockwef.Anchored = true
shockwef.CanCollide = false
shockwef.Size = Vector3.new(4,4,4)
shockwef.CFrame = Root.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
shockwef.BrickColor = BrickColor.new("White")
shockwef.Transparency = .5
shockwef.Material = "Neon"
shockwef.Name = "corodaad"
removeuseless:AddItem(shockwef,5)
for i,v in pairs(Torso:GetChildren()) do if v.Name == "corodaad" then v.Size = v.Size + Vector3.new(5,5,5) v.Transparency = v.Transparency + .05 end end
swait()
end
for i = 1, 25 do
for i,v in pairs(Torso:GetChildren()) do if v.Name == "corodaad" then v.Size = v.Size + Vector3.new(5,5,5) v.Transparency = v.Transparency + .05 end end
swait()
end
end)()
for i = 1, 40 do
elesize = elesize + 1
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "nme" then
elementblock = Instance.new("Part",Torso)
elementblock.Size = Vector3.new(3.5+elesize,3.5+elesize,3.5+elesize)
elementblock.Transparency = 0
elementblock.Anchored = true
elementblock.CanCollide = false
elementblock.CFrame = v.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
elementblock.Material = "Grass"
elementblock.BrickColor = BrickColor.new("Bright green")
elementblock.Name = "ele"
removeuseless:AddItem(elementblock,3)
craterswoo = v
v.CFrame = v.CFrame * CFrame.new(3,0,12)
end
end
swait()
end
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "nme" then
v:Remove()
end
end
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "cr2" then
v:Remove()
end
end
craterloc:Remove()
craterloc = Instance.new("Part",Torso)
craterloc.Size = Vector3.new(1,1,1)
craterloc.Transparency = 0
craterloc.Anchored = false
craterloc.CanCollide = false
craterlocweld = weldBetween(craterloc,levitatewave)
bnmv = 0
for i = 1, 40 do
bnmv = bnmv + 15
grassblocks = Instance.new("Part",Torso)
grassblocks.Size = Vector3.new(1,1,1)
grassblocks.Material = "Grass"
grassblocks.Anchored = false
grassblocks.Transparency = 0
grassblocks.CanCollide = false
grassblocks.Name = "nme"
grassblockswld = weldBetween(grassblocks,craterloc)
grassblockswld.C0 = CFrame.new(-15,0,0) * CFrame.Angles(math.rad(0),math.rad(bnmv),0)
removeuseless:AddItem(grassblocks,25)
crater2 = Instance.new("Part",Torso)
crater2.CFrame = grassblocks.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
crater2.Size = Vector3.new(6.5,6.5,6.5)
crater2.Anchored = true
crater2.Name = "cr2"
crater2.CanCollide = false
crater2.Transparency = 1
crater2.Material = "Grass"
crater2.BrickColor = BrickColor.new("Cyan")
grassblockswld:Remove()
end
grassblockswld:Remove()
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "nme" then
v.Anchored = true
end
end
coroutine.wrap(function()
for i = 1, 100 do
swait()
for i,v in pairs(Torso:GetChildren()) do if v.Name == "ele" then
v.Transparency = v.Transparency + .025
end
end
end
end)()
elesize = .1
coroutine.wrap(function()
for i = 1, 10 do
shockwef = Instance.new("Part",Torso)
shockwef.Anchored = true
shockwef.CanCollide = false
shockwef.Size = Vector3.new(4,4,4)
shockwef.CFrame = Root.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
shockwef.BrickColor = BrickColor.new("White")
shockwef.Transparency = .5
shockwef.Material = "Neon"
shockwef.Name = "corodaad"
removeuseless:AddItem(shockwef,5)
for i,v in pairs(Torso:GetChildren()) do if v.Name == "corodaad" then v.Size = v.Size + Vector3.new(5,5,5) v.Transparency = v.Transparency + .05 end end
swait()
end
for i = 1, 25 do
for i,v in pairs(Torso:GetChildren()) do if v.Name == "corodaad" then v.Size = v.Size + Vector3.new(5,5,5) v.Transparency = v.Transparency + .05 end end
swait()
end
end)()
for i = 1, 40 do
elesize = elesize + 1
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "nme" then
colors = colortable[math.random(1,#colortable)]
elementblock = Instance.new("Part",Torso)
elementblock.Size = Vector3.new(3.5+elesize,3.5+elesize,3.5+elesize)
elementblock.Transparency = .5
elementblock.Anchored = true
elementblock.CanCollide = false
elementblock.Material = "Neon"
elementblock.CFrame = v.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
elementblock.BrickColor = BrickColor.new(colors)
elementblock.Name = "ele"
removeuseless:AddItem(elementblock,3)
craterswoo = v
v.CFrame = v.CFrame * CFrame.new(3,0,12)
end
end
swait()
end
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "nme" then
v:Remove()
end
end
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "cr2" then
v:Remove()
end
end
craterloc:Remove()
craterloc = Instance.new("Part",Torso)
craterloc.Size = Vector3.new(1,1,1)
craterloc.Transparency = 0
craterloc.Anchored = false
craterloc.CanCollide = false
craterlocweld = weldBetween(craterloc,levitatewave)
bnmv = 0
for i = 1, 40 do
bnmv = bnmv + 15
grassblocks = Instance.new("Part",Torso)
grassblocks.Size = Vector3.new(1,1,1)
grassblocks.Material = "Grass"
grassblocks.Anchored = false
grassblocks.Transparency = 0
grassblocks.CanCollide = false
grassblocks.Name = "nme"
grassblockswld = weldBetween(grassblocks,craterloc)
grassblockswld.C0 = CFrame.new(-15,0,0) * CFrame.Angles(math.rad(0),math.rad(bnmv),0)
removeuseless:AddItem(grassblocks,25)
crater2 = Instance.new("Part",Torso)
crater2.CFrame = grassblocks.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
crater2.Size = Vector3.new(6.5,6.5,6.5)
crater2.Anchored = true
crater2.Name = "cr2"
crater2.CanCollide = false
crater2.Transparency = 1
crater2.Material = "Grass"
crater2.BrickColor = BrickColor.new("Cyan")
grassblockswld:Remove()
end
grassblockswld:Remove()
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "nme" then
v.Anchored = true
end
end
coroutine.wrap(function()
for i = 1, 100 do
swait()
for i,v in pairs(Torso:GetChildren()) do if v.Name == "ele" then
v.Transparency = v.Transparency + .025
end
end
end
end)()
elesize = .1
coroutine.wrap(function()
for i = 1, 10 do
shockwef = Instance.new("Part",Torso)
shockwef.Anchored = true
shockwef.CanCollide = false
shockwef.Size = Vector3.new(4,4,4)
shockwef.CFrame = Root.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
shockwef.BrickColor = BrickColor.new("White")
shockwef.Transparency = .5
shockwef.Material = "Neon"
shockwef.Name = "corodaad"
removeuseless:AddItem(shockwef,5)
for i,v in pairs(Torso:GetChildren()) do if v.Name == "corodaad" then v.Size = v.Size + Vector3.new(5,5,5) v.Transparency = v.Transparency + .05 end end
swait()
end
for i = 1, 25 do
for i,v in pairs(Torso:GetChildren()) do if v.Name == "corodaad" then v.Size = v.Size + Vector3.new(5,5,5) v.Transparency = v.Transparency + .05 end end
swait()
end
end)()
for i = 1, 40 do
elesize = elesize + 1
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "nme" then
colors2 = colortable2[math.random(1,#colortable2)]
elementblock = Instance.new("Part",Torso)
elementblock.Size = Vector3.new(3.5+elesize,3.5+elesize,3.5+elesize)
elementblock.Transparency = .5
elementblock.Anchored = true
elementblock.CanCollide = false
elementblock.Material = "Neon"
elementblock.CFrame = v.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
elementblock.BrickColor = BrickColor.new(colors2)
elementblock.Name = "ele"
removeuseless:AddItem(elementblock,3)
craterswoo = v
v.CFrame = v.CFrame * CFrame.new(3,0,12)
end
end
swait()
end
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "nme" then
v:Remove()
end
end
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "cr2" then
v:Remove()
end
end
craterloc:Remove()
craterloc = Instance.new("Part",Torso)
craterloc.Size = Vector3.new(1,1,1)
craterloc.Transparency = 0
craterloc.Anchored = false
craterloc.CanCollide = false
craterlocweld = weldBetween(craterloc,levitatewave)
bnmv = 0
for i = 1, 40 do
bnmv = bnmv + 15
grassblocks = Instance.new("Part",Torso)
grassblocks.Size = Vector3.new(1,1,1)
grassblocks.Material = "Grass"
grassblocks.Anchored = false
grassblocks.Transparency = 0
grassblocks.CanCollide = false
grassblocks.Name = "nme"
grassblockswld = weldBetween(grassblocks,craterloc)
grassblockswld.C0 = CFrame.new(-15,0,0) * CFrame.Angles(math.rad(0),math.rad(bnmv),0)
removeuseless:AddItem(grassblocks,25)
crater2 = Instance.new("Part",Torso)
crater2.CFrame = grassblocks.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
crater2.Size = Vector3.new(6.5,6.5,6.5)
crater2.Anchored = true
crater2.Name = "cr2"
crater2.CanCollide = false
crater2.Transparency = 1
crater2.Material = "Neon"
crater2.BrickColor = BrickColor.new("White")
grassblockswld:Remove()
end
grassblockswld:Remove()
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "nme" then
v.Anchored = true
end
end
coroutine.wrap(function()
for i = 1, 100 do
swait()
for i,v in pairs(Torso:GetChildren()) do if v.Name == "ele" then
v.Transparency = v.Transparency + .025
end
end
end
end)()
elesize = .1
coroutine.wrap(function()
for i = 1, 10 do
shockwef = Instance.new("Part",Torso)
shockwef.Anchored = true
shockwef.CanCollide = false
shockwef.Size = Vector3.new(4,4,4)
shockwef.CFrame = Root.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
shockwef.BrickColor = BrickColor.new("White")
shockwef.Transparency = .5
shockwef.Material = "Neon"
shockwef.Name = "corodaad"
removeuseless:AddItem(shockwef,5)
for i,v in pairs(Torso:GetChildren()) do if v.Name == "corodaad" then v.Size = v.Size + Vector3.new(5,5,5) v.Transparency = v.Transparency + .05 end end
swait()
end
for i = 1, 25 do
for i,v in pairs(Torso:GetChildren()) do if v.Name == "corodaad" then v.Size = v.Size + Vector3.new(5,5,5) v.Transparency = v.Transparency + .05 end end
swait()
end
end)()
for i = 1, 40 do
elesize = elesize + 1
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "nme" then
elementblock = Instance.new("Part",Torso)
elementblock.Size = Vector3.new(3.5+elesize,3.5+elesize,3.5+elesize)
elementblock.Transparency = .5
elementblock.Anchored = true
elementblock.CanCollide = false
elementblock.Material = "Neon"
elementblock.CFrame = v.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
elementblock.BrickColor = BrickColor.new("White")
elementblock.Name = "ele"
removeuseless:AddItem(elementblock,3)
craterswoo = v
v.CFrame = v.CFrame * CFrame.new(3,0,12)
end
end
swait()
end
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "nme" then
v:Remove()
end
end
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "cr2" then
v:Remove()
end
end
craterloc:Remove()
end
elseif Press=='n' then
if debounce then return end
if bluetotem then return end
if whitetotem then return end
if redtotem then return end
if browntotem then
debounce = true
particlemiter1.Enabled = false
particlemiter2.Enabled = false
particlemiter4.Enabled = false
particlemiter5.Enabled = false
particlemiter6.Enabled = false
particlemiter7.Enabled = false
SOUND(locbrick,1119859528,8,false,5)
coroutine.wrap(function()
for i = 1, 35 do
swait()
powvol = powvol - .075
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "crator" then
v.Transparency = v.Transparency + .05
end
end
end
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "crator" then
v:Remove()
end
end
end)()
for i = 1, 5 do
rockttm.CFrame = rockttm.CFrame * CFrame.new(0,.25,0)
swait()
end
for i = 1, 15 do
rockttm.CFrame = rockttm.CFrame * CFrame.new(0,-2,0)
swait()
end
browntotem = false
rockttm:Remove()
debounce = false
else
ws = 16
browntotem = true
debounce = true
attacking = true
got = gottalktable[math.random(1,#gottalktable)]
smh = Instance.new("Sound", Head)
if avatarstate then
smh.Volume = 10
else
smh.Volume = 8
end
smh.SoundId = "http://www.roblox.com/asset/?id="..got
smh.Looped = false
if avatarstate then
smh.Pitch = .85
else
smh.Pitch = 1
end
smh:Play()
removeuseless:AddItem(smh,5)
g1 = Instance.new("BodyGyro", Root)
g1.D = 175
g1.P = 20000
g1.MaxTorque = Vector3.new(0,9000,0)
for i = 1, 15 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.2)
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(-30),0,0),.4)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.3,0,.2) * CFrame.Angles(math.rad(30),math.rad(30),0),.4)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.3,0,.2) * CFrame.Angles(math.rad(30),math.rad(-30),0),.4)
swait()
end
particlecolor = ColorSequence.new(BrickColor.new("Earth green").Color)
particlemiter1.Enabled = true
particlemiter2.Enabled = true
particlemiter4.Enabled = true
particlemiter5.Enabled = true
particlemiter6.Enabled = true
particlemiter7.Enabled = true
rockttm = Instance.new("Part", Torso)
rockttm.Size = Vector3.new(0.5, 0.5, 0.5)
rockttm.Material = "Neon"
rockttm.BrickColor = BrickColor.new("Earth green")
rockttm.Transparency = .5
rockttm.Anchored = true
rockttm.CanCollide = false
rockttm.CFrame = CFrame.new(mouse.Hit.p) * CFrame.new(0,-15,0) * CFrame.Angles(math.rad(math.random(-4,4)),math.rad(math.random(-4,4)),math.rad(math.random(-4,4)))
ttmmeshrock = Instance.new("SpecialMesh", rockttm)
ttmmeshrock.Scale = Vector3.new(.1,.1,.1)
ttmmeshrock.MeshId = "rbxassetid://574506349"
coroutine.wrap(function()
locbrick = Instance.new("Part",Torso)
locbrick.Size = Vector3.new(1,1,1)
locbrick.Transparency = 1
locbrick.CFrame = CFrame.new(mouse.Hit.p)
locbrick.CanCollide = false
locbrick.Anchored = true
locbrick2 = Instance.new("Part",workspace)
locbrick2.Size = Vector3.new(1,1,1)
locbrick2.Transparency = 1
locbrick2.CFrame = CFrame.new(mouse.Hit.p)
locbrick2.CanCollide = false
locbrick2weld = weldBetween(locbrick2,locbrick)
zxp2 = 0
for i = 1, 65 do
zxp2 = zxp2 + 5
crater = Instance.new("Part",Torso)
crater.BrickColor = BrickColor.new("Earth green")
crater.Size = Vector3.new(5,5,5)
crater.Transparency = 1
crater.Name = "crator"
craterweld = weldBetween(crater,locbrick2)
craterweld.C0 = craterweld.C0 * CFrame.new(2.5,0,0) * CFrame.Angles(math.rad(0),math.rad(zxp2),math.rad(0))
crater2 = Instance.new("Part",Torso)
crater2.CFrame = crater.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
crater2.Size = Vector3.new(4,4,4)
crater2.Anchored = true
crater2.Material = "Grass"
crater2.Name = "crator"
crater2.BrickColor = BrickColor.new("Bright green")
end
end)()
shockwave = Instance.new("Part", Torso)
shockwave.Size = Vector3.new(1,1,1)
shockwave.CanCollide = false
shockwave.Anchored = true
shockwave.Transparency = .5
shockwave.BrickColor = BrickColor.new("White")
shockwave.CFrame = CFrame.new(mouse.Hit.p)
shockwavemesh = Instance.new("SpecialMesh", shockwave)
shockwavemesh.Scale = Vector3.new(7,3,7)
shockwavemesh.MeshId = "rbxassetid://20329976"
removeuseless:AddItem(shockwave,4)
shockwave2 = Instance.new("Part", Torso)
shockwave2.Size = Vector3.new(1,1,1)
shockwave2.CanCollide = false
shockwave2.Anchored = true
shockwave2.Transparency = .5
shockwave2.BrickColor = BrickColor.new("White")
shockwave2.CFrame = CFrame.new(mouse.Hit.p)
shockwavemesh2 = Instance.new("SpecialMesh", shockwave2)
shockwavemesh2.Scale = Vector3.new(5,3,5)
shockwavemesh2.MeshId = "rbxassetid://20329976"
removeuseless:AddItem(shockwave2,4)
coroutine.wrap(function()
for i = 1, 30 do
swait()
shockwave.CFrame = shockwave.CFrame * CFrame.Angles(math.rad(0),math.rad(0+15),0)
shockwave2.CFrame = shockwave2.CFrame * CFrame.Angles(math.rad(0),math.rad(0-8),0)
shockwave.Transparency = shockwave.Transparency + 0.025
shockwave2.Transparency = shockwave2.Transparency + 0.025
shockwavemesh2.Scale = shockwavemesh2.Scale + Vector3.new(3,.5,3)
shockwavemesh.Scale = shockwavemesh.Scale + Vector3.new(4,.6,4)
end
end)()
SOUND(locbrick,1119859528,8,false,5)
coroutine.wrap(function()
for i = 1, 10 do
rockttm.CFrame = rockttm.CFrame * CFrame.new(0,2,0)
swait()
end
for i = 1, 8 do
rockttm.CFrame = rockttm.CFrame * CFrame.new(0,.25,0)
swait()
end
for i = 1, 5 do
rockttm.CFrame = rockttm.CFrame * CFrame.new(0,-.25,0)
swait()
end
end)()
for i = 1, 35 do
powvol = powvol + .075
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(30),0,0),.4)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.3,1,.35) * CFrame.Angles(math.rad(-110),math.rad(-12),math.rad(1)),.4)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.3,1,.35) * CFrame.Angles(math.rad(-110),math.rad(12),math.rad(-1)),.4)
swait()
end
removeuseless:AddItem(g1,.001)
debounce = false
attacking = false
ws = 90
end
elseif Press=='b' then
if debounce then return end
if bluetotem then return end
if browntotem then return end
if redtotem then return end
if whitetotem then
debounce = true
particlemiter1.Enabled = false
particlemiter2.Enabled = false
particlemiter4.Enabled = false
particlemiter5.Enabled = false
particlemiter6.Enabled = false
particlemiter7.Enabled = false
SOUND(locbrick,1119859528,8,false,5)
coroutine.wrap(function()
for i = 1, 35 do
swait()
powvol = powvol - .075
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "crator" then
v.Transparency = v.Transparency + .05
end
end
end
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "crator" then
v:Remove()
end
end
end)()
for i = 1, 5 do
rockttm.CFrame = rockttm.CFrame * CFrame.new(0,.25,0)
swait()
end
for i = 1, 15 do
rockttm.CFrame = rockttm.CFrame * CFrame.new(0,-2,0)
swait()
end
whitetotem = false
rockttm:Remove()
debounce = false
else
ws = 16
whitetotem = true
debounce = true
attacking = true
got = gottalktable[math.random(1,#gottalktable)]
smh = Instance.new("Sound", Head)
if avatarstate then
smh.Volume = 10
else
smh.Volume = 8
end
smh.SoundId = "http://www.roblox.com/asset/?id="..got
smh.Looped = false
if avatarstate then
smh.Pitch = .85
else
smh.Pitch = 1
end
smh:Play()
removeuseless:AddItem(smh,5)
g1 = Instance.new("BodyGyro", Root)
g1.D = 175
g1.P = 20000
g1.MaxTorque = Vector3.new(0,9000,0)
for i = 1, 15 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.2)
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(-30),0,0),.4)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.3,0,.2) * CFrame.Angles(math.rad(30),math.rad(30),0),.4)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.3,0,.2) * CFrame.Angles(math.rad(30),math.rad(-30),0),.4)
swait()
end
particlecolor = ColorSequence.new(BrickColor.new("White").Color)
particlemiter1.Enabled = true
particlemiter2.Enabled = true
particlemiter4.Enabled = true
particlemiter5.Enabled = true
particlemiter6.Enabled = true
particlemiter7.Enabled = true
rockttm = Instance.new("Part", Torso)
rockttm.Size = Vector3.new(0.5, 0.5, 0.5)
rockttm.Material = "Neon"
rockttm.BrickColor = BrickColor.new("White")
rockttm.Transparency = .5
rockttm.Anchored = true
rockttm.CanCollide = false
rockttm.CFrame = CFrame.new(mouse.Hit.p) * CFrame.new(0,-15,0) * CFrame.Angles(math.rad(math.random(-4,4)),math.rad(math.random(-4,4)),math.rad(math.random(-4,4)))
ttmmeshrock = Instance.new("SpecialMesh", rockttm)
ttmmeshrock.Scale = Vector3.new(.1,.1,.1)
ttmmeshrock.MeshId = "rbxassetid://574506349"
coroutine.wrap(function()
locbrick = Instance.new("Part",Torso)
locbrick.Size = Vector3.new(1,1,1)
locbrick.Transparency = 1
locbrick.CFrame = CFrame.new(mouse.Hit.p)
locbrick.CanCollide = false
locbrick.Anchored = true
locbrick2 = Instance.new("Part",workspace)
locbrick2.Size = Vector3.new(1,1,1)
locbrick2.Transparency = 1
locbrick2.CFrame = CFrame.new(mouse.Hit.p)
locbrick2.CanCollide = false
locbrick2weld = weldBetween(locbrick2,locbrick)
zxp2 = 0
for i = 1, 65 do
zxp2 = zxp2 + 5
crater = Instance.new("Part",Torso)
crater.BrickColor = BrickColor.new("White")
crater.Size = Vector3.new(5,5,5)
crater.Transparency = 1
crater.Name = "crator"
craterweld = weldBetween(crater,locbrick2)
craterweld.C0 = craterweld.C0 * CFrame.new(2.5,0,0) * CFrame.Angles(math.rad(0),math.rad(zxp2),math.rad(0))
crater2 = Instance.new("Part",Torso)
crater2.CFrame = crater.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
crater2.Size = Vector3.new(4,4,4)
crater2.Anchored = true
crater2.Material = "Grass"
crater2.Name = "crator"
crater2.BrickColor = BrickColor.new("Bright green")
end
end)()
shockwave = Instance.new("Part", Torso)
shockwave.Size = Vector3.new(1,1,1)
shockwave.CanCollide = false
shockwave.Anchored = true
shockwave.Transparency = .5
shockwave.BrickColor = BrickColor.new("White")
shockwave.CFrame = CFrame.new(mouse.Hit.p)
shockwavemesh = Instance.new("SpecialMesh", shockwave)
shockwavemesh.Scale = Vector3.new(7,3,7)
shockwavemesh.MeshId = "rbxassetid://20329976"
removeuseless:AddItem(shockwave,4)
shockwave2 = Instance.new("Part", Torso)
shockwave2.Size = Vector3.new(1,1,1)
shockwave2.CanCollide = false
shockwave2.Anchored = true
shockwave2.Transparency = .5
shockwave2.BrickColor = BrickColor.new("White")
shockwave2.CFrame = CFrame.new(mouse.Hit.p)
shockwavemesh2 = Instance.new("SpecialMesh", shockwave2)
shockwavemesh2.Scale = Vector3.new(5,3,5)
shockwavemesh2.MeshId = "rbxassetid://20329976"
removeuseless:AddItem(shockwave2,4)
coroutine.wrap(function()
for i = 1, 30 do
swait()
shockwave.CFrame = shockwave.CFrame * CFrame.Angles(math.rad(0),math.rad(0+15),0)
shockwave2.CFrame = shockwave2.CFrame * CFrame.Angles(math.rad(0),math.rad(0-8),0)
shockwave.Transparency = shockwave.Transparency + 0.025
shockwave2.Transparency = shockwave2.Transparency + 0.025
shockwavemesh2.Scale = shockwavemesh2.Scale + Vector3.new(3,.5,3)
shockwavemesh.Scale = shockwavemesh.Scale + Vector3.new(4,.6,4)
end
end)()
SOUND(locbrick,1119859528,8,false,5)
coroutine.wrap(function()
for i = 1, 10 do
rockttm.CFrame = rockttm.CFrame * CFrame.new(0,2,0)
swait()
end
for i = 1, 8 do
rockttm.CFrame = rockttm.CFrame * CFrame.new(0,.25,0)
swait()
end
for i = 1, 5 do
rockttm.CFrame = rockttm.CFrame * CFrame.new(0,-.25,0)
swait()
end
end)()
for i = 1, 35 do
powvol = powvol + .075
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(30),0,0),.4)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.3,1,.35) * CFrame.Angles(math.rad(-110),math.rad(-12),math.rad(1)),.4)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.3,1,.35) * CFrame.Angles(math.rad(-110),math.rad(12),math.rad(-1)),.4)
swait()
end
removeuseless:AddItem(g1,.001)
debounce = false
attacking = false
ws = 90

end
elseif Press=='v' then
if debounce then return end
if bluetotem then return end
if browntotem then return end
if whitetotem then return end
if redtotem then
debounce = true
particlemiter1.Enabled = false
particlemiter2.Enabled = false
particlemiter4.Enabled = false
particlemiter5.Enabled = false
particlemiter6.Enabled = false
particlemiter7.Enabled = false
SOUND(locbrick,1119859528,8,false,5)
coroutine.wrap(function()
for i = 1, 35 do
swait()
powvol = powvol - .075
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "crator" then
v.Transparency = v.Transparency + .05
end
end
end
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "crator" then
v:Remove()
end
end
end)()
for i = 1, 5 do
rockttm.CFrame = rockttm.CFrame * CFrame.new(0,.25,0)
swait()
end
for i = 1, 15 do
rockttm.CFrame = rockttm.CFrame * CFrame.new(0,-2,0)
swait()
end
redtotem = false
rockttm:Remove()
debounce = false
else
ws = 16
redtotem = true
debounce = true
attacking = true
got = gottalktable[math.random(1,#gottalktable)]
smh = Instance.new("Sound", Head)
if avatarstate then
smh.Volume = 10
else
smh.Volume = 8
end
smh.SoundId = "http://www.roblox.com/asset/?id="..got
smh.Looped = false
if avatarstate then
smh.Pitch = .85
else
smh.Pitch = 1
end
smh:Play()
removeuseless:AddItem(smh,10)
g1 = Instance.new("BodyGyro", Root)
g1.D = 175
g1.P = 20000
g1.MaxTorque = Vector3.new(0,9000,0)
for i = 1, 15 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.2)
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(-30),0,0),.4)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.3,0,.2) * CFrame.Angles(math.rad(30),math.rad(30),0),.4)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.3,0,.2) * CFrame.Angles(math.rad(30),math.rad(-30),0),.4)
swait()
end
particlecolor = ColorSequence.new(BrickColor.new("Bright yellow").Color)
particlemiter1.Enabled = true
particlemiter2.Enabled = true
particlemiter4.Enabled = true
particlemiter5.Enabled = true
particlemiter6.Enabled = true
particlemiter7.Enabled = true
rockttm = Instance.new("Part", Torso)
rockttm.Size = Vector3.new(0.5, 0.5, 0.5)
rockttm.Material = "Neon"
rockttm.BrickColor = BrickColor.new("Bright yellow")
rockttm.Transparency = .5
rockttm.Anchored = true
rockttm.CanCollide = false
rockttm.CFrame = CFrame.new(mouse.Hit.p) * CFrame.new(0,-15,0) * CFrame.Angles(math.rad(math.random(-4,4)),math.rad(math.random(-4,4)),math.rad(math.random(-4,4)))
ttmmeshrock = Instance.new("SpecialMesh", rockttm)
ttmmeshrock.Scale = Vector3.new(.1,.1,.1)
ttmmeshrock.MeshId = "rbxassetid://574506349"
coroutine.wrap(function()
locbrick = Instance.new("Part",Torso)
locbrick.Size = Vector3.new(1,1,1)
locbrick.Transparency = 1
locbrick.CFrame = CFrame.new(mouse.Hit.p)
locbrick.CanCollide = false
locbrick.Anchored = true
locbrick2 = Instance.new("Part",workspace)
locbrick2.Size = Vector3.new(1,1,1)
locbrick2.Transparency = 1
locbrick2.CFrame = CFrame.new(mouse.Hit.p)
locbrick2.CanCollide = false
locbrick2weld = weldBetween(locbrick2,locbrick)
zxp2 = 0
for i = 1, 65 do
zxp2 = zxp2 + 5
crater = Instance.new("Part",Torso)
crater.BrickColor = BrickColor.new("Bright yellow")
crater.Size = Vector3.new(5,5,5)
crater.Transparency = 1
crater.Name = "crator"
craterweld = weldBetween(crater,locbrick2)
craterweld.C0 = craterweld.C0 * CFrame.new(2.5,0,0) * CFrame.Angles(math.rad(0),math.rad(zxp2),math.rad(0))
crater2 = Instance.new("Part",Torso)
crater2.CFrame = crater.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
crater2.Size = Vector3.new(4,4,4)
crater2.Anchored = true
crater2.Material = "Grass"
crater2.Name = "crator"
crater2.BrickColor = BrickColor.new("Bright green")
end
end)()
shockwave = Instance.new("Part", Torso)
shockwave.Size = Vector3.new(1,1,1)
shockwave.CanCollide = false
shockwave.Anchored = true
shockwave.Transparency = .5
shockwave.BrickColor = BrickColor.new("White")
shockwave.CFrame = CFrame.new(mouse.Hit.p)
shockwavemesh = Instance.new("SpecialMesh", shockwave)
shockwavemesh.Scale = Vector3.new(7,3,7)
shockwavemesh.MeshId = "rbxassetid://20329976"
removeuseless:AddItem(shockwave,4)
shockwave2 = Instance.new("Part", Torso)
shockwave2.Size = Vector3.new(1,1,1)
shockwave2.CanCollide = false
shockwave2.Anchored = true
shockwave2.Transparency = .5
shockwave2.BrickColor = BrickColor.new("White")
shockwave2.CFrame = CFrame.new(mouse.Hit.p)
shockwavemesh2 = Instance.new("SpecialMesh", shockwave2)
shockwavemesh2.Scale = Vector3.new(5,3,5)
shockwavemesh2.MeshId = "rbxassetid://20329976"
removeuseless:AddItem(shockwave2,4)
coroutine.wrap(function()
for i = 1, 30 do
swait()
shockwave.CFrame = shockwave.CFrame * CFrame.Angles(math.rad(0),math.rad(0+15),0)
shockwave2.CFrame = shockwave2.CFrame * CFrame.Angles(math.rad(0),math.rad(0-8),0)
shockwave.Transparency = shockwave.Transparency + 0.025
shockwave2.Transparency = shockwave2.Transparency + 0.025
shockwavemesh2.Scale = shockwavemesh2.Scale + Vector3.new(3,.5,3)
shockwavemesh.Scale = shockwavemesh.Scale + Vector3.new(4,.6,4)
end
end)()
SOUND(locbrick,1119859528,8,false,5)
coroutine.wrap(function()
for i = 1, 10 do
rockttm.CFrame = rockttm.CFrame * CFrame.new(0,2,0)
swait()
end
for i = 1, 8 do
rockttm.CFrame = rockttm.CFrame * CFrame.new(0,.25,0)
swait()
end
for i = 1, 5 do
rockttm.CFrame = rockttm.CFrame * CFrame.new(0,-.25,0)
swait()
end
end)()
for i = 1, 35 do
powvol = powvol + .075
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(30),0,0),.4)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.3,1,.35) * CFrame.Angles(math.rad(-110),math.rad(-12),math.rad(1)),.4)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.3,1,.35) * CFrame.Angles(math.rad(-110),math.rad(12),math.rad(-1)),.4)
swait()
end
removeuseless:AddItem(g1,.001)
debounce = false
attacking = false
ws = 90
end
elseif Press=='c' then
if debounce then return end
if redtotem then return end
if browntotem then return end
if whitetotem then return end
if bluetotem then
debounce = true
particlemiter1.Enabled = false
particlemiter2.Enabled = false
particlemiter4.Enabled = false
particlemiter5.Enabled = false
particlemiter6.Enabled = false
particlemiter7.Enabled = false
SOUND(locbrick,1119859528,8,false,5)
coroutine.wrap(function()
for i = 1, 35 do
swait()
powvol = powvol - .075
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "crator" then
v.Transparency = v.Transparency + .05
end
end
end
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "crator" then
v:Remove()
end
end
end)()
for i = 1, 5 do
rockttm.CFrame = rockttm.CFrame * CFrame.new(0,.25,0)
swait()
end
for i = 1, 15 do
rockttm.CFrame = rockttm.CFrame * CFrame.new(0,-2,0)
swait()
end
bluetotem = false
rockttm:Remove()
debounce = false
else
ws = 16
bluetotem = true
debounce = true
attacking = true
got = gottalktable[math.random(1,#gottalktable)]
smh = Instance.new("Sound", Head)
if avatarstate then
smh.Volume = 10
else
smh.Volume = 8
end
smh.SoundId = "http://www.roblox.com/asset/?id="..got
smh.Looped = false
if avatarstate then
smh.Pitch = .85
else
smh.Pitch = 1
end
smh:Play()
removeuseless:AddItem(smh,5)
g1 = Instance.new("BodyGyro", Root)
g1.D = 175
g1.P = 20000
g1.MaxTorque = Vector3.new(0,9000,0)
for i = 1, 15 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.2)
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(-30),0,0),.4)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.3,0,.2) * CFrame.Angles(math.rad(30),math.rad(30),0),.4)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.3,0,.2) * CFrame.Angles(math.rad(30),math.rad(-30),0),.4)
swait()
end
particlecolor = ColorSequence.new(Color3.new(0, 5, 255))
particlemiter1.Enabled = true
particlemiter2.Enabled = true
particlemiter4.Enabled = true
particlemiter5.Enabled = true
particlemiter6.Enabled = true
particlemiter7.Enabled = true
rockttm = Instance.new("Part", Torso)
rockttm.Size = Vector3.new(0.5, 0.5, 0.5)
rockttm.Material = "Neon"
rockttm.BrickColor = BrickColor.new("Cyan")
rockttm.Transparency = .5
rockttm.Anchored = true
rockttm.CanCollide = false
rockttm.CFrame = CFrame.new(mouse.Hit.p) * CFrame.new(0,-15,0) * CFrame.Angles(math.rad(math.random(-4,4)),math.rad(math.random(-4,4)),math.rad(math.random(-4,4)))
ttmmeshrock = Instance.new("SpecialMesh", rockttm)
ttmmeshrock.Scale = Vector3.new(.1,.1,.1)
ttmmeshrock.MeshId = "rbxassetid://574506349"
coroutine.wrap(function()
locbrick = Instance.new("Part",Torso)
locbrick.Size = Vector3.new(1,1,1)
locbrick.Transparency = 1
locbrick.CFrame = CFrame.new(mouse.Hit.p)
locbrick.CanCollide = false
locbrick.Anchored = true
locbrick2 = Instance.new("Part",workspace)
locbrick2.Size = Vector3.new(1,1,1)
locbrick2.Transparency = 1
locbrick2.CFrame = CFrame.new(mouse.Hit.p)
locbrick2.CanCollide = false
locbrick2weld = weldBetween(locbrick2,locbrick)
zxp2 = 0
for i = 1, 65 do
zxp2 = zxp2 + 5
crater = Instance.new("Part",Torso)
crater.BrickColor = BrickColor.new("Cyan")
crater.Size = Vector3.new(5,5,5)
crater.Transparency = 1
crater.Name = "crator"
craterweld = weldBetween(crater,locbrick2)
craterweld.C0 = craterweld.C0 * CFrame.new(2.5,0,0) * CFrame.Angles(math.rad(0),math.rad(zxp2),math.rad(0))
crater2 = Instance.new("Part",Torso)
crater2.CFrame = crater.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
crater2.Size = Vector3.new(4,4,4)
crater2.Anchored = true
crater2.Material = "Grass"
crater2.Name = "crator"
crater2.BrickColor = BrickColor.new("Bright green")
end
end)()
shockwave = Instance.new("Part", Torso)
shockwave.Size = Vector3.new(1,1,1)
shockwave.CanCollide = false
shockwave.Anchored = true
shockwave.Transparency = .5
shockwave.BrickColor = BrickColor.new("White")
shockwave.CFrame = CFrame.new(mouse.Hit.p)
shockwavemesh = Instance.new("SpecialMesh", shockwave)
shockwavemesh.Scale = Vector3.new(7,3,7)
shockwavemesh.MeshId = "rbxassetid://20329976"
removeuseless:AddItem(shockwave,4)
shockwave2 = Instance.new("Part", Torso)
shockwave2.Size = Vector3.new(1,1,1)
shockwave2.CanCollide = false
shockwave2.Anchored = true
shockwave2.Transparency = .5
shockwave2.BrickColor = BrickColor.new("White")
shockwave2.CFrame = CFrame.new(mouse.Hit.p)
shockwavemesh2 = Instance.new("SpecialMesh", shockwave2)
shockwavemesh2.Scale = Vector3.new(5,3,5)
shockwavemesh2.MeshId = "rbxassetid://20329976"
removeuseless:AddItem(shockwave2,4)
coroutine.wrap(function()
for i = 1, 30 do
swait()
shockwave.CFrame = shockwave.CFrame * CFrame.Angles(math.rad(0),math.rad(0+15),0)
shockwave2.CFrame = shockwave2.CFrame * CFrame.Angles(math.rad(0),math.rad(0-8),0)
shockwave.Transparency = shockwave.Transparency + 0.025
shockwave2.Transparency = shockwave2.Transparency + 0.025
shockwavemesh2.Scale = shockwavemesh2.Scale + Vector3.new(3,.5,3)
shockwavemesh.Scale = shockwavemesh.Scale + Vector3.new(4,.6,4)
end
end)()
SOUND(locbrick,1119859528,8,false,5)
coroutine.wrap(function()
for i = 1, 10 do
rockttm.CFrame = rockttm.CFrame * CFrame.new(0,2,0)
swait()
end
for i = 1, 8 do
rockttm.CFrame = rockttm.CFrame * CFrame.new(0,.25,0)
swait()
end
for i = 1, 5 do
rockttm.CFrame = rockttm.CFrame * CFrame.new(0,-.25,0)
swait()
end
end)()
for i = 1, 35 do
powvol = powvol + .075
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(30),0,0),.4)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.3,1,.35) * CFrame.Angles(math.rad(-110),math.rad(-12),math.rad(1)),.4)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.3,1,.35) * CFrame.Angles(math.rad(-110),math.rad(12),math.rad(-1)),.4)
swait()
end
removeuseless:AddItem(g1,.001)
debounce = false
attacking = false
ws = 90
end
elseif Press=='l' then
if debounce then return end
if tornadobounce then return end
tornadobounce = true
debounce = true
attacking = true
coroutine.wrap(function()
local tornadopart = Instance.new("Part",Torso)
tornadopart.Size = Vector3.new(10,10,10)
tornadopart.CanCollide = false
tornadopart.Transparency = 1
tornadopart.CFrame = CFrame.new(mouse.Hit.p)
tornadopart.Anchored = true
tornadopart.BrickColor = BrickColor.new("White")
tornadopart.Material = "Neon"
tornadopart.Name = "tornblock"
tornsound = Instance.new("Sound",tornadopart)
tornsound.Volume = 0
tornsound.SoundId = "rbxassetid://151051389"
tornsound:Play()
tornsound.Looped = true
wrn = Instance.new("Sound",workspace)
wrn.Volume = 1
wrn.SoundId = "rbxassetid://130767714"
wrn:Play()
local tornadopart2 = Instance.new("Part",Torso)
tornadopart2.Size = Vector3.new(20,20,20)
tornadopart2.CanCollide = false
tornadopart2.Transparency = 1
tornadopart2.CFrame = CFrame.new(mouse.Hit.p) * CFrame.new(0,12,0)
tornadopart2.Anchored = true
tornadopart2.BrickColor = BrickColor.new("White")
tornadopart2.Material = "Neon"
tornadopart2.Name = "tornblock2"
local tornadopart3 = Instance.new("Part",Torso)
tornadopart3.Size = Vector3.new(30,30,30)
tornadopart3.CanCollide = false
tornadopart3.Transparency = 1
tornadopart3.CFrame = CFrame.new(mouse.Hit.p) * CFrame.new(0,24,0)
tornadopart3.Anchored = true
tornadopart3.BrickColor = BrickColor.new("White")
tornadopart3.Material = "Neon"
tornadopart3.Name = "tornblock3"
local tornadopart4 = Instance.new("Part",Torso)
tornadopart4.Size = Vector3.new(40,40,40)
tornadopart4.CanCollide = false
tornadopart4.Transparency = 1
tornadopart4.CFrame = CFrame.new(mouse.Hit.p) * CFrame.new(0,36,0)
tornadopart4.Anchored = true
tornadopart4.BrickColor = BrickColor.new("White")
tornadopart4.Material = "Neon"
tornadopart4.Name = "tornblock4"
local tornadopart5 = Instance.new("Part",Torso)
tornadopart5.Size = Vector3.new(50,50,50)
tornadopart5.CanCollide = false
tornadopart5.Transparency = 1
tornadopart5.CFrame = CFrame.new(mouse.Hit.p) * CFrame.new(0,48,0)
tornadopart5.Anchored = true
tornadopart5.BrickColor = BrickColor.new("White")
tornadopart5.Material = "Neon"
tornadopart5.Name = "tornblock5"
local tornadopart6 = Instance.new("Part",Torso)
tornadopart6.Size = Vector3.new(70,70,70)
tornadopart6.CanCollide = false
tornadopart6.Transparency = 1
tornadopart6.CFrame = CFrame.new(mouse.Hit.p) * CFrame.new(0,80,0)
tornadopart6.Anchored = true
tornadopart6.BrickColor = BrickColor.new("White")
tornadopart6.Material = "Neon"
tornadopart6.Name = "tornblock6"
local tornadopart7 = Instance.new("Part",Torso)
tornadopart7.Size = Vector3.new(90,90,90)
tornadopart7.CanCollide = false
tornadopart7.Transparency = 1
tornadopart7.CFrame = CFrame.new(mouse.Hit.p) * CFrame.new(0,150,0)
tornadopart7.Anchored = true
tornadopart7.BrickColor = BrickColor.new("White")
tornadopart7.Material = "Neon"
tornadopart7.Name = "tornblock7"
local tornadopart8 = Instance.new("Part",Torso)
tornadopart8.Size = Vector3.new(110,110,110)
tornadopart8.CanCollide = false
tornadopart8.Transparency = 1
tornadopart8.CFrame = CFrame.new(mouse.Hit.p) * CFrame.new(0,220,0)
tornadopart8.Anchored = true
tornadopart8.BrickColor = BrickColor.new("White")
tornadopart8.Material = "Neon"
tornadopart8.Name = "tornblock8"
wind = Instance.new("Part", Torso)
wind.Size = Vector3.new(0.5, 0.5, 0.5)
wind.Material = "Neon"
wind.BrickColor = BrickColor.new("Really white")
wind.Transparency = 1
wind.Anchored = true
wind.CanCollide = false
wind.CFrame = tornadopart.CFrame * CFrame.new(0,120,0)
windMESH = Instance.new("SpecialMesh", wind)
windMESH.Scale = Vector3.new(40.5,70.5,40.5)
windMESH.MeshId = "rbxassetid://168892432"
wind2 = Instance.new("Part", Torso)
wind2.Size = Vector3.new(0.5, 0.5, 0.5)
wind2.Material = "Neon"
wind2.BrickColor = BrickColor.new("Really white")
wind2.Transparency = 1
wind2.Anchored = true
wind2.CanCollide = false
wind2.CFrame = tornadopart.CFrame * CFrame.new(0,120,0)
windMESH2 = Instance.new("SpecialMesh", wind2)
windMESH2.Scale = Vector3.new(40.5,70.5,40.5)
windMESH2.MeshId = "rbxassetid://168892432"
wind3 = Instance.new("Part", Torso)
wind3.Size = Vector3.new(0.5, 0.5, 0.5)
wind3.Material = "Neon"
wind3.BrickColor = BrickColor.new("Really white")
wind3.Transparency = 1
wind3.Anchored = true
wind3.CanCollide = false
wind3.CFrame = tornadopart.CFrame * CFrame.new(0,160,0)
windMESH3 = Instance.new("SpecialMesh", wind3)
windMESH3.Scale = Vector3.new(70.5,100.5,70.5)
windMESH3.MeshId = "rbxassetid://168892432"
wind4 = Instance.new("Part", Torso)
wind4.Size = Vector3.new(0.5, 0.5, 0.5)
wind4.Material = "Neon"
wind4.BrickColor = BrickColor.new("Really white")
wind4.Transparency = 1
wind4.Anchored = true
wind4.CanCollide = false
wind4.CFrame = tornadopart.CFrame * CFrame.new(0,120,0)
windMESH4 = Instance.new("SpecialMesh", wind4)
windMESH4.Scale = Vector3.new(70.5,100.5,70.5)
windMESH4.MeshId = "rbxassetid://168892432"
coroutine.wrap(function()
for i = 1, 20 do
tornsound.Volume = tornsound.Volume + .5
wind.Transparency = wind.Transparency - .002
wind2.Transparency = wind2.Transparency - .002
wind3.Transparency = wind3.Transparency - .001
wind4.Transparency = wind4.Transparency - .001
tornadopart.Transparency = tornadopart.Transparency -.025
tornadopart2.Transparency = tornadopart2.Transparency -.025
tornadopart3.Transparency = tornadopart3.Transparency -.025
tornadopart4.Transparency = tornadopart4.Transparency -.025
tornadopart5.Transparency = tornadopart5.Transparency -.025
tornadopart6.Transparency = tornadopart6.Transparency -.025
tornadopart7.Transparency = tornadopart7.Transparency -.025
tornadopart8.Transparency = tornadopart8.Transparency -.025
swait()
end
end)()
coroutine.wrap(function()
coroutine.wrap(function()
for i = 1, 110 do
swait(10)
Hit = damagealll(52,tornadopart.Position)
for _,v in pairs(Hit) do
if whitetotem then

elseif avatarstate then

else
end
vel = Instance.new("BodyVelocity",v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")) 
vel.maxForce = Vector3.new(9999999999999,9999999999999,9999999999999)
torso = v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
vel.velocity = CFrame.new(torso.Position,tornadopart.Position).lookVector*175
removeuseless:AddItem(vel,.1)
end
end
end)()
to3 = 0
to4 = 0
for i = 1, 1200 do
to3 = to3 + 2
to4 = to4 - 2
local grasssblockss = Instance.new("Part",Torso)
grasssblockss.Size = Vector3.new(math.random(8,11),math.random(8,11),math.random(8,11))
grasssblockss.Material = "Grass"
grasssblockss.CanCollide = false
grasssblockss.Anchored = true
grasssblockss.BrickColor = BrickColor.new("Bright green")
grasssblockss.CFrame = tornadopart.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
grasssblockss.Name = "grasssblockss"
removeuseless:AddItem(grasssblockss,2)
local sk = Instance.new("Part",Torso)
sk.CanCollide = false
sk.Anchored = true
sk.BrickColor = BrickColor.new("White")
sk.Name = "sk"
sk.CFrame = tornadopart.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),0,math.rad(math.random(-180,180)))
local skmesh = Instance.new("SpecialMesh",sk)
skmesh.MeshId = "rbxassetid://662586858"
skmesh.Name = "wave"
skmesh.Scale = Vector3.new(.04,.01,.04)
removeuseless:AddItem(sk,2)
for i,v in pairs(Torso:GetDescendants()) do if v.Name == "wave" then
v.Scale = v.Scale + Vector3.new(0.05,0,.05)
v.Parent.Transparency = v.Parent.Transparency + .05
end
end
for i,v in pairs(Torso:GetDescendants()) do if v.Name == "grasssblockss" then
v.CFrame = v.CFrame * CFrame.new(0,4,0)
v.Transparency = v.Transparency + .035
end
end
wind.CFrame = wind.CFrame * CFrame.Angles(0,math.rad(0+17),0)
wind2.CFrame = wind2.CFrame * CFrame.Angles(0,math.rad(0-17),0)
wind3.CFrame = wind3.CFrame * CFrame.Angles(0,math.rad(0+12),0)
wind4.CFrame = wind4.CFrame * CFrame.Angles(0,math.rad(0-12),0)
tornadopart.CFrame = tornadopart.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
tornadopart2.CFrame = tornadopart2.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
tornadopart3.CFrame = tornadopart3.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
tornadopart4.CFrame = tornadopart4.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
tornadopart5.CFrame = tornadopart5.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
tornadopart6.CFrame = tornadopart6.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
tornadopart7.CFrame = tornadopart7.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
tornadopart8.CFrame = tornadopart8.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
swait()
end
for i = 1, 20 do
tornsound.Volume = tornsound.Volume - .5
for i,v in pairs(Torso:GetDescendants()) do if v.Name == "grasssblockss" then
v.CFrame = v.CFrame * CFrame.new(0,4,0)
v.Transparency = v.Transparency + .1
end
end
for i,v in pairs(Torso:GetDescendants()) do if v.Name == "wave" then
v.Scale = v.Scale + Vector3.new(0.05,0,.05)
v.Parent.Transparency = v.Parent.Transparency + .1
end
end
wind.Transparency = wind.Transparency + .002
wind2.Transparency = wind2.Transparency + .002
wind3.Transparency = wind3.Transparency + .001
wind4.Transparency = wind4.Transparency + .001
tornadopart.Transparency = tornadopart.Transparency + .025
tornadopart2.Transparency = tornadopart2.Transparency + .025
tornadopart3.Transparency = tornadopart3.Transparency + .025
tornadopart4.Transparency = tornadopart4.Transparency + .025
tornadopart5.Transparency = tornadopart5.Transparency + .025
tornadopart6.Transparency = tornadopart6.Transparency + .025
tornadopart7.Transparency = tornadopart7.Transparency + .025
tornadopart8.Transparency = tornadopart8.Transparency + .025
swait()
end
wind:Remove()
wind2:Remove()
wind3:Remove()
wind4:Remove()
tornsound:Remove()----ignore this ugly mess pl0x
tornadopart:Remove()
tornadopart2:Remove()
tornadopart3:Remove()
tornadopart4:Remove()
tornadopart5:Remove()
tornadopart6:Remove()
tornadopart7:Remove()
tornadopart8:Remove()
tornadobounce = false
end)()
end)()
for i = 1, 20 do
sk = Instance.new("Part",Torso)
sk.CanCollide = false
sk.Anchored = true
sk.BrickColor = BrickColor.new("White")
sk.Name = "sk"
sk.CFrame = Root.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),0,math.rad(math.random(-180,180)))
local skmesh = Instance.new("SpecialMesh",sk)
skmesh.MeshId = "rbxassetid://662586858"
skmesh.Name = "wave2"
skmesh.Scale = Vector3.new(.02,.01,.02)
removeuseless:AddItem(sk,2)
end
for i = 1, 3 do
blastwave = Instance.new("Part",Torso)
blastwave.Size = Vector3.new(1,1,1)
blastwave.CanCollide = false
blastwave.Material = "Neon"
blastwave.Anchored = true
blastwave.Transparency = .6
blastwave.CFrame = Root.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),0,math.rad(math.random(-180,180)))
blastwave.BrickColor = BrickColor.new("White")
blastwave.Name = "zin"
removeuseless:AddItem(blastwave,2)
end
SOUND(Torso,2458107258,8,false,5)
g1 = Instance.new("BodyGyro", Root)
g1.D = 175
g1.P = 20000
g1.MaxTorque = Vector3.new(0,9000,0)
for i = 1, 22 do
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(39 - 12 * math.sin(sine/12)),0,0),.4)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:Lerp(CFrame.new(-1.65,.75,0) * CFrame.Angles(math.rad(10),math.rad(5),math.rad(-35)),.4)
LEFTARMLERP.C0 = LEFTARMLERP.C0:Lerp(CFrame.new(1.65,.75,0)* CFrame.Angles(math.rad(10),math.rad(-5),math.rad(35)),.4)
for i,v in pairs(Torso:GetDescendants()) do if v.Name == "wave2" then
v.Scale = v.Scale + Vector3.new(0.03,0,.03)
v.Parent.Transparency = v.Parent.Transparency + .05
end
end
for i,v in pairs(Torso:GetDescendants()) do if v.Name == "zin" then
v.Size = v.Size + Vector3.new(4,4,4)
v.Transparency = v.Transparency + .05
end
end
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.2)
swait()
end
removeuseless:AddItem(g1,.001)
attacking = false 
debounce = false
elseif Press=='k' then
if debounce then return end
debounce = true
attacking = true
waterz = true
ws = 0
g1 = Instance.new("BodyGyro", Root)
g1.D = 175
g1.P = 20000
g1.MaxTorque = Vector3.new(0,9000,0)
if avatarstate then
for i = 1, 7 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.4)
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(-30),0,0),.8)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.3,0,.2) * CFrame.Angles(math.rad(30),math.rad(30),0),.8)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.3,0,.2) * CFrame.Angles(math.rad(30),math.rad(-30),0),.8)
swait()
end
else
for i = 1, 15 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.2)
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(-30),0,0),.4)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.3,0,.2) * CFrame.Angles(math.rad(30),math.rad(30),0),.4)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.3,0,.2) * CFrame.Angles(math.rad(30),math.rad(-30),0),.4)
swait()
end
end
SOUND(Torso,169486406,8,false,5)
coroutine.wrap(function()
if avatarstate then
for i = 1, 7 do
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(30),0,0),.8)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.3,1,.35) * CFrame.Angles(math.rad(-110),math.rad(-12),math.rad(1)),.8)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.3,1,.35) * CFrame.Angles(math.rad(-110),math.rad(12),math.rad(-1)),.8)
swait()
end
else
for i = 1, 15 do
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(30),0,0),.4)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.3,1,.35) * CFrame.Angles(math.rad(-110),math.rad(-12),math.rad(1)),.4)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.3,1,.35) * CFrame.Angles(math.rad(-110),math.rad(12),math.rad(-1)),.4)
swait()
end
end
end)()
for i = 1, 6 do
waterblock = Instance.new("Part",Torso)
waterblock.Size = Vector3.new(4,4,4)
waterblock.Transparency = .6
waterblock.Anchored = true
waterblock.CanCollide = false
waterblock.BrickColor = BrickColor.new("Cyan")
waterblock.Material = "Neon"
waterblock.Name = "water"
waterblock.CFrame = Root.CFrame * CFrame.new(math.random(-15,15),-15,math.random(-15,15))
end
coroutine.wrap(function()
while waterz do
swait()
colors2 = colortable2[math.random(1,#colortable2)]
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "water" then
waterwv = Instance.new("Part",v)
waterwv.Size = Vector3.new(5,5,5)
waterwv.CFrame = v.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
waterwv.Anchored = false
waterwv.CanCollide = false
waterwv.Name = "waterv"
waterwv.Material = "Neon"
waterwv.BrickColor = BrickColor.new(colors2)
removeuseless:AddItem(waterwv,2)
end
end
for i,v in pairs(Torso:GetDescendants()) do
if v.Name == "waterv" then
v.Size = v.Size - Vector3.new(.35,.35,.35)
v.Transparency = v.Transparency + .02
end
end
swait()
end
end)()
if avatarstate then
for i = 1, 13 do
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "water" then
v.CFrame = v.CFrame * CFrame.new(0,0 + 2,0)
end
end
swait()
end
else
for i = 1, 25 do
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "water" then
v.CFrame = v.CFrame * CFrame.new(0,0 + 1,0)
end
end
swait()
end
end
wait(.5)
ws = 12
coroutine.wrap(function()
if avatarstate then
for i = 1, 38 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.4)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(10*math.sin(sine/12)),math.rad(-40),math.rad(0)),.4)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(-50 - 3 * math.sin(sine/12)),math.rad(-3 + 1 * math.sin(sine/12))), .4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 2 + .02 * math.sin(sine/12), 0.2 + .1 * math.sin(sine/12)) * CFrame.Angles(math.rad(25 + 5 * math.sin(sine/12)), math.rad(-20), math.rad(0)), 0.4)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.54, 2 + .02 * math.sin(sine/12), 0.2 + .1 * math.sin(sine/12)) * CFrame.Angles(math.rad(25 + 5 * math.sin(sine/12)), math.rad(20), math.rad(0)), 0.4)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(.5,2,0) * CFrame.Angles(math.rad(0),math.rad(-25),math.rad(-140)),.4)
swait()
end
else
for i = 1, 75 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.2)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(10*math.sin(sine/12)),math.rad(-40),math.rad(0)),.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(-50 - 3 * math.sin(sine/12)),math.rad(-3 + 1 * math.sin(sine/12))), .2)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 2 + .02 * math.sin(sine/12), 0.2 + .1 * math.sin(sine/12)) * CFrame.Angles(math.rad(25 + 5 * math.sin(sine/12)), math.rad(-20), math.rad(0)), 0.2)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.54, 2 + .02 * math.sin(sine/12), 0.2 + .1 * math.sin(sine/12)) * CFrame.Angles(math.rad(25 + 5 * math.sin(sine/12)), math.rad(20), math.rad(0)), 0.2)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(.5,2,0) * CFrame.Angles(math.rad(0),math.rad(-25),math.rad(-140)),.2)
swait()
end
end
end)()
if avatarstate then
for i = 1, 39 do
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "water" then
v.CFrame = v.CFrame:lerp(CFrame.new(rightlocation.Position) * CFrame.new(0,10,0),.1)
end
end
swait()
end
else
for i = 1, 75 do
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "water" then
v.CFrame = v.CFrame:lerp(CFrame.new(rightlocation.Position) * CFrame.new(0,10,0),.05)
end
end
swait()
end
end
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "water" then
v:Remove()
end
end
waterb = Instance.new("Part",Torso)
waterb.Size = Vector3.new(1,1,1)
waterb.Transparency = 1
waterb.CFrame = CFrame.new(rightlocation.Position) * CFrame.new(0,10,0)
waterb.Anchored = true
waterb.CanCollide = false
waterb.Name = "waterbx"
SOUND(rightlocation,413682983,9,false,10)
coroutine.wrap(function()
waterb2 = Instance.new("Part",Torso)
waterb2.Size = Vector3.new(10,10,10)
waterb2.Transparency = 0
waterb2.CFrame = CFrame.new(rightlocation.Position) * CFrame.new(0,10,0) * CFrame.Angles(math.rad(math.random(-180,180)),0,math.rad(math.random(-180,180)))
waterb2.Anchored = true
waterb2.CanCollide = false
waterb2.Name = "waterb"
waterb2.Material = "Neon"
for i = 1, 30 do
waterb2.Size = waterb2.Size + Vector3.new(3,3,3)
waterb2.Transparency = waterb2.Transparency + .05
swait()
end
waterb2:Remove()
end)()
coroutine.wrap(function()
for i = 1, 25 do
swait()
sk = Instance.new("Part",Torso)
sk.CanCollide = false
sk.Anchored = true
sk.BrickColor = BrickColor.new(colors2)
sk.Name = "sk"
sk.CFrame = waterb.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),0,math.rad(math.random(-180,180)))
skmesh = Instance.new("SpecialMesh",sk)
skmesh.MeshId = "rbxassetid://662586858"
skmesh.Name = "firewave"
skmesh.Scale = Vector3.new(.04,.01,.04)
removeuseless:AddItem(sk,2)
for i,v in pairs(Torso:GetDescendants()) do if v.Name == "firewave" then
v.Scale = v.Scale + Vector3.new(0.03,0,.03)
v.Parent.Transparency = v.Parent.Transparency + .05
end
end
end
for i = 1, 30 do
for i,v in pairs(Torso:GetDescendants()) do if v.Name == "firewave" then
v.Scale = v.Scale + Vector3.new(0.03,0,.03)
v.Parent.Transparency = v.Parent.Transparency + .05
end
end
swait()
end
end)()
coroutine.wrap(function()
while waterz do
colors2 = colortable2[math.random(1,#colortable2)]
blwater = Instance.new("Part",Torso)
blwater.Size = Vector3.new(10,10,10)
blwater.Transparency = .5
blwater.BrickColor = BrickColor.new(colors2)
blwater.Material = "Neon"
blwater.Anchored = false
blwater.CanCollide = false
blwater.CFrame = waterb.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
blwater.Name = "blyat"
removeuseless:AddItem(blwater,2)
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "blyat" then
v.Size = v.Size - Vector3.new(.25,.25,.25)
v.Transparency = v.Transparency + .025
end
end
swait()
end
end)()
for i = 1, 25 do
waterb.CFrame = CFrame.new(rightlocation.Position) * CFrame.new(0,10,0)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(.6, 1.9, 0.2) * CFrame.Angles(math.rad(-85), math.rad(120), math.rad(-20)), 0.5)
swait()
end
waterb:Remove()
waterz = false
local waterb = Instance.new("Part",Torso)
waterb.Size = Vector3.new(1,1,1)
waterb.Transparency = 1
waterb.CFrame = CFrame.new(rightlocation.Position) * CFrame.new(0,10,0)
waterb.Anchored = false
waterb.CanCollide = false
waterb.Name = "waterbx2"
bov = Instance.new("BodyVelocity",waterb)
bov.maxForce = Vector3.new(99999,99999,99999)
waterb.CFrame = CFrame.new(waterb.Position,mouse.Hit.p)
bov.velocity = waterb.CFrame.lookVector*220
local alreadyhit = false
waterb.Touched:connect(function(hit)
if hit.Name ~= "blyat" and hit.Name ~= "firewave" and hit.Name ~= "waterb" and hit.Name ~= "sk" and hit.Name ~= "beeg" then
if alreadyhit then return end
alreadyhit = true
waterb.Anchored = true
Hit = damagealll(38,waterb.Position)
for _,v in pairs(Hit) do
if bluetotem then

elseif avatarstate then

else

end
vel = Instance.new("BodyVelocity",v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")) 
vel.maxForce = Vector3.new(9999999999999,9999999999999,9999999999999)
torso = v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
vel.velocity = CFrame.new(waterb.Position,torso.Position).lookVector*175
removeuseless:AddItem(vel,.1)
end
local exploblue = Instance.new("Part",Torso)
exploblue.Name = "bluex"
exploblue.Size = Vector3.new(6,6,6)
exploblue.Anchored = true
exploblue.Transparency = .6
exploblue.CanCollide = false
exploblue.CFrame = waterb.CFrame
exploblue.Material = "Neon"
exploblue.Shape = "Ball"
exploblue.BrickColor = BrickColor.new(colors2)
SOUND(exploblue,2350560656,8,false,5)
local exploblue2 = Instance.new("Part",Torso)
exploblue2.Name = "bluex"
exploblue2.Size = Vector3.new(4,4,4)
exploblue2.Anchored = true
exploblue2.Transparency = .4
exploblue2.CanCollide = false
exploblue2.CFrame = waterb.CFrame
exploblue2.Material = "Neon"
exploblue2.Shape = "Ball"
exploblue2.BrickColor = BrickColor.new(colors2)
local exploblue3 = Instance.new("Part",Torso)
exploblue3.Name = "bluex"
exploblue3.Transparency = .2
exploblue3.Size = Vector3.new(2,2,2)
exploblue3.Anchored = true
exploblue3.CanCollide = false
exploblue3.CFrame = waterb.CFrame
exploblue3.Material = "Neon"
exploblue3.Shape = "Ball"
exploblue3.BrickColor = BrickColor.new(colors2)
waterb:Remove()
for i = 1, 25 do
sk = Instance.new("Part",Torso)
sk.CanCollide = false
sk.Anchored = true
sk.BrickColor = BrickColor.new(colors2)
sk.Name = "sk"
sk.CFrame = exploblue.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),0,math.rad(math.random(-180,180)))
skmesh = Instance.new("SpecialMesh",sk)
skmesh.MeshId = "rbxassetid://662586858"
skmesh.Name = "lolwtf"
skmesh.Scale = Vector3.new(.04,.01,.04)
end
for i = 1, 15 do
for i,v in pairs(Torso:GetDescendants()) do if v.Name == "lolwtf" then
v.Scale = v.Scale + Vector3.new(0.04,0,.04)
end
end
exploblue.Size = exploblue.Size + Vector3.new(4,4,4)
exploblue2.Size = exploblue2.Size + Vector3.new(4,4,4)
exploblue3.Size = exploblue3.Size + Vector3.new(4,4,4)
swait()
end
for i = 1, 15 do
for i,v in pairs(Torso:GetDescendants()) do if v.Name == "lolwtf" then
v.Scale = v.Scale + Vector3.new(0.02,0,.02)
end
end
exploblue.Size = exploblue.Size + Vector3.new(2,2,2)
exploblue2.Size = exploblue2.Size + Vector3.new(2,2,2)
exploblue3.Size = exploblue3.Size + Vector3.new(2,2,2)
swait()
end
for i = 1, 40 do
for i,v in pairs(Torso:GetDescendants()) do if v.Name == "lolwtf" then
v.Scale = v.Scale - Vector3.new(0.04,0,.04)
v.Parent.Transparency = v.Parent.Transparency + .05
end
end
exploblue.Transparency = exploblue.Transparency + .025
exploblue2.Transparency = exploblue2.Transparency + .025
exploblue3.Transparency = exploblue3.Transparency + .025
exploblue.Size = exploblue.Size - Vector3.new(3,3,3)
exploblue2.Size = exploblue2.Size - Vector3.new(3,3,3)
exploblue3.Size = exploblue3.Size - Vector3.new(3,3,3)
swait()
end
for i,v in pairs(Torso:GetDescendants()) do if v.Name == "lolwtf" then
v:Remove()
end
end
exploblue:Remove()
exploblue2:Remove()
exploblue3:Remove()
print(hit.Name)
end
end)
coroutine.wrap(function()
for i = 1, 350 do
if breakwaterm then break end
colors2 = colortable2[math.random(1,#colortable2)]
blwater = Instance.new("Part",Torso)
blwater.Size = Vector3.new(10,10,10)
blwater.Transparency = .5
blwater.BrickColor = BrickColor.new(colors2)
blwater.Material = "Neon"
blwater.Anchored = false
blwater.CanCollide = false
blwater.CFrame = waterb.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
blwater.Name = "blyat"
removeuseless:AddItem(blwater,2)
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "blyat" then
v.Size = v.Size - Vector3.new(.25,.25,.25)
v.Transparency = v.Transparency + .025
end
end
swait()
end
pcall(function()
waterb:Remove()
end)
end)()
for i = 1, 50 do
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,math.rad(40),0),.4)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(.2,.2,.2) * CFrame.Angles(0,0,0),.5)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1, 1.1, 0.4) * CFrame.Angles(math.rad(-75), math.rad(15), math.rad(4)), 0.5)
swait()
end
RIGHTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
debounce = false
attacking = false
removeuseless:AddItem(g1,.001)
ws = 90
elseif Press=='j' then
if debounce then return end
if nottouched then return end
nottouched = true
nottouched2 = true
debounce = true 
attacking = true
ws = 6
fireballsize = 0
fireballsize2 = 0
phjv = 0
phjl = 0
g1 = Instance.new("BodyGyro", Root)
g1.D = 175
g1.P = 20000
g1.MaxTorque = Vector3.new(0,9000,0)
bigfireball = Instance.new("Part",Torso)
bigfireball.Anchored = true
bigfireball.CanCollide = false
bigfireball.Size = Vector3.new(2,2,2)
bigfireball.BrickColor = BrickColor.new(colors)
bigfireball.Material = "Neon"
bigfireball.CFrame = rightlocation.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),0,math.rad(math.random(-180,180)))
bigfireball2 = bigfireball:Clone()
bigfireball2.Parent = Torso
bigfireball2.Name = "beeg"
bigfireball2.BrickColor = BrickColor.new(colors)
bigfireball2.CFrame = rightlocation.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),0,math.rad(math.random(-180,180)))
ohno = Instance.new("Sound",bigfireball)
ohno.SoundId = "rbxassetid://2469853862"
ohno.Volume = 9
ohno:Play()
firsound = Instance.new("Sound",bigfireball)
firsound.SoundId = "rbxassetid://2371433183"
firsound.Volume = 0
firsound.Looped = true
firsound:Play()
for i = 1, 350 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.2)
firsound.Volume = firsound.Volume + .05
phjv = phjv + .225
phjl = phjl + .225
fireballsize = fireballsize + .005
fireballsize2 = fireballsize2 + .0152
bigfireball2.CFrame = Root.CFrame * CFrame.new(6,phjv,0) * CFrame.Angles(math.rad(math.random(-180,180)),0,math.rad(math.random(-180,180)))
bigfireball.CFrame = Root.CFrame * CFrame.new(6,phjl,0) * CFrame.Angles(math.rad(math.random(-180,180)),0,math.rad(math.random(-180,180)))
bigfireball.Size = bigfireball.Size + Vector3.new(.25,.25,.25)
bigfireball2.Size = bigfireball2.Size + Vector3.new(.25,.25,.25)
wshockwave = Instance.new("Part", Torso)
wshockwave.Size = Vector3.new(1,1,1)
wshockwave.CanCollide = false
wshockwave.Anchored = true
wshockwave.Name = "wsw"
wshockwave.Transparency = .45
wshockwave.BrickColor = BrickColor.new(colors)
wshockwave.CFrame = CFrame.new(bigfireball.Position) * CFrame.Angles(math.rad(math.random(-180,180)),0,math.rad(math.random(-180,180)))
wshockwavemesh = Instance.new("SpecialMesh", wshockwave)
wshockwavemesh.Scale = Vector3.new(1,.05,1)
wshockwavemesh.Name = "wswm"
wshockwavemesh.MeshId = "rbxassetid://20329976"
removeuseless:AddItem(wshockwave,2)
for i,v in pairs(Torso:GetDescendants()) do
if v.Name == "wswm" then
v.Parent.Transparency = v.Parent.Transparency + 0.05
v.Scale = v.Scale + Vector3.new(fireballsize,0,fireballsize2)
end
end
sk = Instance.new("Part",Torso)
sk.CanCollide = false
sk.Anchored = true
sk.BrickColor = BrickColor.new(colors)
sk.Name = "sk"
sk.CFrame = bigfireball.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),0,math.rad(math.random(-180,180)))
skmesh = Instance.new("SpecialMesh",sk)
skmesh.MeshId = "rbxassetid://662586858"
skmesh.Name = "firewave"
skmesh.Scale = Vector3.new(.04,.01,.04)
removeuseless:AddItem(sk,2)
for i,v in pairs(Torso:GetDescendants()) do if v.Name == "firewave" then
v.Scale = v.Scale + Vector3.new(fireballsize/10,0,fireballsize/10)
v.Parent.Transparency = v.Parent.Transparency + .05
end
end
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.2)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(10*math.sin(sine/12)),math.rad(0),math.rad(0)),.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(-50 - 3 * math.sin(sine/12)),math.rad(-3 + 1 * math.sin(sine/12))), .2)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 2 + .02 * math.sin(sine/12), 0.2 + .1 * math.sin(sine/12)) * CFrame.Angles(math.rad(25 + 5 * math.sin(sine/12)), math.rad(-20), math.rad(0)), 0.2)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.54, 2 + .02 * math.sin(sine/12), 0.2 + .1 * math.sin(sine/12)) * CFrame.Angles(math.rad(25 + 5 * math.sin(sine/12)), math.rad(20), math.rad(0)), 0.2)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(.5,2,0) * CFrame.Angles(math.rad(0),math.rad(-25),math.rad(-140)),.3)
swait()
end
coroutine.wrap(function()
for i = 1, 45 do
for i,v in pairs(Torso:GetDescendants()) do if v.Name == "firewave" then
v.Scale = v.Scale + Vector3.new(.02,0,.02)
v.Parent.Transparency = v.Parent.Transparency + .05
end
end
for i,v in pairs(Torso:GetDescendants()) do
if v.Name == "wswm" then
v.Parent.Transparency = v.Parent.Transparency + 0.05
v.Scale = v.Scale + Vector3.new(4,0,4)
end
end
swait()
end
end)()
for i = 1, 75 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.2)
firsound.Volume = firsound.Volume - .05
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(10*math.sin(sine/12)),math.rad(0),math.rad(0)),.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(-50 - 3 * math.sin(sine/12)),math.rad(-3 + 1 * math.sin(sine/12))), .2)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 2 + .02 * math.sin(sine/12), 0.2 + .1 * math.sin(sine/12)) * CFrame.Angles(math.rad(25 + 5 * math.sin(sine/12)), math.rad(-20), math.rad(0)), 0.2)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.54, 2 + .02 * math.sin(sine/12), 0.2 + .1 * math.sin(sine/12)) * CFrame.Angles(math.rad(25 + 5 * math.sin(sine/12)), math.rad(20), math.rad(0)), 0.2)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(.5,2,0) * CFrame.Angles(math.rad(0),math.rad(-25),math.rad(-140)),.3)
bigfireball2.CFrame = Root.CFrame * CFrame.new(6,phjv,0) * CFrame.Angles(math.rad(math.random(-180,180)),0,math.rad(math.random(-180,180)))
bigfireball.CFrame = Root.CFrame * CFrame.new(6,phjl,0) * CFrame.Angles(math.rad(math.random(-180,180)),0,math.rad(math.random(-180,180)))
swait()
end
removeuseless:AddItem(g1,.001)
for i = 1, 35 do
firsound.Volume = firsound.Volume - .05
bigfireball2.CFrame = Root.CFrame * CFrame.new(6,phjv,0) * CFrame.Angles(math.rad(math.random(-180,180)),0,math.rad(math.random(-180,180)))
bigfireball.CFrame = Root.CFrame * CFrame.new(6,phjl,0) * CFrame.Angles(math.rad(math.random(-180,180)),0,math.rad(math.random(-180,180)))
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.55,0) * CFrame.Angles(math.rad(-20),math.rad(5),math.rad(20)),.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,math.rad(-40),0),.4)
swait()
end
firsound:Remove()
lozz = bigfireball.Size
bigfireball.Anchored = false
bigfireball.Transparency = 1
bigfireball.Size = Vector3.new(5,5,5)
coroutine.wrap(function()
bov = Instance.new("BodyVelocity",bigfireball)
bov.maxForce = Vector3.new(99999,99999,99999)
bigfireball.CFrame = CFrame.new(bigfireball.Position,mouse.Hit.p)
bov.velocity = bigfireball.CFrame.lookVector*75
coroutine.wrap(function()
for i = 1, 45 do
bigfireball2.Size = bigfireball2.Size + Vector3.new(4,4,4)
bigfireball2.Transparency = bigfireball2.Transparency + .05
swait()
end
end)()
function explo()
SOUND(bigfireball,240795638,36,false,10)
colors = colortable[math.random(1,#colortable)]
bigfireexplosion = bigfireball:Clone()
bigfireexplosion.Parent = Torso
bigfireexplosion.Size = smke.Size + Vector3.new(120,120,120) 
bigfireexplosion.BrickColor = BrickColor.new(colors)
bigfireexplosion.CFrame = bigfireball.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
colors = colortable[math.random(1,#colortable)]
bigfireexplosion2 = bigfireball:Clone()
bigfireexplosion2.Parent = Torso
bigfireexplosion2.Size = smke.Size + Vector3.new(120,120,120) 
bigfireexplosion2.BrickColor = BrickColor.new(colors)
bigfireexplosion2.CFrame = bigfireball.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
coroutine.wrap(function()
for i = 1, 25 do
for i,v in pairs(Torso:GetDescendants()) do if v.Name == "firewave" then
v.Scale = v.Scale + Vector3.new(.02,0,.02)
v.Parent.Transparency = v.Parent.Transparency + .08
end
end
bigfireexplosion.Size = bigfireexplosion.Size + Vector3.new(10,10,10)
bigfireexplosion.Transparency = bigfireexplosion.Transparency + .05
bigfireexplosion2.Size = bigfireexplosion2.Size + Vector3.new(10,10,10)
bigfireexplosion2.Transparency = bigfireexplosion2.Transparency + .05
swait()
end
bigfireexplosion:Remove()
bigfireexplosion2:Remove()
end)()
rlplosion = Instance.new("Part",Torso)
rlplosion.Size = Vector3.new(100,100,100)
rlplosion.BrickColor = BrickColor.new(colors)
rlplosion.Material = "Neon"
rlplosion.Anchored = true
rlplosion.Shape = "Ball"
rlplosion.CanCollide = false
rlplosion.CFrame = bigfireball.CFrame
deadlyring = Instance.new("Part", Torso)
deadlyring.Size = Vector3.new(5, 5, 5)
deadlyring.Transparency = 0.7
deadlyring.BrickColor = BrickColor.new("White")
deadlyring.Anchored = true
deadlyring.CanCollide = false
deadlyring.CFrame = rlplosion.CFrame * CFrame.Angles(math.rad(math.random(-180,180)), math.rad(math.random(-180,180)), math.rad(math.random(-180,180)))
deadlyringh = Instance.new("SpecialMesh", deadlyring) 
deadlyringh.MeshId = "http://www.roblox.com/asset/?id=3270017" 
deadlyringh.Scale = Vector3.new(8, 8, .1)
deadlyring2 = Instance.new("Part", Torso)
deadlyring2.Size = Vector3.new(5, 5, 5)
deadlyring2.Transparency = 0.7
deadlyring2.BrickColor = BrickColor.new("White")
deadlyring2.Anchored = true
deadlyring2.CanCollide = false
deadlyring2.CFrame = rlplosion.CFrame * CFrame.Angles(math.rad(math.random(-180,180)), math.rad(math.random(-180,180)), math.rad(math.random(-180,180)))
deadlyringh2 = Instance.new("SpecialMesh", deadlyring2) 
deadlyringh2.MeshId = "http://www.roblox.com/asset/?id=3270017" 
deadlyringh2.Scale = Vector3.new(8, 8, .1)
deadlywave = Instance.new("Part",Torso)
deadlywave.Size = Vector3.new(18,1,18)
deadlywave.CanCollide = false
deadlywave.Anchored = true
deadlywave.Transparency = .5
deadlywave.BrickColor = BrickColor.new("White")
deadlywave.CFrame = CFrame.new(rlplosion.Position)
deadlywavemesh = Instance.new("SpecialMesh", deadlywave)
deadlywavemesh.Scale = Vector3.new(15,60,15)
deadlywavemesh.MeshId = "rbxassetid://20329976"
deadlywave2 = Instance.new("Part",Torso)
deadlywave2.Size = Vector3.new(1,1,1)
deadlywave2.CanCollide = false
deadlywave2.Anchored = true
deadlywave2.Transparency = .5
deadlywave2.BrickColor = BrickColor.new("White")
deadlywave2.CFrame = CFrame.new(rlplosion.Position)
deadlywave2mesh = Instance.new("SpecialMesh", deadlywave2)
deadlywave2mesh.Scale = Vector3.new(60,5,60)
deadlywave2mesh.MeshId = "rbxassetid://20329976"
rlplosions = 5
for i = 1, 250 do
rlplosions = rlplosions + 1
Hit = damagealll(80+rlplosions,rlplosion.Position)
for _,v in pairs(Hit) do
if redtotem then

elseif avatarstate then

else

end
vel = Instance.new("BodyVelocity",v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")) 
vel.maxForce = Vector3.new(9999999999999,9999999999999,9999999999999)
torso = v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
vel.velocity = CFrame.new(rlplosion.Position,torso.Position).lookVector*125
removeuseless:AddItem(vel,.1)
end
deadlyringh2.Scale = deadlyringh2.Scale + Vector3.new(5, 5, 0)
deadlyringh.Scale = deadlyringh.Scale + Vector3.new(5, 5, 0)
deadlyring.CFrame = deadlyring.CFrame * CFrame.Angles(math.rad(0+7),math.rad(0-7),math.rad(0+7))
deadlyring2.CFrame = deadlyring2.CFrame * CFrame.Angles(math.rad(0-7),math.rad(0+7),math.rad(0-7))
deadlywave.CFrame = deadlywave.CFrame * CFrame.Angles(0,math.rad(0+21),0)
deadlywave2.CFrame = deadlywave2.CFrame * CFrame.Angles(0,math.rad(0+14),0)
deadlywavemesh.Scale = deadlywavemesh.Scale + Vector3.new(4,0,4)
deadlywave2mesh.Scale = deadlywave2mesh.Scale + Vector3.new(5,0,5)
rlplosion.Size = rlplosion.Size + Vector3.new(2.5,2.5,2.5)
swait()
end
for i = 1, 50 do
ohno.Volume = ohno.Volume - .2
deadlyringh2.Scale = deadlyringh2.Scale + Vector3.new(5, 5, 0)
deadlyringh.Scale = deadlyringh.Scale + Vector3.new(5, 5, 0)
deadlyring.CFrame = deadlyring.CFrame * CFrame.Angles(math.rad(0+7),math.rad(0-7),math.rad(0+7))
deadlyring2.CFrame = deadlyring2.CFrame * CFrame.Angles(math.rad(0-7),math.rad(0+7),math.rad(0-7))
deadlyring.Transparency = deadlyring.Transparency + .05
deadlyring2.Transparency = deadlyring2.Transparency + .05
deadlywave.CFrame = deadlywave.CFrame * CFrame.Angles(0,math.rad(0+7),0)
deadlywave2.CFrame = deadlywave2.CFrame * CFrame.Angles(0,math.rad(0+4),0)
deadlywavemesh.Scale = deadlywavemesh.Scale + Vector3.new(.4,0,.4)
deadlywave2mesh.Scale = deadlywave2mesh.Scale + Vector3.new(.5,0,.5)
deadlywave.Transparency = deadlywave.Transparency + .05
deadlywave2.Transparency = deadlywave2.Transparency + .05
rlplosion.Size = rlplosion.Size + Vector3.new(1,1,1)
rlplosion.Transparency = rlplosion.Transparency + 0.02
swait()
end
deadlyring:Remove()
deadlyring2:Remove()
deadlywave:Remove()
deadlywave2:Remove()
rlplosion:Remove()
bigfireball:Remove()
touchedistrue = false
nottouched = false
end
bigfireball.Touched:connect(function(hitza)
if hitza.Name ~= "smke" and hitza.Name ~= "sk" and hitza.Name ~= "beeg" and hitza.Name ~= "wsw" then
if touchedistrue then return end
touchedistrue = true
nottouched2 = false
bigfireball.Anchored = true
bov:Remove()
explo()
end
end)
coroutine.wrap(function()
while nottouched2 do
swait(10)
colors = colortable[math.random(1,#colortable)]
smke = Instance.new("Part",Torso)
smke.Size = lozz
smke.BrickColor = BrickColor.new(colors)
smke.Anchored = true
smke.CanCollide = false
smke.Material = "Neon"
smke.Name = "smke"
smke.CFrame = bigfireball.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
removeuseless:AddItem(smke,3)
end
end)()
while nottouched2 do
swait()
for i,v in pairs(Torso:GetDescendants()) do
if v.Name == "smke" then
v.Transparency = v.Transparency + .02
end
end
sk = Instance.new("Part",Torso)
sk.CanCollide = false
sk.Anchored = true
sk.BrickColor = BrickColor.new(colors)
sk.Name = "sk"
sk.CFrame = bigfireball.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),0,math.rad(math.random(-180,180)))
skmesh = Instance.new("SpecialMesh",sk)
skmesh.MeshId = "rbxassetid://662586858"
skmesh.Name = "firewave"
skmesh.Scale = Vector3.new(.04,.01,.04)
removeuseless:AddItem(sk,2)
for i,v in pairs(Torso:GetDescendants()) do if v.Name == "firewave" then
v.Scale = v.Scale + Vector3.new(fireballsize/10,0,fireballsize/10)
v.Parent.Transparency = v.Parent.Transparency + .05
end
end
swait()
end
end)()
for i = 1, 50 do
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,math.rad(40),0),.4)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(.2,.2,.2) * CFrame.Angles(0,0,0),.5)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1, 1.1, 0.4) * CFrame.Angles(math.rad(-75), math.rad(15), math.rad(4)), 0.5)
swait()
end
RIGHTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
coroutine.wrap(function()
for i = 1, 1000 do
if touchedistrue == true then break end
swait()
end
if not touchedistrue then
touchedistrue = true
nottouched2 = false
explo()
end
end)()
attacking = false
debounce = false
ws = 90
elseif Press=='h' then
if winddashing then
ws = 0
winddashing = false
tornad:Remove()
pzp4:Remove()
pzp3:Remove()
pzp2:Remove()
earthquak:Remove()
removeuseless:AddItem(g1,.001)
attacking = false
allowlev = true
SOUND(Torso,1619519574,8,false,5)
for i = 1, 35 do
for i,v in pairs(Torso:GetDescendants()) do if v.Name == "windwave" then
v.Scale = v.Scale + Vector3.new(.01,0,.01)
v.Parent.Transparency = v.Parent.Transparency + .05
end
end
windball.Size = windball.Size + Vector3.new(1,1,1)
windball.Transparency = windball.Transparency + .05
swait()
end
windball:Remove()
debounce = false
ws = 90
else
if debounce then return end
debounce = true
attacking = true
allowlev = false
ws = 0
for i = 1, 25 do
sk = Instance.new("Part",Torso)
sk.CanCollide = false
sk.Anchored = true
sk.BrickColor = BrickColor.new("White")
sk.Name = "sk"
sk.CFrame = Torso.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),0,math.rad(math.random(-180,180)))
skmesh = Instance.new("SpecialMesh",sk)
skmesh.MeshId = "rbxassetid://662586858"
skmesh.Name = "windwave"
skmesh.Scale = Vector3.new(.04,.01,.04)
removeuseless:AddItem(sk,2)
for i,v in pairs(Torso:GetDescendants()) do if v.Name == "windwave" then
v.Scale = v.Scale + Vector3.new(.01,0,.01)
v.Parent.Transparency = v.Parent.Transparency + .05
end
end
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(29 - 12 * math.sin(sine/12)),0,0),.05)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:Lerp(CFrame.new(-1.65,.75,0) * CFrame.Angles(math.rad(10),math.rad(5),math.rad(-35)),.05)
LEFTARMLERP.C0 = LEFTARMLERP.C0:Lerp(CFrame.new(1.65,.75,0)* CFrame.Angles(math.rad(10),math.rad(-5),math.rad(35)),.05)
hum.HipHeight = hum.HipHeight + .1
swait()
end
coroutine.wrap(function()
for i = 1, 45 do
for i,v in pairs(Torso:GetDescendants()) do if v.Name == "windwave" then
v.Scale = v.Scale + Vector3.new(.01,0,.01)
v.Parent.Transparency = v.Parent.Transparency + .05
end
end
swait()
end
end)()
SOUND(Torso,2458107258,8,false,5)
groundrum = Instance.new("Sound",Torso)
groundrum.SoundId = "rbxassetid://1265219916"
groundrum.Volume = 10
groundrum.Pitch = 1.5
groundrum:Play()
removeuseless:AddItem(groundrum,4)
hum.HipHeight = 0
wait(.2)
Hit = damagealll(31,Torso.Position)
for _,v in pairs(Hit) do
if whitetotem then

elseif avatarstate then

else

end
vel = Instance.new("BodyVelocity",v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")) 
vel.maxForce = Vector3.new(9999999999999,9999999999999,9999999999999)
torso = v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
vel.velocity = CFrame.new(Torso.Position,torso.Position).lookVector*125
removeuseless:AddItem(vel,.1)
end
coroutine.wrap(function()
bnmv = 0
craterloc = Instance.new("Part",Torso)
craterloc.Size = Vector3.new(1,1,1)
craterloc.Transparency = 1
craterloc.Anchored = false
craterloc.CanCollide = false
craterlocweld = weldBetween(craterloc,Root)
removeuseless:AddItem(craterloc,25)
shockwave = Instance.new("Part", Torso)
shockwave.Size = Vector3.new(1,1,1)
shockwave.CanCollide = false
shockwave.Anchored = true
shockwave.Transparency = .5
shockwave.BrickColor = BrickColor.new("White")
shockwave.CFrame = CFrame.new(craterloc.Position)
shockwavemesh = Instance.new("SpecialMesh", shockwave)
shockwavemesh.Scale = Vector3.new(7,14,7)
shockwavemesh.MeshId = "rbxassetid://20329976"
shockwave2 = Instance.new("Part", Torso)
shockwave2.Size = Vector3.new(1,1,1)
shockwave2.CanCollide = false
shockwave2.Anchored = true
shockwave2.Transparency = .5
shockwave2.BrickColor = BrickColor.new("White")
shockwave2.CFrame = CFrame.new(craterloc.Position)
shockwavemesh2 = Instance.new("SpecialMesh", shockwave2)
shockwavemesh2.Scale = Vector3.new(5,14,5)
shockwavemesh2.MeshId = "rbxassetid://20329976"
coroutine.wrap(function()
for i = 1, 30 do
swait()
shockwave.CFrame = shockwave.CFrame * CFrame.Angles(math.rad(0),math.rad(0+15),0)
shockwave2.CFrame = shockwave2.CFrame * CFrame.Angles(math.rad(0),math.rad(0-8),0)
shockwave.Transparency = shockwave.Transparency + 0.025
shockwave2.Transparency = shockwave2.Transparency + 0.025
shockwavemesh2.Scale = shockwavemesh2.Scale + Vector3.new(6,1,6)
shockwavemesh.Scale = shockwavemesh.Scale + Vector3.new(6,1,6)
end
shockwave:Remove()
shockwave2:Remove()
end)()
for i = 1, 75 do
bnmv = bnmv + 15
grassblocks = Instance.new("Part",craterloc)
grassblocks.Size = Vector3.new(1,1,1)
grassblocks.Material = "Grass"
grassblocks.Anchored = false
grassblocks.Transparency = 1
grassblocks.CanCollide = false
grassblockswld = weldBetween(grassblocks,craterloc)
grassblockswld.C0 = CFrame.new(-15,8.5,0) * CFrame.Angles(math.rad(0),math.rad(bnmv),0)
removeuseless:AddItem(grassblocks,25)
crater2 = Instance.new("Part",Torso)
crater2.CFrame = grassblocks.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
crater2.Size = Vector3.new(6.5,6.5,6.5)
crater2.Anchored = true
crater2.Name = "cr2"
crater2.Material = "Grass"
crater2.BrickColor = BrickColor.new("Bright green")
end
end)()
for i = 1, 45 do
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.4, 1, 0.501) * CFrame.Angles(math.rad(-80), math.rad(-5), math.rad(0)), 0.3)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5, 0, 0) * CFrame.Angles(math.rad(-30), math.rad(0), math.rad(0)), 0.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(-80), math.rad(-10), math.rad(0)), 0.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 1.2, .8) * CFrame.Angles(math.rad(-80), math.rad(0), math.rad(0)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 1.9, -.34) * CFrame.Angles(math.rad(-40), math.rad(0), math.rad(10)), 0.3)
swait()
end
for i = 1, 50 do
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(-0), math.rad(-0), math.rad(0)), 0.08)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.08)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10)), 0.08)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.08)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(10)), 0.08)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.5,0)* CFrame.Angles(math.rad(-10),math.rad(0),math.rad(20)),.08)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.5,0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(-20)),.08)
swait()
end
SOUND(Torso,2466413404,8,false,6)
coroutine.wrap(function()
for i = 1, 25 do
sk = Instance.new("Part",Torso)
sk.CanCollide = false
sk.Anchored = true
sk.BrickColor = BrickColor.new("White")
sk.Name = "sk"
sk.CFrame = Torso.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),0,math.rad(math.random(-180,180)))
skmesh = Instance.new("SpecialMesh",sk)
skmesh.MeshId = "rbxassetid://662586858"
skmesh.Name = "windwave"
skmesh.Scale = Vector3.new(.01,.01,.01)
removeuseless:AddItem(sk,4)
end
for i = 1, 25 do
for i,v in pairs(Torso:GetDescendants()) do if v.Name == "windwave" then
v.Scale = v.Scale + Vector3.new(.02,0,.02)
v.Parent.Transparency = v.Parent.Transparency + .01
end
end
swait()
end
for i = 1, 25 do
for i,v in pairs(Torso:GetDescendants()) do if v.Name == "windwave" then
v.Scale = v.Scale + Vector3.new(.005,0,.005)
v.Parent.Transparency = v.Parent.Transparency + .05
end
end
swait()
end
end)()
windball = Instance.new("Part",Torso)
windball.Size = Vector3.new(20,20,20)
windball.Shape = "Ball"
windball.CanCollide = false
windball.Anchored = true
windball.Material = "Neon"
windball.CFrame = Root.CFrame
windball.Transparency = 1
for i = 1, 75 do
windball.CFrame = Root.CFrame
windball.Transparency = windball.Transparency - 0.02
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,-.4,0) * CFrame.Angles(math.rad(29),0,0),.2)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:Lerp(CFrame.new(-1.65,.75,0) * CFrame.Angles(math.rad(40),math.rad(5),math.rad(-35)),.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:Lerp(CFrame.new(1.65,.75,0)* CFrame.Angles(math.rad(40),math.rad(-5),math.rad(35)),.2)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 1.9, .39) * CFrame.Angles(math.rad(30), math.rad(0), math.rad(-10)), 0.2)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 1.9, .39) * CFrame.Angles(math.rad(30), math.rad(0), math.rad(10)), 0.2)
swait()
end
windball2 = windball:Clone()
windball2.Parent = Torso
windball.Transparency = .5
coroutine.wrap(function()
for i = 1, 25 do
sk = Instance.new("Part",Torso)
sk.CanCollide = false
sk.Anchored = true
sk.BrickColor = BrickColor.new("White")
sk.Name = "sk"
sk.CFrame = Torso.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),0,math.rad(math.random(-180,180)))
skmesh = Instance.new("SpecialMesh",sk)
skmesh.MeshId = "rbxassetid://662586858"
skmesh.Name = "windwave"
skmesh.Scale = Vector3.new(.01,.01,.01)
removeuseless:AddItem(sk,4)
end
for i = 1, 25 do
for i,v in pairs(Torso:GetDescendants()) do if v.Name == "windwave" then
v.Scale = v.Scale + Vector3.new(.02,0,.02)
v.Parent.Transparency = v.Parent.Transparency + .01
end
end
swait()
end
for i = 1, 25 do
for i,v in pairs(Torso:GetDescendants()) do if v.Name == "windwave" then
v.Scale = v.Scale + Vector3.new(.005,0,.005)
v.Parent.Transparency = v.Parent.Transparency + .05
end
end
swait()
end
end)()
SOUND(Torso,1619519574,8,false,5)
for i = 1, 50 do
for i,v in pairs(Torso:GetDescendants()) do if v.Name == "cr2" then
v.Transparency = v.Transparency + .02
end
end
windball2.Size = windball2.Size + Vector3.new(4,4,4)
windball2.Transparency = windball2.Transparency + .05
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.05)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.05)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.6, 0.5 - .1 * -math.sin(sine/12), 0) * CFrame.Angles(math.rad(35 - 2 * math.sin(sine/12)), math.rad(0), math.rad(25 + 5 * math.sin(sine/12))), 0.05)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.6, 0.5 - .1 * -math.sin(sine/12), 0) * CFrame.Angles(math.rad(35 - 2 * math.sin(sine/12)), math.rad(0), math.rad(-25 - 5 * math.sin(sine/12))), 0.05)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-41 - 1 * math.sin(sine/9)), math.rad(0 + 0 * math.cos(sine/8)), math.rad(0) + Root.RotVelocity.Y / 15, math.cos(10 * math.cos(sine/10))), 0.05)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 2 + .02 * math.sin(sine/12), 0.2 + .1 * math.sin(sine/12)) * CFrame.Angles(math.rad(25 + 5 * math.sin(sine/12)), math.rad(-20), math.rad(0)), 0.05)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.54, 2 + .02 * math.sin(sine/12), 0.2 + .1 * math.sin(sine/12)) * CFrame.Angles(math.rad(25 + 5 * math.sin(sine/12)), math.rad(20), math.rad(0)), 0.05)
swait()
end
for i,v in pairs(Torso:GetDescendants()) do if v.Name == "cr2" then
v:Remove()
end
end
windball.Anchored = false
windballweld = weldBetween(windball,Torso)
windball2:Remove()
pzp = Instance.new("Part",Torso)
pzp.Size = Vector3.new(1,1,1)
pzp.CanCollide = false
pzp.Transparency = 1
pzpweld = weldBetween(pzp,Torso)
pzpweld.C0 = CFrame.new(0,0,0)
pzp2 = Instance.new("Part",Torso)
pzp2.Size = Vector3.new(1,1,1)
pzp2.CanCollide = false
pzp2.Transparency = 1
pzpweld2 = weldBetween(pzp2,pzp)
pzpweld2.C0 = CFrame.new(12,3,0)
pzp3 = Instance.new("Part",Torso)
pzp3.Size = Vector3.new(1,1,1)
pzp3.CanCollide = false
pzp3.Transparency = 1
pzpweld3 = weldBetween(pzp3,pzp)
pzpweld3.C0 = CFrame.new(-12,3,0)
pzp4 = Instance.new("Part",Torso)
pzp4.Size = Vector3.new(1,1,1)
pzp4.CanCollide = false
pzp4.Transparency = 1
pzpweld4 = weldBetween(pzp4,Root)
pzpweld4.C0 = CFrame.new(0,0,10.5)
earthquak = Instance.new("Sound",Torso)
earthquak.Volume = 9
earthquak.SoundId = "rbxassetid://2017948224"
earthquak.Looped = true
earthquak:Play()
tornad = Instance.new("Sound",windball)
tornad.Volume = 10
tornad.Looped = true
tornad.SoundId = "rbxassetid://1245010022"
tornad:Play()
g1 = Instance.new("BodyGyro", Root)
g1.D = 175
g1.P = 20000
g1.MaxTorque = Vector3.new(0,9000,0)
winddashing = true
while winddashing do
Hit = damagealll(35,Torso.Position)
for _,v in pairs(Hit) do
if whitetotem then

else

end
vel = Instance.new("BodyVelocity",v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")) 
vel.maxForce = Vector3.new(9999999999999,9999999999999,9999999999999)
torso = v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
vel.velocity = CFrame.new(Torso.Position,torso.Position).lookVector*190
removeuseless:AddItem(vel,.1)
end
if mouse.Target ~= nil then
sk = Instance.new("Part",Torso)
sk.CanCollide = false
sk.Anchored = true
sk.BrickColor = BrickColor.new("White")
sk.Name = "sk"
sk.CFrame = pzp4.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),0,math.rad(math.random(-180,180)))
skmesh = Instance.new("SpecialMesh",sk)
skmesh.MeshId = "rbxassetid://662586858"
skmesh.Name = "windwave"
skmesh.Scale = Vector3.new(.01,.01,.01)
removeuseless:AddItem(sk,4)
for i,v in pairs(Torso:GetDescendants()) do if v.Name == "windwave" then
v.Scale = v.Scale + Vector3.new(.02,0,.02)
v.Parent.Transparency = v.Parent.Transparency + .025
end
end
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.6, 0.5 - .1 * -math.sin(sine/12), 0) * CFrame.Angles(math.rad(35 - 2 * math.sin(sine/12)), math.rad(0), math.rad(25 + 5 * math.sin(sine/12))), 0.5)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.6, 0.5 - .1 * -math.sin(sine/12), 0) * CFrame.Angles(math.rad(35 - 2 * math.sin(sine/12)), math.rad(0), math.rad(-25 - 5 * math.sin(sine/12))), 0.5)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.Angles(math.rad(-41), math.rad(0), math.rad(0)), 0.5)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 2 + .02 * math.sin(sine/12), 0.2 + .1 * math.sin(sine/12)) * CFrame.Angles(math.rad(25 + 5 * math.sin(sine/12)), math.rad(-20), math.rad(0)), 0.5)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.54, 2 + .02 * math.sin(sine/12), 0.2 + .1 * math.sin(sine/12)) * CFrame.Angles(math.rad(25 + 5 * math.sin(sine/12)), math.rad(20), math.rad(0)), 0.5)
earthquak.Volume = 9
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.2)
Root.CFrame = Root.CFrame * CFrame.new(0,0,-4)
coroutine.wrap(function()
local grassblocks = Instance.new("Part",Torso)
grassblocks.Size = Vector3.new(6,6,6)
grassblocks.Material = "Grass"
grassblocks.BrickColor = BrickColor.new("Bright green")
grassblocks.Anchored = true
grassblocks.Transparency = 0
grassblocks.CanCollide = false
grassblocks.CFrame = pzp3.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
local grassblocks2 = Instance.new("Part",Torso)
grassblocks2.Size = Vector3.new(6,6,6)
grassblocks2.Material = "Grass"
grassblocks2.Anchored = true
grassblocks2.BrickColor = BrickColor.new("Bright green")
grassblocks2.Transparency = 0
grassblocks2.CanCollide = false
grassblocks2.CFrame = pzp2.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
wait(2)
for i = 1, 25 do
grassblocks.Transparency = grassblocks.Transparency + .05
grassblocks2.Transparency = grassblocks2.Transparency + .05
swait()
end
grassblocks:Remove()
grassblocks2:Remove()
end)()
else
for i,v in pairs(Torso:GetDescendants()) do if v.Name == "windwave" then
v.Scale = v.Scale + Vector3.new(.02,0,.02)
v.Parent.Transparency = v.Parent.Transparency + .01
end
end
earthquak.Volume = 0
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2 + -.1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0),math.rad(25),math.rad(0)),.4)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1,-.2,.4) * CFrame.Angles(math.rad(-87 + .01 * math.sin(sine/9)),math.rad(80 - 3 * math.sin(sine/9)),math.rad(0)), 0.4)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.7,-.2,.4) * CFrame.Angles(math.rad(-87 - .01 * math.sin(sine/9)),math.rad(-88 + .7 * math.sin(sine/9)),math.rad(0)), 0.4)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10)), 0.4)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(10)), 0.4)
end
swait()
end
end
elseif Press=='f' then
if avatarstate then return end
if debounce then return end
debounce = true
attacking = true
allowlev = false
avatarstatee = Instance.new("Sound",Torso)
avatarstatee.SoundId = "rbxassetid://2496371442"
avatarstatee.Volume = 10
avatarstatee:Play()
coroutine.wrap(function()
for i = 1, 100 do
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 1.9, -.2) * CFrame.Angles(math.rad(-25 + 5 * math.sin(sine/12)), math.rad(20), math.rad(0)), 0.05)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.54, 1.9, -.2) * CFrame.Angles(math.rad(-25 + 5 * math.sin(sine/12)), math.rad(-20), math.rad(0)), 0.05)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.75,.5) * CFrame.Angles(math.rad(-60),math.rad(-20 + 1 *math.sin(sine/12)),0),.05)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.75,.5) * CFrame.Angles(math.rad(-60),math.rad(20 - 1 * math.sin(sine/12)),0),.05)
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(-60),0,0),.05)
swait()
end
end)()
for i = 1, 140 do
doomtheme.Volume = doomtheme.Volume - .05
swait()
end
doomtheme.Volume = 6
doomtheme:Play()
levitatewave3 = Instance.new("Part", Torso)
levitatewave3.Size = Vector3.new(1,1,1)
levitatewave3.CanCollide = false
levitatewave3.Anchored = false
levitatewave3.Transparency = .75
levitatewave3.BrickColor = BrickColor.new("White")
levitatewave3.CFrame = CFrame.new(Root.Position) * CFrame.new(0,-5,0)
levitatewavemesh3 = Instance.new("SpecialMesh", levitatewave3)
levitatewavemesh3.Scale = Vector3.new(11,1.25,11)
levitatewavemesh3.MeshId = "rbxassetid://20329976"
levitatewaveweld3 = weldBetween(levitatewave3,locbrick1)
levitatewave4 = Instance.new("Part", Torso)
levitatewave4.Size = Vector3.new(1,1,1)
levitatewave4.CanCollide = false
levitatewave4.Anchored = false
levitatewave4.Transparency = .75
levitatewave4.BrickColor = BrickColor.new("White")
levitatewave4.CFrame = CFrame.new(Root.Position) * CFrame.new(0,-5,0)
levitatewavemesh4 = Instance.new("SpecialMesh", levitatewave4)
levitatewavemesh4.Scale = Vector3.new(15,2,15)
levitatewavemesh4.MeshId = "rbxassetid://20329976"
levitatewaveweld4 = weldBetween(levitatewave4,locbrick1)
levitatewave5 = Instance.new("Part", Torso)
levitatewave5.Size = Vector3.new(1,1,1)
levitatewave5.CanCollide = false
levitatewave5.Anchored = false
levitatewave5.Transparency = .75
levitatewave5.BrickColor = BrickColor.new("White")
levitatewave5.CFrame = CFrame.new(Root.Position) * CFrame.new(0,-5,0)
levitatewavemesh5 = Instance.new("SpecialMesh", levitatewave5)
levitatewavemesh5.Scale = Vector3.new(24,6,24)
levitatewavemesh5.MeshId = "rbxassetid://20329976"
levitatewaveweld5 = weldBetween(levitatewave5,locbrick1)
levitatewave6 = Instance.new("Part", Torso)
levitatewave6.Size = Vector3.new(1,1,1)
levitatewave6.CanCollide = false
levitatewave6.Anchored = false
levitatewave6.Transparency = .75
levitatewave6.BrickColor = BrickColor.new("White")
levitatewave6.CFrame = CFrame.new(Root.Position) * CFrame.new(0,-5,0)
levitatewavemesh6 = Instance.new("SpecialMesh", levitatewave6)
levitatewavemesh6.Scale = Vector3.new(23,6,23)
levitatewavemesh6.MeshId = "rbxassetid://20329976"
levitatewaveweld6 = weldBetween(levitatewave6,locbrick1)
windblocks3 = Instance.new("Part",Torso)
windblocks3.Size = Vector3.new(1,1,1)
windblocks3.Transparency = 1
windblocks3.Anchored = false
windblocks3.CanCollide = false
windblocks3weld = weldBetween(windblocks3,Root)

windblocks4 = Instance.new("Part",Torso)
windblocks4.Size = Vector3.new(1,1,1)
windblocks4.Transparency = 1
windblocks4.Anchored = false
windblocks4.CanCollide = false
windblocks4weld = weldBetween(windblocks4,Root)
windring3 = Instance.new("Part", Torso)
windring3.Size = Vector3.new(1, 1, 1)
windring3.Transparency = .9
windring3.Anchored = false
windring3.BrickColor = BrickColor.new("Really white")
windring3.CanCollide = false
ringh3 = Instance.new("SpecialMesh", windring3) 
ringh3.MeshId = "http://www.roblox.com/asset/?id=3270017" 
ringh3.Scale = Vector3.new(39, 39, 4)
windring3weld = weldBetween(windring3,windblocks3)
windring4 = Instance.new("Part", Torso)
windring4.Size = Vector3.new(1, 1, 1)
windring4.Transparency = .9
windring4.Anchored = false
windring4.BrickColor = BrickColor.new("Really white")
windring4.CanCollide = false
ringh4 = Instance.new("SpecialMesh", windring4) 
ringh4.MeshId = "http://www.roblox.com/asset/?id=3270017" 
ringh4.Scale = Vector3.new(39, 39, 4)
windring4weld = weldBetween(windring4,windblocks4)
wind3 = Instance.new("Part", Torso)
wind3.Size = Vector3.new(0.5, 0.5, 0.5)
wind3.Material = "Neon"
wind3.BrickColor = BrickColor.new("Really white")
wind3.Transparency = .88
wind3.CanCollide = false
windMESH3 = Instance.new("SpecialMesh", wind3)
windMESH3.Scale = Vector3.new(9.5,9.5,9.5)
windMESH3.MeshId = "rbxassetid://168892432"
windWeld3 = weldBetween(wind3,Root)
windWeld3.C0 = CFrame.new(0,-10,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
wind4 = Instance.new("Part", Torso)
wind4.Size = Vector3.new(0.5, 0.5, 0.5)
wind4.Material = "Neon"
wind4.BrickColor = BrickColor.new("Really white")
wind4.Transparency = .96
wind4.CanCollide = false
windMESH4 = Instance.new("SpecialMesh", wind4)
windMESH4.Scale = Vector3.new(12,12,12)
windMESH4.MeshId = "rbxassetid://168892432"
windWeld4 = weldBetween(wind4,Root)
windWeld4.C0 = CFrame.new(0,-10,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
waind = 0
for i = 1, 50 do
waind = waind + 5
local windblockss = Instance.new("Part",Torso)
windblockss.Material = "Neon"
windblockss.BrickColor = BrickColor.new("White")
windblockss.Anchored = true
windblockss.Transparency = .5
windblockss.CanCollide = false
windblockss.Size = Vector3.new(5+waind,5+waind,5+waind)
windblockss.Name = "waind2"
windblockss.CFrame = Root.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
removeuseless:AddItem(windblockss,6)
coroutine.wrap(function()
for i = 1, 40 do
windblockss.Transparency = windblockss.Transparency + .025
swait()
end
windblockss:Remove()
end)()
swait(1)
end
avatarstate = true
debounce = false
attacking = false
allowlev = true
elseif Press=='g' then
if debounce then return end
debounce = true
attacking = true
allowlev = false
ws = 6
g1 = Instance.new("BodyGyro", Root)
g1.D = 175
g1.P = 20000
g1.MaxTorque = Vector3.new(0,9000,0)
coroutine.wrap(function()
for i = 1, 85 do
coroutine.wrap(function()
local WindBlastw = Instance.new("Part",Torso)
WindBlastw.CFrame = rightlocation.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
WindBlastw.Material = "Neon"
WindBlastw.BrickColor = BrickColor.new("White")
WindBlastw.Transparency = .75
WindBlastw.Size = Vector3.new(1,1,1)
WindBlastw.Anchored = true
WindBlastw.CanCollide = false
local WindBlastx = Instance.new("Part",Torso)
WindBlastx.CFrame = leftlocation.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
WindBlastx.Material = "Neon"
WindBlastx.BrickColor = BrickColor.new("White")
WindBlastx.Transparency = .75
WindBlastx.Size = Vector3.new(1,1,1)
WindBlastx.Anchored = true
WindBlastx.CanCollide = false
for i = 1, 25 do
WindBlastx.Size = WindBlastx.Size + Vector3.new(2,2,2)
WindBlastx.Transparency = WindBlastx.Transparency + .05
WindBlastw.Size = WindBlastw.Size + Vector3.new(2,2,2)
WindBlastw.Transparency = WindBlastw.Transparency + .05
swait()
end
WindBlastx:Remove()
WindBlastw:Remove()
end)()
sk = Instance.new("Part",Torso)
sk.CanCollide = false
sk.Anchored = true
sk.BrickColor = BrickColor.new("White")
sk.Name = "sk"
sk.CFrame = rightlocation.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),0,math.rad(math.random(-180,180)))
skmesh = Instance.new("SpecialMesh",sk)
skmesh.MeshId = "rbxassetid://662586858"
skmesh.Name = "windwave"
skmesh.Scale = Vector3.new(.04,.01,.04)
removeuseless:AddItem(sk,2)
sk2 = Instance.new("Part",Torso)
sk2.CanCollide = false
sk2.Anchored = true
sk2.BrickColor = BrickColor.new("White")
sk2.Name = "sk2"
sk2.CFrame = leftlocation.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),0,math.rad(math.random(-180,180)))
skmesh2 = Instance.new("SpecialMesh",sk2)
skmesh2.MeshId = "rbxassetid://662586858"
skmesh2.Name = "windwave2"
skmesh2.Scale = Vector3.new(.04,.01,.04)
removeuseless:AddItem(sk2,2)
for i,v in pairs(Torso:GetDescendants()) do
if v.Name == "windwave" then
v.Parent.Transparency = v.Parent.Transparency + .045
v.Scale = v.Scale + Vector3.new(.005,0,.005)
end
end
for i,v in pairs(Torso:GetDescendants()) do
if v.Name == "windwave2" then
v.Parent.Transparency = v.Parent.Transparency + .045
v.Scale = v.Scale + Vector3.new(.005,0,.005)
end
end
swait()
end
end)()
Wind = Instance.new("Sound",Torso)
Wind.Volume = 8
Wind.SoundId = "rbxassetid://147348734"
Wind.Pitch = 1.2
Wind:Play()
removeuseless:AddItem(Wind,6)
for i = 1, 85 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.2)
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(30),0,0),.3)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(.5,2,0) * CFrame.Angles(math.rad(0),math.rad(20),math.rad(-140)),.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(-.5,2,0) * CFrame.Angles(math.rad(0),math.rad(-20),math.rad(140)),.3)
swait()
end
coroutine.wrap(function()
for i = 1, 15 do
sk = Instance.new("Part",Torso)
sk.CanCollide = false
sk.Anchored = true
sk.BrickColor = BrickColor.new("White")
sk.Name = "sk"
sk.CFrame = rightlocation.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),0,math.rad(math.random(-180,180)))
skmesh = Instance.new("SpecialMesh",sk)
skmesh.MeshId = "rbxassetid://662586858"
skmesh.Name = "xm"
skmesh.Scale = Vector3.new(.04,.01,.04)
removeuseless:AddItem(sk,2)
sk2 = Instance.new("Part",Torso)
sk2.CanCollide = false
sk2.Anchored = true
sk2.BrickColor = BrickColor.new("White")
sk2.Name = "sk2"
sk2.CFrame = leftlocation.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),0,math.rad(math.random(-180,180)))
skmesh2 = Instance.new("SpecialMesh",sk2)
skmesh2.MeshId = "rbxassetid://662586858"
skmesh2.Name = "mx"
skmesh2.Scale = Vector3.new(.04,.01,.04)
removeuseless:AddItem(sk2,2)
for i,v in pairs(Torso:GetDescendants()) do if v.Name == "mx" then
v.Scale = v.Scale + Vector3.new(.03,0,.03)
v.Parent.Transparency = v.Parent.Transparency + .05
end
end
for i,v in pairs(Torso:GetDescendants()) do if v.Name == "xm" then
v.Scale = v.Scale + Vector3.new(.03,0,.03)
v.Parent.Transparency = v.Parent.Transparency + .05
end
end
swait()
end
for i = 1, 45 do
for i,v in pairs(Torso:GetDescendants()) do if v.Name == "mx" then
v.Scale = v.Scale + Vector3.new(.03,0,.03)
v.Parent.Transparency = v.Parent.Transparency + .05
end
end
for i,v in pairs(Torso:GetDescendants()) do if v.Name == "xm" then
v.Scale = v.Scale + Vector3.new(.03,0,.03)
v.Parent.Transparency = v.Parent.Transparency + .05
end
end
swait()
end
end)()
removeuseless:AddItem(g1,.001)
coroutine.wrap(function()
for i = 1, 50 do
swait()
for i,v in pairs(Torso:GetDescendants()) do
if v.Name == "windwave" then
v.Parent.Transparency = v.Parent.Transparency + .045
v.Scale = v.Scale + Vector3.new(.005,0,.005)
end
end
for i,v in pairs(Torso:GetDescendants()) do
if v.Name == "windwave2" then
v.Parent.Transparency = v.Parent.Transparency + .045
v.Scale = v.Scale + Vector3.new(.005,0,.005)
end
end
end
end)()
ws = 0
SOUND(Torso,2458107258,10,false,4)
coroutine.wrap(function()
local blastpart = Instance.new("Part",Torso)
SOUND(blastpart,479309152,8,true,50)
blastpart.Size = Vector3.new(5,5,5)
blastpart.Name = "blastpart"
blastpart.Anchored = true
blastpart.Transparency = 1
blastpart.CanCollide = false
blastpart.CFrame = Root.CFrame
local locationblast = Instance.new("Part",blastpart)
locationblast.Size = Vector3.new(5,5,5)
locationblast.CanCollide = false
locationblast.Anchored = true
locationblast.Transparency = 1
locationblast.CFrame = blastpart.CFrame * CFrame.new(-5,0,0)
local locationblast2 = Instance.new("Part",blastpart)
locationblast2.Size = Vector3.new(1,1,1)
locationblast2.CanCollide = false
locationblast2.Anchored = true
locationblast2.Transparency = 1
locationblast2.CFrame = blastpart.CFrame * CFrame.new(-5,0,0)
for i = 1, 175 do
Hit = damagealll(58,blastpart.Position)
for _,v in pairs(Hit) do
if whitetotem then

elseif avatarstate then

else

end
vel = Instance.new("BodyVelocity",v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")) 
vel.maxForce = Vector3.new(9999999999999,9999999999999,9999999999999)
torso = v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
vel.velocity = CFrame.new(blastpart.Position,torso.Position).lookVector*100
removeuseless:AddItem(vel,.1)
end
coroutine.wrap(function()
local sk = Instance.new("Part",Torso)
sk.CanCollide = false
sk.Anchored = true
sk.BrickColor = BrickColor.new("White")
sk.Name = "sk"
sk.CFrame = locationblast.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),0,math.rad(math.random(-180,180)))
local skmesh = Instance.new("SpecialMesh",sk)
skmesh.MeshId = "rbxassetid://662586858"
skmesh.Name = "windwave"
skmesh.Scale = Vector3.new(.04,.01,.04)
removeuseless:AddItem(sk,2)
local sk2 = Instance.new("Part",Torso)
sk2.CanCollide = false
sk2.Anchored = true
sk2.BrickColor = BrickColor.new("White")
sk2.Name = "sk2"
sk2.CFrame = locationblast2.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),0,math.rad(math.random(-180,180)))
local skmesh2 = Instance.new("SpecialMesh",sk2)
skmesh2.MeshId = "rbxassetid://662586858"
skmesh2.Name = "windwave2"
skmesh2.Scale = Vector3.new(.04,.01,.04)
removeuseless:AddItem(sk,2)
local WindBlast = Instance.new("Part",Torso)
WindBlast.CFrame = blastpart.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
WindBlast.Material = "Neon"
WindBlast.Transparency = .6
WindBlast.Size = Vector3.new(42,42,42)
WindBlast.Anchored = true
WindBlast.CanCollide = false
for i = 1, 25 do
skmesh2.Scale = skmesh2.Scale + Vector3.new(.09,0,.09)
skmesh.Scale = skmesh.Scale + Vector3.new(.09,0,.09)
skmesh.Parent.Transparency = skmesh.Parent.Transparency + 0.04
skmesh2.Parent.Transparency = skmesh2.Parent.Transparency + 0.04
WindBlast.Transparency = WindBlast.Transparency + 0.022
swait()
end
sk:Remove()
sk2:Remove()
WindBlast:Remove()
end)()
blastpart.CFrame = blastpart.CFrame * CFrame.new(0,0,0-4.5)
locationblast2.CFrame = blastpart.CFrame * CFrame.new(10,-8,0)
locationblast.CFrame = blastpart.CFrame * CFrame.new(-10,-8,0)
locationblast2.Size = Vector3.new(1,1,1)
locationblast.Size = Vector3.new(1,1,1)
swait()
end
locationblast:Remove()
blastpart:Remove()
locationblast2:Remove()
end)()
for i = 1, 35 do
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.2,.8,.5) * CFrame.Angles(math.rad(-90),math.rad(25),math.rad(3)), .3)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.2,.8,.5) * CFrame.Angles(math.rad(-90),math.rad(-25),math.rad(-3)), .3)
swait()
end
ws = 90
allowlev = true
attacking = false 
debounce = false
elseif Press=='q' then
if debounce then return end
attacking = true
debounce = true
if spwt then
SOUND(Torso,339027743,8,false,4)
coroutine.wrap(function()
for i = 1, 10 do
sk = Instance.new("Part",Torso)
sk.CanCollide = false
sk.Anchored = true
sk.BrickColor = BrickColor.new(colors2)
sk.Name = "sk"
sk.CFrame = waterlocbrick2.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),0,math.rad(math.random(-180,180)))
skmesh = Instance.new("SpecialMesh",sk)
skmesh.MeshId = "rbxassetid://662586858"
skmesh.Name = "sklol3"
skmesh.Scale = Vector3.new(.04,.01,.04)
removeuseless:AddItem(sk,2)
end
for i = 1, 25 do
for i,v in pairs(Torso:GetDescendants()) do
if v.Name == "sklol3" then
v.Scale = v.Scale + Vector3.new(.01,0,.01)
end
end
swait()
end
end)()
coroutine.wrap(function()
for i = 1, 10 do
sk = Instance.new("Part",Torso)
sk.CanCollide = false
sk.Anchored = true
sk.BrickColor = BrickColor.new(colors2)
sk.Name = "sk"
sk.CFrame = waterlocbrick.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),0,math.rad(math.random(-180,180)))
skmesh = Instance.new("SpecialMesh",sk)
skmesh.MeshId = "rbxassetid://662586858"
skmesh.Name = "sklol4"
skmesh.Scale = Vector3.new(.04,.01,.04)
removeuseless:AddItem(sk,2)
end
for i = 1, 25 do
for i,v in pairs(Torso:GetDescendants()) do
if v.Name == "sklol4" then
v.Scale = v.Scale + Vector3.new(.02,0,.02)
end
end
swait()
end
end)()
waterwaveb = Instance.new("Part",Torso)
waterwaveb.CFrame = waterlocbrick.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),0,math.rad(math.random(-180,180)))
waterwaveb.Size = Vector3.new(1,1,1)
waterwaveb.BrickColor = BrickColor.new(colors2)
waterwaveb.Transparency = .2
waterwaveb.CanCollide = false
waterwaveb.Anchored = true
waterwaveb.Material = "Neon"
waterwaveb2 = Instance.new("Part",Torso)
waterwaveb2.CFrame = waterlocbrick2.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),0,math.rad(math.random(-180,180)))
waterwaveb2.Size = Vector3.new(1,1,1)
waterwaveb2.BrickColor = BrickColor.new(colors2)
waterwaveb2.Transparency = .2
waterwaveb2.CanCollide = false
waterwaveb2.Anchored = true
waterwaveb2.Material = "Neon"
coroutine.wrap(function()
for i = 1, 25 do
sow = sow - 0.25
waterwaveb.Size = waterwaveb.Size + Vector3.new(.9,.9,.9)
waterwaveb2.Size = waterwaveb2.Size + Vector3.new(.9,.9,.9)
waterwaveb.Transparency = waterwaveb.Transparency + .05
waterwaveb2.Transparency = waterwaveb2.Transparency + .05
swait()
end
spinwater = false
pxcbrick:Remove()
waterlocbrick:Remove()
waterlocbrick2:Remove()
waterwaveb:Remove()
waterwaveb2:Remove()
spwt = false
attacking = false
debounce = false
end)()
else
ws = 0
spinwater = true
spwt = true
coroutine.wrap(function()
local shockwave = Instance.new("Part",Torso)
shockwave.Shape = "Ball"
shockwave.Size = Vector3.new(1,1,1)
shockwave.Transparency = 0
shockwave.Anchored = true
shockwave.CanCollide = false
shockwave.BrickColor = BrickColor.new("Cyan")
shockwave.CFrame = Torso.CFrame
shockwave.Material = "Neon"
coroutine.wrap(function()
coroutine.wrap(function()
for i = 1, 50 do
for i,v in pairs(Torso:GetDescendants()) do
if v.Name == "sklol2" then
v.Scale = v.Scale + Vector3.new(.01,0,.01)
v.Parent.Transparency = v.Parent.Transparency + 0.05
end
end
swait()
end
end)()
for i = 1, 15 do
swait()
sk = Instance.new("Part",Torso)
sk.CanCollide = false
sk.Anchored = true
sk.Material = "Neon"
sk.BrickColor = BrickColor.new(colors2)
sk.Name = "sk2"
sk.CFrame = Torso.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),0,math.rad(math.random(-180,180)))
skmesh = Instance.new("SpecialMesh",sk)
skmesh.MeshId = "rbxassetid://662586858"
skmesh.Name = "sklol2"
skmesh.Scale = Vector3.new(.09,.01,.09)
removeuseless:AddItem(sk,2)
end
end)()
for i = 1, 30 do
shockwave.Size = shockwave.Size + Vector3.new(4,4,4)
shockwave.Transparency = shockwave.Transparency + .045
swait()
end
end)()
SOUND(Torso,2136440257,8,false,8)
SOUND(Torso,169486406,10,false,4)
coroutine.wrap(function()
pxcbrick = Instance.new("Part",Root)
pxcbrick.Size = Vector3.new(1,1,1)
pxcbrick.CanCollide = false
pxcbrick.Transparency = 1
pxcbrickweld = weldBetween(pxcbrick,Torso)
waterlocbrick = Instance.new("Part",Torso)
waterlocbrick.Size = Vector3.new(1,1,1)
waterlocbrick.Anchored = false
waterlocbrick.Transparency = 1
waterlocbrick.CanCollide = false
wazx = weldBetween(waterlocbrick,pxcbrick)
wazx.C0 = CFrame.new(0,0,0)
waterlocbrick2 = Instance.new("Part",Torso)
waterlocbrick2.Size = Vector3.new(1,1,1)
waterlocbrick2.Anchored = false
waterlocbrick2.Transparency = 1
waterlocbrick2.CanCollide = false
wazx2 = weldBetween(waterlocbrick2,pxcbrick)
wazx2.C0 = CFrame.new(0,0,0)
coroutine.wrap(function()
sow = 5
while spinwater do
colors2 = colortable2[math.random(1,#colortable2)]
waterwave = Instance.new("Part",waterlocbrick)
waterwave.BrickColor = BrickColor.new(colors2)
waterwave.Size = Vector3.new(sow,sow,sow)
waterwave.CFrame = waterlocbrick.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
waterwave.CanCollide = false
waterwave.Material = "Neon"
waterwave.Transparency = .4
waterwave.Name = "waterwave"
removeuseless:AddItem(waterwave,1.3)
waterwave2 = Instance.new("Part",waterlocbrick2)
waterwave2.BrickColor = BrickColor.new(colors2)
waterwave2.Size = Vector3.new(sow,sow,sow)
waterwave2.Material = "Neon"
waterwave2.Transparency = .4
waterwave2.CFrame = waterlocbrick2.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
waterwave2.CanCollide = false
waterwave2.Name = "waterwave2"
removeuseless:AddItem(waterwave2,1.3)
for i,v in pairs(waterlocbrick:GetDescendants()) do
if v.Name == "waterwave" then
v.Size = v.Size - Vector3.new(.3,.3,.3)
end
end
for i,v in pairs(waterlocbrick2:GetDescendants()) do
if v.Name == "waterwave2" then
v.Size = v.Size - Vector3.new(.3,.3,.3)
end
end
swait(.1)
end
end)()
for i = 1, 70 do
wazx.C0 = wazx.C0:lerp(CFrame.new(-15,0,0),.1)
wazx2.C0 = wazx2.C0:lerp(CFrame.new(15,0,0),.1)
swait()
end
mb = 25
for i = 1, 40 do
pxcbrickweld.C0 = pxcbrickweld.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,math.rad(25),0),.05)
swait()
end
coroutine.wrap(function()
coroutine.wrap(function()
if firsttimewtr then return end
firsttimewtr = true
while true do
for i,v in pairs(Torso:GetDescendants()) do
if v.Name == "sklol4" then
v.Scale = v.Scale + Vector3.new(.01,0,.01)
v.Parent.Transparency = v.Parent.Transparency + .05
end
end
for i,v in pairs(Torso:GetDescendants()) do
if v.Name == "sklol3" then
v.Scale = v.Scale + Vector3.new(.01,0,.01)
v.Parent.Transparency = v.Parent.Transparency + .05
end
end
swait()
end
end)()
while spinwater do
swait(15)
Hit = damagealll(14,waterlocbrick2.Position)
for _,v in pairs(Hit) do
coroutine.wrap(function()
for i = 1, 10 do
sk = Instance.new("Part",Torso)
sk.CanCollide = false
sk.Anchored = true
sk.BrickColor = BrickColor.new(colors2)
sk.Name = "sk"
sk.CFrame = waterlocbrick2.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),0,math.rad(math.random(-180,180)))
skmesh = Instance.new("SpecialMesh",sk)
skmesh.MeshId = "rbxassetid://662586858"
skmesh.Name = "sklol3"
skmesh.Scale = Vector3.new(.04,.01,.04)
removeuseless:AddItem(sk,2)
end
end)()
if bluetotem then

elseif avatarstate then

else

end
vel = Instance.new("BodyVelocity",v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")) 
vel.maxForce = Vector3.new(9999999999999,9999999999999,9999999999999)
torso = v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
vel.velocity = CFrame.new(Torso.Position,torso.Position).lookVector*125
removeuseless:AddItem(vel,.1)
SOUND(waterlocbrick2,169486406,10,false,4)
end
Hit = damagealll(14,waterlocbrick.Position)
for _,v in pairs(Hit) do
coroutine.wrap(function()
for i = 1, 10 do
sk = Instance.new("Part",Torso)
sk.CanCollide = false
sk.Anchored = true
sk.BrickColor = BrickColor.new(colors2)
sk.Name = "sk"
sk.CFrame = waterlocbrick.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),0,math.rad(math.random(-180,180)))
skmesh = Instance.new("SpecialMesh",sk)
skmesh.MeshId = "rbxassetid://662586858"
skmesh.Name = "sklol4"
skmesh.Scale = Vector3.new(.04,.01,.04)
removeuseless:AddItem(sk,2)
end
end)()
if bluetotem then

else

end
vel = Instance.new("BodyVelocity",v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")) 
vel.maxForce = Vector3.new(9999999999999,9999999999999,9999999999999)
torso = v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
vel.velocity = CFrame.new(Torso.Position,torso.Position).lookVector*125
removeuseless:AddItem(vel,.1)
SOUND(waterlocbrick,169486406,10,false,4)
end
swait()
end
end)()
while spinwater do
mb = mb - 3
pxcbrickweld.C0 = pxcbrickweld.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,math.rad(mb),0),.1)
swait()
end
end)()
for i = 1, 110 do
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(25),0,0),.05)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:Lerp(CFrame.new(-1.65,.75,0) * CFrame.Angles(math.rad(10),math.rad(5),math.rad(-35)),.05)
LEFTARMLERP.C0 = LEFTARMLERP.C0:Lerp(CFrame.new(1.65,.75,0)* CFrame.Angles(math.rad(10),math.rad(-5),math.rad(35)),.05)
swait()
end
ws = 90
attacking = false
debounce = false
end
elseif Press=='p' then
if debounce then return end
debounce = true
attacking = true
apocalypse = true
ws = 0
coroutine.wrap(function()
colors = colortable[math.random(1,#colortable)]
local shockwave = Instance.new("Part",Torso)
shockwave.Shape = "Ball"
shockwave.Size = Vector3.new(1,1,1)
shockwave.Transparency = 0
shockwave.Anchored = true
shockwave.CanCollide = false
shockwave.BrickColor = BrickColor.new(colors)
shockwave.CFrame = Torso.CFrame
shockwave.Material = "Neon"
for i = 1, 30 do
shockwave.Size = shockwave.Size + Vector3.new(4,4,4)
shockwave.Transparency = shockwave.Transparency + .045
swait()
end
end)()
explosionsound = Instance.new("Sound",Torso)
explosionsound.Volume = 10
explosionsound.Pitch = 1
explosionsound:Play()
explosionsound.SoundId = "rbxassetid://1327085116"
coroutine.wrap(function()
while apocalypse do
swait(10)
if avatarstate then
Hit = damagealll(60,Torso.Position)
else
Hit = damagealll(32,Torso.Position)
end
for _,v in pairs(Hit) do
if redtotem then

elseif avatarstate then

else

end
vel = Instance.new("BodyVelocity",v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")) 
vel.maxForce = Vector3.new(9999999999999,9999999999999,9999999999999)
torso = v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
vel.velocity = CFrame.new(Torso.Position,torso.Position).lookVector*60
removeuseless:AddItem(vel,.1)
end
explosionsound:Play()
end
end)()
coroutine.wrap(function()
while apocalypse do
swait(.3)
wshockwave = Instance.new("Part", Torso)
wshockwave.Size = Vector3.new(1,1,1)
wshockwave.CanCollide = false
wshockwave.Anchored = true
wshockwave.Transparency = .45
wshockwave.BrickColor = BrickColor.new(colors)
wshockwave.CFrame = CFrame.new(Torso.Position) * CFrame.Angles(math.rad(math.random(-180,180)),0,math.rad(math.random(-180,180)))
wshockwavemesh = Instance.new("SpecialMesh", wshockwave)
wshockwavemesh.Scale = Vector3.new(1,.05,1)
wshockwavemesh.Name = "wswm"
wshockwavemesh.MeshId = "rbxassetid://20329976"
removeuseless:AddItem(wshockwave,2)
fairebalz = Instance.new("Part",Torso)
fairebalz.Size = Vector3.new(.1,.1,.1)
fairebalz.Transparency = 0
fairebalz.Name = "fairebalz"
fairebalz.BrickColor = BrickColor.new(colors)
fairebalz.Anchored = true
fairebalz.CanCollide = false
fairebalz.Material = "Neon"
fairebalz.CFrame = Root.CFrame * CFrame.new(math.random(-15,15),math.random(-15,15),math.random(-15,15)) * CFrame.Angles(math.rad(math.random(-180,180)),0,math.rad(math.random(-180,180)))
removeuseless:AddItem(fairebalz,1)
sk = Instance.new("Part",Torso)
sk.CanCollide = false
sk.Anchored = true
sk.BrickColor = BrickColor.new(colors)
sk.Name = "sk"
sk.CFrame = Torso.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),0,math.rad(math.random(-180,180)))
skmesh = Instance.new("SpecialMesh",sk)
skmesh.MeshId = "rbxassetid://662586858"
skmesh.Name = "sklol"
skmesh.Scale = Vector3.new(.09,.05,.09)
removeuseless:AddItem(sk,2)
if not avatarstate then
for i,v in pairs(Torso:GetDescendants()) do
if v.Name == "sklol" then
v.Parent.Transparency = v.Parent.Transparency + 0.06
v.Scale = v.Scale + Vector3.new(.03,.001,.03)
end
end
for i,v in pairs(Torso:GetDescendants()) do
if v.Name == "wswm" then
v.Parent.Transparency = v.Parent.Transparency + 0.05
v.Scale = v.Scale + Vector3.new(2,0,2)
end
end
for i,v in pairs(Torso:GetDescendants()) do
if v.Name == "fairebalz" then
v.Transparency = v.Transparency + 0.05
v.Size = v.Size + Vector3.new(.45,.45,.45)
end
end
else
for i,v in pairs(Torso:GetDescendants()) do
if v.Name == "sklol" then
v.Parent.Transparency = v.Parent.Transparency + 0.06
v.Scale = v.Scale + Vector3.new(.06,.002,.06)
end
end
for i,v in pairs(Torso:GetDescendants()) do
if v.Name == "wswm" then
v.Parent.Transparency = v.Parent.Transparency + 0.05
v.Scale = v.Scale + Vector3.new(4,0,4)
end
end
for i,v in pairs(Torso:GetDescendants()) do
if v.Name == "fairebalz" then
v.Transparency = v.Transparency + 0.05
v.Size = v.Size + Vector3.new(.9,.9,.9)
end
end
end
end
end)()
for i = 1, 135 do
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(29 - 12 * math.sin(sine/12)),0,0),.05)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:Lerp(CFrame.new(-1.65,.75,0) * CFrame.Angles(math.rad(10),math.rad(5),math.rad(-35)),.05)
LEFTARMLERP.C0 = LEFTARMLERP.C0:Lerp(CFrame.new(1.65,.75,0)* CFrame.Angles(math.rad(10),math.rad(-5),math.rad(35)),.05)
swait()
end
wait(.1)
coroutine.wrap(function()
for i = 1, 30 do
for i,v in pairs(Torso:GetDescendants()) do
if v.Name == "sklol" then
v.Parent.Transparency = v.Parent.Transparency + 0.06
v.Scale = v.Scale + Vector3.new(.03,.001,.03)
end
end
for i,v in pairs(Torso:GetDescendants()) do
if v.Name == "fairebalz" then
v.Transparency = v.Transparency + 0.05
v.Size = v.Size + Vector3.new(.25,.25,.25)
end
end
for i,v in pairs(Torso:GetDescendants()) do
if v.Name == "wswm" then
v.Parent.Transparency = v.Parent.Transparency + 0.05
v.Scale = v.Scale + Vector3.new(2,0,2)
end
end
swait()
end
end)()
apocalypse = false
attacking = false
debounce = false
ws = 90
removeuseless:AddItem(explosionsound,5)
elseif Press=='u' then
if debounce then return end
debounce = true
attacking = true
ws = 16
g1 = Instance.new("BodyGyro", Root)
g1.D = 175
g1.P = 20000
g1.MaxTorque = Vector3.new(0,9000,0)
if avatarstate then
for i = 1, 5 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.4)
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(-30),0,0),.8)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.3,0,.2) * CFrame.Angles(math.rad(30),math.rad(30),0),.8)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.3,0,.2) * CFrame.Angles(math.rad(30),math.rad(-30),0),.8)
swait()
end
else
for i = 1, 15 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.2)
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(-30),0,0),.4)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.3,0,.2) * CFrame.Angles(math.rad(30),math.rad(30),0),.4)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.3,0,.2) * CFrame.Angles(math.rad(30),math.rad(-30),0),.4)
swait()
end
end
ws = 0
removeuseless:AddItem(g1,.001)
shieldlocbrick = Instance.new("Part",Torso)
shieldlocbrick.Size = Vector3.new(1,1,1)
shieldlocbrick.Anchored = true
shieldlocbrick.Transparency = 1
shieldlocbrick.CanCollide = false
shieldlocbrick.CFrame = Root.CFrame * CFrame.new(0,-6,-24)
Hit = damagealll(25,shieldlocbrick.Position)
for _,v in pairs(Hit) do
if browntotem then

else

end
vel = Instance.new("BodyVelocity",v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")) 
vel.maxForce = Vector3.new(9999999999999,9999999999999,9999999999999)
torso = v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
vel.velocity = CFrame.new(shieldlocbrick.Position,torso.Position).lookVector*75
removeuseless:AddItem(vel,.1)
end
removeuseless:AddItem(shieldlocbrick,5)
SOUND(shieldlocbrick,1119859528,8,false,5)
coroutine.wrap(function()
local grshield = Instance.new("Part",Torso)
grshield.Material = "Grass"
grshield.Anchored = true
grshield.BrickColor = BrickColor.new("Bright green")
grshield.Size = Vector3.new(4,math.random(42,48),12)
grshield.CFrame = Root.CFrame * CFrame.new(0,-30,-18) * CFrame.Angles(math.rad(math.random(-8,-3)),math.rad(math.random(82,98)),math.rad(math.random(-20,-15)))
local grshield2 = Instance.new("Part",Torso)
grshield2.Material = "Grass"
grshield2.Anchored = true
grshield2.BrickColor = BrickColor.new("Bright green")
grshield2.Size = Vector3.new(4,math.random(42,48),12)
grshield2.CFrame = Root.CFrame * CFrame.new(8,-30,-18) * CFrame.Angles(math.rad(math.random(-8,-3)),math.rad(math.random(82,98)),math.rad(math.random(-20,-15)))
local grshield3 = Instance.new("Part",Torso)
grshield3.Material = "Grass"
grshield3.Anchored = true
grshield3.BrickColor = BrickColor.new("Bright green")
grshield3.Size = Vector3.new(4,math.random(42,48),12)
grshield3.CFrame = Root.CFrame * CFrame.new(-8,-30,-18) * CFrame.Angles(math.rad(math.random(-8,-3)),math.rad(math.random(82,98)),math.rad(math.random(-20,-15)))
local grshield4 = Instance.new("Part",Torso)
grshield4.Material = "Grass"
grshield4.Anchored = true
grshield4.BrickColor = BrickColor.new("Bright green")
grshield4.Size = Vector3.new(4,math.random(42,48),12)
grshield4.CFrame = Root.CFrame * CFrame.new(16,-30,-18) * CFrame.Angles(math.rad(math.random(-8,-3)),math.rad(math.random(82,98)),math.rad(math.random(-20,-15)))
local grshield5 = Instance.new("Part",Torso)
grshield5.Material = "Grass"
grshield5.Anchored = true
grshield5.BrickColor = BrickColor.new("Bright green")
grshield5.Size = Vector3.new(4,math.random(42,48),12)
grshield5.CFrame = Root.CFrame * CFrame.new(-16,-30,-18) * CFrame.Angles(math.rad(math.random(-8,-3)),math.rad(math.random(82,98)),math.rad(math.random(-20,-15)))
for i = 1, 15 do
grshield.CFrame = grshield.CFrame * CFrame.new(0,2,0)
grshield2.CFrame = grshield2.CFrame * CFrame.new(0,2,0)
grshield3.CFrame = grshield3.CFrame * CFrame.new(0,2,0)
grshield4.CFrame = grshield4.CFrame * CFrame.new(0,2,0)
grshield5.CFrame = grshield5.CFrame * CFrame.new(0,2,0)
swait()
end
for i = 1, 5 do
grshield.CFrame = grshield.CFrame * CFrame.new(0,.2,0)
grshield2.CFrame = grshield2.CFrame * CFrame.new(0,.2,0)
grshield3.CFrame = grshield3.CFrame * CFrame.new(0,.2,0)
grshield4.CFrame = grshield4.CFrame * CFrame.new(0,.2,0)
grshield5.CFrame = grshield5.CFrame * CFrame.new(0,.2,0)
swait()
end
for i = 1, 5 do
grshield.CFrame = grshield.CFrame * CFrame.new(0,-.2,0)
grshield2.CFrame = grshield2.CFrame * CFrame.new(0,-.2,0)
grshield3.CFrame = grshield3.CFrame * CFrame.new(0,-.2,0)
grshield4.CFrame = grshield4.CFrame * CFrame.new(0,-.2,0)
grshield5.CFrame = grshield5.CFrame * CFrame.new(0,-.2,0)
swait()
end
wait(30)
for i = 1, 6 do
grshield.CFrame = grshield.CFrame * CFrame.new(0,.4,0)
grshield2.CFrame = grshield2.CFrame * CFrame.new(0,.4,0)
grshield3.CFrame = grshield3.CFrame * CFrame.new(0,.4,0)
grshield4.CFrame = grshield4.CFrame * CFrame.new(0,.4,0)
grshield5.CFrame = grshield5.CFrame * CFrame.new(0,.4,0)
swait()
end
for i = 1, 30 do
grshield.Transparency = grshield.Transparency + .025
grshield2.Transparency = grshield2.Transparency + .025
grshield3.Transparency = grshield3.Transparency + .025
grshield4.Transparency = grshield4.Transparency + .025
grshield5.Transparency = grshield5.Transparency + .025
grshield.CFrame = grshield.CFrame * CFrame.new(0,-2,0)
grshield2.CFrame = grshield2.CFrame * CFrame.new(0,-2,0)
grshield3.CFrame = grshield3.CFrame * CFrame.new(0,-2,0)
grshield4.CFrame = grshield4.CFrame * CFrame.new(0,-2,0)
grshield5.CFrame = grshield5.CFrame * CFrame.new(0,-2,0)
swait()
end
grshield:Remove()
grshield2:Remove()
grshield3:Remove()
grshield4:Remove()
grshield5:Remove()
end)()
if avatarstate then
for i = 1, 5 do
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(30),0,0),.8)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.3,1,.35) * CFrame.Angles(math.rad(-110),math.rad(-12),math.rad(1)),.8)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.3,1,.35) * CFrame.Angles(math.rad(-110),math.rad(12),math.rad(-1)),.8)
swait()
end
else
for i = 1, 15 do
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(30),0,0),.4)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.3,1,.35) * CFrame.Angles(math.rad(-110),math.rad(-12),math.rad(1)),.4)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.3,1,.35) * CFrame.Angles(math.rad(-110),math.rad(12),math.rad(-1)),.4)
swait()
end
end
debounce = false
attacking = false
ws = 90
elseif Press=='x' then
id = 2435339444
doomtheme.SoundId = "rbxassetid://"..id
doomtheme:Play()
elseif Press=='z' then
id = 2327920334
doomtheme.SoundId = "rbxassetid://"..id
doomtheme:Play()
elseif Press=='y' then
if debounce then return end
debounce = true
attacking = true
allowlev = false
zxm={}
ws = 0
waterball = Instance.new("Part",Torso)
waterball.Size = Vector3.new(25,25,25)
waterball.Transparency = .9
waterball.Shape = "Ball"
waterball.BrickColor = BrickColor.new("Cyan")
waterball.Anchored = true
waterball.Material = "Neon"
waterball.CanCollide = false
waterball.CFrame = Root.CFrame
waterp = true
coroutine.wrap(function()
while waterball.Transparency > 0 do
waterball.CFrame = Root.CFrame
waterblockk = Instance.new("Part",Torso)
waterblockk.Material = waterblocks.Material
waterblockk.BrickColor = waterblocks.BrickColor
waterblockk.CanCollide = false
waterblockk.Anchored = true
waterblockk.Size = Vector3.new(2,2,2)
waterblockk.Name = "nd"
waterblockk.Transparency = .25
table.insert(zxm,waterblockk)
waterblockk.CFrame = Root.CFrame * CFrame.new(math.random(-18,18),math.random(-18,18),math.random(-18,18)) * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
removeuseless:AddItem(waterblockk,.75)
swait(5)
end
end)()
coroutine.wrap(function()
while waterball.Transparency > 0 do
waterball.Transparency = waterball.Transparency -  0.0050
for i,v in pairs(zxm) do 
v.Transparency = v.Transparency + .05
v.CFrame = v.CFrame:lerp(CFrame.new(Root.Position) * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180))) ,.09)
end
swait()
end
waterp = false
for i = 1, 25 do
for i,v in pairs(zxm) do 
v.Transparency = v.Transparency + .05
v.Size = v.Size + Vector3.new(.5,.5,.5)
end
swait()
end
end)()
for i = 1, 20 do
waterball.Size = waterball.Size - Vector3.new(.85,.85,.85)
waterball.CFrame = Root.CFrame
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),.5)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1,-.2,.4) * CFrame.Angles(math.rad(-87),math.rad(80),math.rad(0)), 0.3)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.7,-.2,.4) * CFrame.Angles(math.rad(-87),math.rad(-88),math.rad(0)), 0.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 1., .9) * CFrame.Angles(math.rad(20), math.rad(-1), math.rad(-3)), 0.25)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(20), math.rad(1), math.rad(3)), 0.25)
swait()
end
while wait() do
if not waterp then break end
end
wshockwave = Instance.new("Part", Torso)
wshockwave.Size = Vector3.new(1,1,1)
wshockwave.CanCollide = false
wshockwave.Anchored = true
wshockwave.Transparency = 1
wshockwave.BrickColor = BrickColor.new("Cyan")
wshockwave.CFrame = CFrame.new(waterball.Position) * CFrame.new(0,-9,0)
wshockwavemesh = Instance.new("SpecialMesh", wshockwave)
wshockwavemesh.Scale = Vector3.new(1,3,1)
wshockwavemesh.MeshId = "rbxassetid://20329976"
wshockwave2 = Instance.new("Part", Torso)
wshockwave2.Size = Vector3.new(1,1,1)
wshockwave2.CanCollide = false
wshockwave2.Anchored = true
wshockwave2.Transparency = 1
wshockwave2.BrickColor = BrickColor.new("Cyan")
wshockwave2.CFrame = CFrame.new(waterball.Position) * CFrame.new(0,-9,0)
wshockwavemesh2 = Instance.new("SpecialMesh", wshockwave2)
wshockwavemesh2.Scale = Vector3.new(2,3,2)
wshockwavemesh2.MeshId = "rbxassetid://20329976"
waterball2 = waterball:Clone()
waterball2.Parent = Torso
waterball2.Transparency = .25
waterball3 = waterball:Clone()
waterball3.Parent = Torso
waterball3.Transparency = .5
waterball4 = waterball:Clone()
waterball4.Parent = Torso
waterball4.Transparency = .75
fkd = Instance.new("Sound",Torso)
fkd.SoundId = "rbxassetid://2136442504"
fkd.Volume = 8
fkd:Play()
dbw = 25
for i = 1, 6 do
wshockwave.CFrame = CFrame.new(waterball.Position) * CFrame.new(0,-9,0)
wshockwave2.CFrame = CFrame.new(waterball.Position) * CFrame.new(0,-9,0)
wshockwave.Transparency = 1
wshockwave2.Transparency = 1
wshockwavemesh2.Scale = Vector3.new(4,3,4)
wshockwavemesh.Scale = Vector3.new(2,3,2)
dbw = dbw + 25
swait()
if avatarstate then
Hit = damagealll(120,waterball.Position)
else
Hit = damagealll(65,waterball.Position)
end
for _,v in pairs(Hit) do
if bluetotem then

elseif avatarstate then

else

end
vel = Instance.new("BodyVelocity",v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")) 
vel.maxForce = Vector3.new(9999999999999,9999999999999,9999999999999)
torso = v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
vel.velocity = CFrame.new(waterball.Position,torso.Position).lookVector*dbw
removeuseless:AddItem(vel,.1)
end
if avatarstate then
for i = 1, 35 do
waterball.CFrame = Root.CFrame
waterball2.CFrame = Root.CFrame
waterball3.CFrame = Root.CFrame
waterball4.CFrame = Root.CFrame
wshockwave.Transparency = wshockwave.Transparency - .015
wshockwave2.Transparency = wshockwave2.Transparency - .015
wshockwave.CFrame = wshockwave.CFrame * CFrame.Angles(0,math.rad(0+15),0)
wshockwave2.CFrame = wshockwave2.CFrame * CFrame.Angles(0,math.rad(0-15),0)
wshockwavemesh.Scale = wshockwavemesh.Scale + Vector3.new(7,.89,7)
wshockwavemesh2.Scale = wshockwavemesh2.Scale + Vector3.new(8,2,8)
waterball2.Size = waterball2.Size + Vector3.new(2,2,2)
waterball3.Size = waterball3.Size + Vector3.new(4,4,4)
waterball4.Size = waterball4.Size + Vector3.new(6,6,6)
swait()
end
for i = 1, 25 do
waterball.CFrame = Root.CFrame
waterball2.CFrame = Root.CFrame
waterball3.CFrame = Root.CFrame
waterball4.CFrame = Root.CFrame
wshockwave.CFrame = wshockwave.CFrame * CFrame.Angles(0,math.rad(0+7),0)
wshockwave2.CFrame = wshockwave2.CFrame * CFrame.Angles(0,math.rad(0-7),0)
wshockwavemesh.Scale = wshockwavemesh.Scale + Vector3.new(3.5,.87,3.5)
wshockwavemesh2.Scale = wshockwavemesh2.Scale + Vector3.new(4,1,4)
waterball2.Size = waterball2.Size + Vector3.new(1,1,1)
waterball3.Size = waterball3.Size + Vector3.new(2,2,2)
waterball4.Size = waterball4.Size + Vector3.new(3,3,3)
swait()
end
for i = 1, 40 do
waterball.CFrame = Root.CFrame
waterball2.CFrame = Root.CFrame
waterball3.CFrame = Root.CFrame
waterball4.CFrame = Root.CFrame
wshockwave.CFrame = wshockwave.CFrame * CFrame.Angles(0,math.rad(0+20),0)
wshockwave2.CFrame = wshockwave2.CFrame * CFrame.Angles(0,math.rad(0-20),0)
wshockwave.Transparency = wshockwave.Transparency +.03
wshockwave2.Transparency = wshockwave2.Transparency + .03
wshockwavemesh.Scale = wshockwavemesh.Scale - Vector3.new(14,4,14)
wshockwavemesh2.Scale = wshockwavemesh2.Scale - Vector3.new(16,6,16)
waterball2.Size = waterball2.Size - Vector3.new(4,4,4)
waterball3.Size = waterball3.Size - Vector3.new(8,8,8)
waterball4.Size = waterball4.Size - Vector3.new(12,12,12)
swait()
end
else
for i = 1, 35 do
waterball.CFrame = Root.CFrame
waterball2.CFrame = Root.CFrame
waterball3.CFrame = Root.CFrame
waterball4.CFrame = Root.CFrame
wshockwave.Transparency = wshockwave.Transparency - .015
wshockwave2.Transparency = wshockwave2.Transparency - .015
wshockwave.CFrame = wshockwave.CFrame * CFrame.Angles(0,math.rad(0+15),0)
wshockwave2.CFrame = wshockwave2.CFrame * CFrame.Angles(0,math.rad(0-15),0)
wshockwavemesh.Scale = wshockwavemesh.Scale + Vector3.new(3.5,.4375,3.5)
wshockwavemesh2.Scale = wshockwavemesh2.Scale + Vector3.new(4,1,4)
waterball2.Size = waterball2.Size + Vector3.new(1,1,1)
waterball3.Size = waterball3.Size + Vector3.new(2,2,2)
waterball4.Size = waterball4.Size + Vector3.new(3,3,3)
swait()
end
for i = 1, 25 do
waterball.CFrame = Root.CFrame
waterball2.CFrame = Root.CFrame
waterball3.CFrame = Root.CFrame
waterball4.CFrame = Root.CFrame
wshockwave.CFrame = wshockwave.CFrame * CFrame.Angles(0,math.rad(0+7),0)
wshockwave2.CFrame = wshockwave2.CFrame * CFrame.Angles(0,math.rad(0-7),0)
wshockwavemesh.Scale = wshockwavemesh.Scale + Vector3.new(1.75,.4375,1.75)
wshockwavemesh2.Scale = wshockwavemesh2.Scale + Vector3.new(2,.5,2)
waterball2.Size = waterball2.Size + Vector3.new(.5,.5,.5)
waterball3.Size = waterball3.Size + Vector3.new(1,1,1)
waterball4.Size = waterball4.Size + Vector3.new(1.5,1.5,1.5)
swait()
end
for i = 1, 40 do
waterball.CFrame = Root.CFrame
waterball2.CFrame = Root.CFrame
waterball3.CFrame = Root.CFrame
waterball4.CFrame = Root.CFrame
wshockwave.CFrame = wshockwave.CFrame * CFrame.Angles(0,math.rad(0+20),0)
wshockwave2.CFrame = wshockwave2.CFrame * CFrame.Angles(0,math.rad(0-20),0)
wshockwave.Transparency = wshockwave.Transparency +.03
wshockwave2.Transparency = wshockwave2.Transparency + .03
wshockwavemesh.Scale = wshockwavemesh.Scale - Vector3.new(7,2,7)
wshockwavemesh2.Scale = wshockwavemesh2.Scale - Vector3.new(8,3,8)
waterball2.Size = waterball2.Size - Vector3.new(2,2,2)
waterball3.Size = waterball3.Size - Vector3.new(4,4,4)
waterball4.Size = waterball4.Size - Vector3.new(6,6,6)
swait()
end
end
end
for i = 1, 50 do
waterball.CFrame = Root.CFrame
waterball2.CFrame = Root.CFrame
waterball3.CFrame = Root.CFrame
waterball4.CFrame = Root.CFrame
waterball.Transparency = waterball.Transparency + .025
waterball2.Transparency = waterball2.Transparency + .025
waterball3.Transparency = waterball3.Transparency + .035
waterball4.Transparency = waterball4.Transparency + .045
waterball.Size = waterball.Size + Vector3.new(.5,.5,.5)
waterball2.Size = waterball2.Size + Vector3.new(1,1,1)
waterball3.Size = waterball3.Size + Vector3.new(2,2,2)
waterball4.Size = waterball4.Size + Vector3.new(3,3,3)
swait()
end
wshockwave:Remove()
wshockwave2:Remove()
waterball:Remove()
waterball2:Remove()
waterball3:Remove()
waterball4:Remove()
attacking = false
debounce = false
waterp = false
allowlev = true
fkd:Remove()
ws = 90
elseif Press=='t' then
if tauntdebounce then return end
if debounce then return end
debounce = true
tauntdebounce = true
attacking = true
debounce = true
ws = 6
coroutine.wrap(function()
for i = 1, 125 do
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(22 - 12 * math.sin(sine/12)),0,0),.4)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1,-.2,.4) * CFrame.Angles(math.rad(-87 + .01 * math.sin(sine/9)),math.rad(80 - 3 * math.sin(sine/9)),math.rad(0)), 0.4)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.7,-.2,.4) * CFrame.Angles(math.rad(-87 - .01 * math.sin(sine/9)),math.rad(-88 + .7 * math.sin(sine/9)),math.rad(0)), 0.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 2 + .02 * math.sin(sine/12), 0.2 + .1 * math.sin(sine/12)) * CFrame.Angles(math.rad(25 + 5 * math.sin(sine/12)), math.rad(-20), math.rad(0)), 0.4)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.54, 2 + .02 * math.sin(sine/12), 0.2 + .1 * math.sin(sine/12)) * CFrame.Angles(math.rad(25 + 5 * math.sin(sine/12)), math.rad(20), math.rad(0)), 0.4)
swait()
end
attacking = false
debounce = false
ws = 90
end)()
got2 = gottalktable2[math.random(1,#gottalktable2)]
tauntsound = Instance.new("Sound", Head)
tauntsound.Volume = 10
tauntsound.SoundId = "http://www.roblox.com/asset/?id="..got2
tauntsound.Looped = false
tauntsound:Play()
local b1 = Instance.new("BillboardGui",Head)
b1.Size = UDim2.new(0,4,0,1.6)
b1.StudsOffset = Vector3.new(0,0,0)
b1.Name = "ttau"
b1.AlwaysOnTop = true
b1.StudsOffset = Vector3.new(0,4,0)
b1.Adornee = Head
removeuseless:AddItem(b1,8)
local b2 = Instance.new("TextLabel",b1)
b2.BackgroundTransparency = 1
if tauntsound.SoundId == "http://www.roblox.com/asset/?id=2492600258" then
b2.Text = "On your knees."
elseif tauntsound.SoundId == "http://www.roblox.com/asset/?id=2492598999" then
b2.Text = "I've survived many battles."
elseif tauntsound.SoundId == "http://www.roblox.com/asset/?id=2492599159" then
b2.Text = "You do not impress."
elseif tauntsound.SoundId == "http://www.roblox.com/asset/?id=2492599303" then
b2.Text = "You would test a god?"
elseif tauntsound.SoundId == "http://www.roblox.com/asset/?id=2492599503" then
b2.Text = "You will respect my title!"
elseif tauntsound.SoundId == "http://www.roblox.com/asset/?id=2492599663" then
b2.Text = "I shall honor you with combat!"
elseif tauntsound.SoundId == "http://www.roblox.com/asset/?id=2492599795" then
b2.Text = "A lamb to the slaughter."
elseif tauntsound.SoundId == "http://www.roblox.com/asset/?id=2492599925" then
b2.Text = "You're most worthy, to die by my hand."
elseif tauntsound.SoundId == "http://www.roblox.com/asset/?id=2492600097" then
b2.Text = "Your soul burns!"
elseif tauntsound.SoundId == "http://www.roblox.com/asset/?id=2492600455" then
b2.Text = "Pathetic."
end
b2.Font = "Garamond"
b2.TextSize = 50
b2.Name = "lafftext"
b2.TextStrokeTransparency = 1
b2.Transparency = 1
b2.TextColor3 = BrickColor.new("Cyan").Color
b2.TextStrokeColor3 = Color3.new(0,0,0)
b2.Size = UDim2.new(1,0,.5,0)
coroutine.wrap(function()
for i = 1, 20 do
b2.Transparency = b2.Transparency - .05
b2.TextStrokeTransparency = b2.TextStrokeTransparency - .05
swait()
end
end)()
wait(tauntsound.TimeLength)
wait(3)
coroutine.wrap(function()
for i = 1, 20 do
b2.Transparency = b2.Transparency + .05
b2.TextStrokeTransparency = b2.TextStrokeTransparency + .05
swait()
end
end)()
tauntsound:Remove()
wait(1)
tauntdebounce = false
elseif Press=='r' then
if debounce then return end
if fireball1 then
SOUND(rightlocation,842332424,7,false,4)
fireball1 = false
fireball2 = true
attacking = true
debounce = true
appi = true
coroutine.wrap(function()
while appi do
swait()
if Root.Velocity.Magnitude > 2 and attacking == true then
position = "Idle3"
end
end
end)()
coroutine.wrap(function()
while appi do
swait()
settime = 0.05
sine = sine + change
if position == "Idle3" and attacking == true and appi == true then
change = .5
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(50 + 3 * math.sin(sine/12)),math.rad(3 - 1 * math.sin(sine/12))),.5)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 2 + .02 * math.sin(sine/12), 0.2 + .1 * math.sin(sine/12)) * CFrame.Angles(math.rad(25 + 5 * math.sin(sine/12)), math.rad(-20), math.rad(0)), 0.5)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.54, 2 + .02 * math.sin(sine/12), 0.2 + .1 * math.sin(sine/12)) * CFrame.Angles(math.rad(25 + 5 * math.sin(sine/12)), math.rad(20), math.rad(0)), 0.5)
end
end
end)()
ws = 65
g1 = Instance.new("BodyGyro", Root)
g1.D = 175
g1.P = 20000
g1.MaxTorque = Vector3.new(0,9000,0)
if avatarstate then
for i = 1, 5 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.4)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(-10),math.rad(-15),math.rad(0)),.7)
RIGHTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(-14), math.rad(20), math.rad(-90)), 0.6)
swait()
end
else
for i = 1, 15 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.2)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(-10),math.rad(-15),math.rad(0)),.5)
RIGHTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(-14), math.rad(20), math.rad(-90)), 0.3)
swait()
end
end
swoosh = Instance.new("Part",Head)
swoosh.Size = Vector3.new(1,1,1)
swoosh.CanCollide = false
swoosh.Anchored = false
swoosh.Name = "swoosh"
swoosh.Transparency = 1
swoosh.CFrame = rightlocation.CFrame
coroutine.wrap(function()
if bbv then return end
bbv = true
while wait(.08) do
for i,v in pairs(Head:GetDescendants()) do
if v.Name == "swoosh" then
Hit = damagealll(13,v.Position)
for _,v in pairs(Hit) do
if redtotem then

elseif avatarstate then

else

end
vel = Instance.new("BodyVelocity",v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")) 
vel.maxForce = Vector3.new(9999999999999,9999999999999,9999999999999)
torso = v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
vel.velocity = CFrame.new(swoosh.Position,torso.Position).lookVector*100
removeuseless:AddItem(vel,.1)
end
end
end
end
end)()
coroutine.wrap(function()
if firsttime then return end
firsttime = true
while wait() do
for i,v in pairs(RightArm:GetChildren()) do
if v.Name == "magiccc" then
v.Transparency = v.Transparency + .05
end
end
for i,v in pairs(Head:GetChildren()) do
if v.Name == "swoosh" then
magiccc = Instance.new("Part",RightArm)
magiccc.Material = "Neon"
magiccc.CanCollide = false
magiccc.Anchored = true
magiccc.Name = "magiccc"
magiccc.BrickColor = BrickColor.new(colors)
magiccc.Size = Vector3.new(5,5,5)
magiccc.CFrame = v.CFrame * CFrame.Angles(math.random(-180,180),math.random(-180,180),math.random(-180,180))
removeuseless:AddItem(magiccc,2)
end
end
end
end)()
bov = Instance.new("BodyVelocity",swoosh)
bov.maxForce = Vector3.new(99999,99999,99999)
swoosh.CFrame = CFrame.new(swoosh.Position,mouse.Hit.p)
bov.velocity = swoosh.CFrame.lookVector*215
removeuseless:AddItem(swoosh,5)
if avatarstate then
for i = 1, 6 do
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(10),math.rad(15),math.rad(0)),.8)
RIGHTARMLERP.C1 = CFrame.new(0,0,0)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.2,1,.5) * CFrame.Angles(math.rad(-90),math.rad(-25),math.rad(0)), 0.8)
swait()
end
else
for i = 1, 12 do
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(10),math.rad(15),math.rad(0)),.5)
RIGHTARMLERP.C1 = CFrame.new(0,0,0)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.2,1,.5) * CFrame.Angles(math.rad(-90),math.rad(-25),math.rad(0)), 0.5)
swait()
end
end
ws = 90
appi = false
attacking = false
debounce = false
removeuseless:AddItem(g1,.01)
elseif fireball2 then
SOUND(leftlocation,842332424,7,false,4)
fireball1 = true
fireball2 = false
attacking = true
debounce = true
appi = true
coroutine.wrap(function()
while appi do
swait()
if Root.Velocity.Magnitude > 2 and attacking == true then
position = "Idle3"
end
end
end)()
coroutine.wrap(function()
while appi do
swait()
settime = 0.05
sine = sine + change
if position == "Idle3" and attacking == true and appi == true then
change = .5
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(-50 - 3 * math.sin(sine/12)),math.rad(-3 + 1 * math.sin(sine/12))), .5)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 2 + .02 * math.sin(sine/12), 0.2 + .1 * math.sin(sine/12)) * CFrame.Angles(math.rad(25 + 5 * math.sin(sine/12)), math.rad(-20), math.rad(0)), 0.5)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.54, 2 + .02 * math.sin(sine/12), 0.2 + .1 * math.sin(sine/12)) * CFrame.Angles(math.rad(25 + 5 * math.sin(sine/12)), math.rad(20), math.rad(0)), 0.5)
end
end
end)()
ws = 65
g1 = Instance.new("BodyGyro", Root)
g1.D = 175
g1.P = 20000
g1.MaxTorque = Vector3.new(0,9000,0)
if avatarstate then
for i = 1, 5 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.4)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(10),math.rad(15),math.rad(0)),.7)
LEFTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(0.5, 2, 0) * CFrame.Angles(math.rad(-14), math.rad(-20), math.rad(90)), 0.6)
swait()
end
else
for i = 1, 15 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.2)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(10),math.rad(15),math.rad(0)),.5)
LEFTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(0.5, 2, 0) * CFrame.Angles(math.rad(-14), math.rad(-20), math.rad(90)), 0.3)
swait()
end
end
swoosh = Instance.new("Part",Head)
swoosh.Size = Vector3.new(1,1,1)
swoosh.CanCollide = false
swoosh.Anchored = false
swoosh.Name = "swoosh"
swoosh.Transparency = 1
swoosh.CFrame = leftlocation.CFrame
coroutine.wrap(function()
if firsttime then return end
firsttime = true
while wait() do
for i,v in pairs(RightArm:GetChildren()) do
if v.Name == "magiccc" then
v.Transparency = v.Transparency + .05
end
end
for i,v in pairs(Head:GetChildren()) do
if v.Name == "swoosh" then
magiccc = Instance.new("Part",RightArm)
magiccc.Material = "Neon"
magiccc.CanCollide = false
magiccc.Anchored = true
magiccc.Name = "magiccc"
magiccc.BrickColor = BrickColor.new(colors)
magiccc.Size = Vector3.new(5,5,5)
magiccc.CFrame = v.CFrame * CFrame.Angles(math.random(-180,180),math.random(-180,180),math.random(-180,180))
removeuseless:AddItem(magiccc,2)
end
end
end
end)()
bov = Instance.new("BodyVelocity",swoosh)
bov.maxForce = Vector3.new(99999,99999,99999)
swoosh.CFrame = CFrame.new(swoosh.Position,mouse.Hit.p)
bov.velocity = swoosh.CFrame.lookVector*215
removeuseless:AddItem(swoosh,5)
if avatarstate then
for i = 1, 6 do
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(-10),math.rad(-15),math.rad(0)),.8)
LEFTARMLERP.C1 = CFrame.new(0,0,0)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.2,1,.5) * CFrame.Angles(math.rad(-90),math.rad(25),math.rad(0)), 0.8)
swait()
end
else
for i = 1, 12 do
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(-10),math.rad(-15),math.rad(0)),.5)
LEFTARMLERP.C1 = CFrame.new(0,0,0)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.2,1,.5) * CFrame.Angles(math.rad(-90),math.rad(25),math.rad(0)), 0.5)
swait()
end
end
ws = 90
attacking = false
debounce = false
appi = false
removeuseless:AddItem(g1,.01)
end
elseif Press=='e' then
if throw1 then
if debounce then return end
throw1 = false
throw2 = true
debounce = true
attacking = true
appi = true
ws = 12
g1 = Instance.new("BodyGyro", Root)
g1.D = 175
g1.P = 20000
g1.MaxTorque = Vector3.new(0,9000,0)
coroutine.wrap(function()
while appi do
swait()
if Root.Velocity.Magnitude > 2 and attacking == true then
position = "Idle3"
end
end
end)()
coroutine.wrap(function()
while appi do
swait()
settime = 0.05
sine = sine + change
if position == "Idle3" and attacking == true and appi == true then
change = .5
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(-50 - 3 * math.sin(sine/12)),math.rad(-3 + 1 * math.sin(sine/12))), .5)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 2 + .02 * math.sin(sine/12), 0.2 + .1 * math.sin(sine/12)) * CFrame.Angles(math.rad(25 + 5 * math.sin(sine/12)), math.rad(-20), math.rad(0)), 0.5)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.54, 2 + .02 * math.sin(sine/12), 0.2 + .1 * math.sin(sine/12)) * CFrame.Angles(math.rad(25 + 5 * math.sin(sine/12)), math.rad(20), math.rad(0)), 0.5)
end
end
end)()
if avatarstate then
for i = 1, 5 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.4)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(-20),math.rad(-20),math.rad(0)),.8)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.3,0,.2) * CFrame.Angles(math.rad(30),math.rad(30),0),.8)
swait()
end
else
for i = 1, 15 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.1)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(-20),math.rad(-20),math.rad(0)),.4)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.3,0,.2) * CFrame.Angles(math.rad(30),math.rad(30),0),.4)
swait()
end
end
if mouse.Target ~= nil then
biggrassblock = Instance.new("Part",Torso)
biggrassblock.Size = Vector3.new(math.random(15,18),50,math.random(15,18))
biggrassblock.Anchored = true
biggrassblock.CFrame = CFrame.new(mouse.Hit.p) * CFrame.new(0,-10,0) * CFrame.Angles(math.rad(math.random(-15,15)),math.rad(math.random(-15,15)),math.rad(math.random(-15,15)))
biggrassblock.CanCollide = true
biggrassblock.Material = "Slate"
biggrassblock.BrickColor = BrickColor.new("Earth green")
removeuseless:AddItem(biggrassblock,10)
coroutine.wrap(function()
local locbrick = Instance.new("Part",biggrassblock)
locbrick.Size = Vector3.new(1,1,1)
locbrick.Transparency = 1
locbrick.CFrame = CFrame.new(mouse.Hit.p)
locbrick.CanCollide = false
locbrick.Anchored = true
local locbrick2 = Instance.new("Part",biggrassblock)
locbrick2.Size = Vector3.new(1,1,1)
locbrick2.Transparency = 1
locbrick2.CFrame = CFrame.new(mouse.Hit.p)
locbrick2.CanCollide = false
locbrick2weld = weldBetween(locbrick2,locbrick)
local shockwave = Instance.new("Part", Torso)
shockwave.Size = Vector3.new(1,1,1)
shockwave.CanCollide = false
shockwave.Anchored = true
shockwave.Transparency = .5
shockwave.BrickColor = BrickColor.new("White")
shockwave.CFrame = CFrame.new(locbrick.Position)
shockwavemesh = Instance.new("SpecialMesh", shockwave)
shockwavemesh.Scale = Vector3.new(7,3,7)
shockwavemesh.MeshId = "rbxassetid://20329976"
local shockwave2 = Instance.new("Part", Torso)
shockwave2.Size = Vector3.new(1,1,1)
shockwave2.CanCollide = false
shockwave2.Anchored = true
shockwave2.Transparency = .5
shockwave2.BrickColor = BrickColor.new("White")
shockwave2.CFrame = CFrame.new(locbrick.Position)
shockwavemesh2 = Instance.new("SpecialMesh", shockwave2)
shockwavemesh2.Scale = Vector3.new(5,3,5)
shockwavemesh2.MeshId = "rbxassetid://20329976"
zxp = 0
for i = 1, 75 do
zxp = zxp + 5
crater = Instance.new("Part",Torso)
crater.BrickColor = biggrassblock.BrickColor
crater.Size = Vector3.new(5,5,5)
crater.Transparency = 1
craterweld = weldBetween(crater,locbrick2)
craterweld.C0 = craterweld.C0 * CFrame.new(15,0,0) * CFrame.Angles(math.rad(0),math.rad(zxp),math.rad(0))
removeuseless:AddItem(crater,1)
crater2 = Instance.new("Part",Torso)
crater2.CFrame = crater.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
crater2.Size = Vector3.new(13,13,13)
crater2.Anchored = true
crater2.Material = "Grass"
crater2.BrickColor = BrickColor.new("Bright green")
removeuseless:AddItem(crater2,15)
end
for i = 1, 30 do
swait()
shockwave.CFrame = shockwave.CFrame * CFrame.Angles(math.rad(0),math.rad(0+15),0)
shockwave2.CFrame = shockwave2.CFrame * CFrame.Angles(math.rad(0),math.rad(0-8),0)
shockwave.Transparency = shockwave.Transparency + 0.025
shockwave2.Transparency = shockwave2.Transparency + 0.025
shockwavemesh2.Scale = shockwavemesh2.Scale + Vector3.new(6,1,6)
shockwavemesh.Scale = shockwavemesh.Scale + Vector3.new(6,1,6)
end
end)()
coroutine.wrap(function()
for i = 1, 10 do
swait()
biggrassblock.CFrame = biggrassblock.CFrame * CFrame.new(0,2.7,0)
end
end)()
groundrum = Instance.new("Sound",biggrassblock)
groundrum.SoundId = "rbxassetid://1265219916"
groundrum.Volume = 10
groundrum.Pitch = 1.5
groundrum:Play()
Hit = damagealll(30,biggrassblock.Position)
for _,v in pairs(Hit) do
if browntotem then

elseif avatarstate then

else

end
vel = Instance.new("BodyVelocity",v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")) 
vel.maxForce = Vector3.new(9999999999999,9999999999999,9999999999999)
torso = v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
vel.velocity = CFrame.new(biggrassblock.Position,torso.Position).lookVector*180
removeuseless:AddItem(vel,.1)
end
end
if avatarstate then
for i = 1, 7 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.2)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(20),math.rad(20),math.rad(0)),.8)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.3,1,.35) * CFrame.Angles(math.rad(-110),math.rad(12),math.rad(-1)),.8)
swait()
end
else
for i = 1, 15 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.1)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(20),math.rad(20),math.rad(0)),.4)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.3,1,.35) * CFrame.Angles(math.rad(-110),math.rad(12),math.rad(-1)),.4)
swait()
end
end
ws = 90
attacking = false
debounce = false
appi = false
removeuseless:AddItem(g1,.001)
elseif throw2 then
if debounce then return end
throw1 = true
throw2 = false
debounce = true
attacking = true
appi = true
ws = 12
g1 = Instance.new("BodyGyro", Root)
g1.D = 175
g1.P = 20000
g1.MaxTorque = Vector3.new(0,9000,0)
coroutine.wrap(function()
while appi do
swait()
if Root.Velocity.Magnitude > 2 and attacking == true then
position = "Idle3"
end
end
end)()
coroutine.wrap(function()
while appi do
swait()
settime = 0.05
sine = sine + change
if position == "Idle3" and attacking == true and appi == true then
change = .5
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(50 + 3 * math.sin(sine/12)),math.rad(3 - 1 * math.sin(sine/12))),.5)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 2 + .02 * math.sin(sine/12), 0.2 + .1 * math.sin(sine/12)) * CFrame.Angles(math.rad(25 + 5 * math.sin(sine/12)), math.rad(-20), math.rad(0)), 0.5)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.54, 2 + .02 * math.sin(sine/12), 0.2 + .1 * math.sin(sine/12)) * CFrame.Angles(math.rad(25 + 5 * math.sin(sine/12)), math.rad(20), math.rad(0)), 0.5)
end
end
end)()
if avatarstate then
for i = 1, 5 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.4)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(-20),math.rad(20),math.rad(0)),.8)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.3,0,.2) * CFrame.Angles(math.rad(30),math.rad(-30),0),.8)
swait()
end
else
for i = 1, 15 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.1)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(-20),math.rad(20),math.rad(0)),.4)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.3,0,.2) * CFrame.Angles(math.rad(30),math.rad(-30),0),.4)
swait()
end
end
if mouse.Target ~= nil then
biggrassblock = Instance.new("Part",Torso)
biggrassblock.Size = Vector3.new(math.random(15,18),50,math.random(15,18))
biggrassblock.Anchored = true
biggrassblock.CFrame = CFrame.new(mouse.Hit.p) * CFrame.new(0,-10,0) * CFrame.Angles(math.rad(math.random(-15,15)),math.rad(math.random(-15,15)),math.rad(math.random(-15,15)))
biggrassblock.CanCollide = true
biggrassblock.Material = "Slate"
biggrassblock.BrickColor = BrickColor.new("Earth green")
removeuseless:AddItem(biggrassblock,10)
locbrick = Instance.new("Part",biggrassblock)
locbrick.Size = Vector3.new(1,1,1)
locbrick.Transparency = 1
locbrick.CFrame = CFrame.new(mouse.Hit.p)
locbrick.CanCollide = false
locbrick.Anchored = true
shockwave = Instance.new("Part", Torso)
shockwave.Size = Vector3.new(1,1,1)
shockwave.CanCollide = false
shockwave.Anchored = true
shockwave.Transparency = .5
shockwave.BrickColor = BrickColor.new("White")
shockwave.CFrame = CFrame.new(locbrick.Position)
shockwavemesh = Instance.new("SpecialMesh", shockwave)
shockwavemesh.Scale = Vector3.new(7,3,7)
shockwavemesh.MeshId = "rbxassetid://20329976"
shockwave2 = Instance.new("Part", Torso)
shockwave2.Size = Vector3.new(1,1,1)
shockwave2.CanCollide = false
shockwave2.Anchored = true
shockwave2.Transparency = .5
shockwave2.BrickColor = BrickColor.new("White")
shockwave2.CFrame = CFrame.new(locbrick.Position)
shockwavemesh2 = Instance.new("SpecialMesh", shockwave2)
shockwavemesh2.Scale = Vector3.new(5,3,5)
shockwavemesh2.MeshId = "rbxassetid://20329976"
locbrick2 = Instance.new("Part",biggrassblock)
locbrick2.Size = Vector3.new(1,1,1)
locbrick2.Transparency = 1
locbrick2.CFrame = CFrame.new(mouse.Hit.p)
locbrick2.CanCollide = false
locbrick2weld = weldBetween(locbrick2,locbrick)
zxp = 0
for i = 1, 75 do
zxp = zxp + 5
crater = Instance.new("Part",Torso)
crater.BrickColor = biggrassblock.BrickColor
crater.Size = Vector3.new(5,5,5)
crater.Transparency = 1
craterweld = weldBetween(crater,locbrick2)
craterweld.C0 = craterweld.C0 * CFrame.new(15,0,0) * CFrame.Angles(math.rad(0),math.rad(zxp),math.rad(0))
removeuseless:AddItem(crater,1)
crater2 = Instance.new("Part",Torso)
crater2.CFrame = crater.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
crater2.Size = Vector3.new(13,13,13)
crater2.Anchored = true
crater2.Material = "Grass"
crater2.BrickColor = BrickColor.new("Bright green")
removeuseless:AddItem(crater2,15)
end
coroutine.wrap(function()
for i = 1, 30 do
swait()
shockwave.CFrame = shockwave.CFrame * CFrame.Angles(math.rad(0),math.rad(0+15),0)
shockwave2.CFrame = shockwave2.CFrame * CFrame.Angles(math.rad(0),math.rad(0-8),0)
shockwave.Transparency = shockwave.Transparency + 0.025
shockwave2.Transparency = shockwave2.Transparency + 0.025
shockwavemesh2.Scale = shockwavemesh2.Scale + Vector3.new(6,1,6)
shockwavemesh.Scale = shockwavemesh.Scale + Vector3.new(6,1,6)
end
end)()
coroutine.wrap(function()
for i = 1, 10 do
swait()
biggrassblock.CFrame = biggrassblock.CFrame * CFrame.new(0,2.7,0)
end
end)()
groundrum = Instance.new("Sound",biggrassblock)
groundrum.SoundId = "rbxassetid://1265219916"
groundrum.Volume = 10
groundrum.Pitch = 1.5
groundrum:Play()
Hit = damagealll(30,biggrassblock.Position)
for _,v in pairs(Hit) do
if browntotem then

elseif avatarstate then

else

end
vel = Instance.new("BodyVelocity",v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")) 
vel.maxForce = Vector3.new(9999999999999,9999999999999,9999999999999)
torso = v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
vel.velocity = CFrame.new(biggrassblock.Position,torso.Position).lookVector*150
removeuseless:AddItem(vel,.1)
end
end
if avatarstate then
for i = 1, 7 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.2)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(20),math.rad(-20),math.rad(0)),.8)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.3,1,.35) * CFrame.Angles(math.rad(-110),math.rad(-12),math.rad(1)),.8)
swait()
end
else
for i = 1, 15 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.1)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(20),math.rad(-20),math.rad(0)),.4)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.3,1,.35) * CFrame.Angles(math.rad(-110),math.rad(-12),math.rad(1)),.4)
swait()
end
end
ws = 90
attacking = false
debounce = false
appi = false
removeuseless:AddItem(g1,.001)
end
end
end)

particlecolor = ColorSequence.new(Color3.new(0, 5, 255))

particlemiter1 = Instance.new("ParticleEmitter", LeftArm)
particlemiter1.Enabled = false
particlemiter1.Color = particlecolor
particlemiter1.Texture = "rbxassetid://304437537"
particlemiter1.Lifetime = NumberRange.new(2.5)
particlemiter1.Size = NumberSequence.new(1,0)
particlemiter1.Rate = 25
particlemiter1.RotSpeed = NumberRange.new(70)
particlemiter1.Speed = NumberRange.new(0)
particlemiter2 = Instance.new("ParticleEmitter", RightArm)
particlemiter2.Enabled = false
particlemiter2.Color = particlecolor
particlemiter2.Texture = "rbxassetid://304437537"
particlemiter2.Lifetime = NumberRange.new(2.5)
particlemiter2.Size = NumberSequence.new(1,0)
particlemiter2.Rate = 25
particlemiter2.RotSpeed = NumberRange.new(70)
particlemiter2.Speed = NumberRange.new(0)
particlemiter4 = Instance.new("ParticleEmitter", LeftLeg)
particlemiter4.Enabled = false
particlemiter4.Color = particlecolor
particlemiter4.Texture = "rbxassetid://304437537"
particlemiter4.Lifetime = NumberRange.new(2.5)
particlemiter4.Size = NumberSequence.new(1,0)
particlemiter4.Rate = 25
particlemiter4.RotSpeed = NumberRange.new(70)
particlemiter4.Speed = NumberRange.new(0)
particlemiter5 = Instance.new("ParticleEmitter", RightLeg)
particlemiter5.Enabled = false
particlemiter5.Color = particlecolor
particlemiter5.Texture = "rbxassetid://304437537"
particlemiter5.Lifetime = NumberRange.new(2.5)
particlemiter5.Size = NumberSequence.new(1,0)
particlemiter5.Rate = 25
particlemiter5.RotSpeed = NumberRange.new(70)
particlemiter5.Speed = NumberRange.new(0)
particlemiter6 = Instance.new("ParticleEmitter", Torso)
particlemiter6.Enabled = false
particlemiter6.Color = particlecolor
particlemiter6.Texture = "rbxassetid://304437537"
particlemiter6.Lifetime = NumberRange.new(2.5)
particlemiter6.Size = NumberSequence.new(1,0)
particlemiter6.Rate = 25
particlemiter6.RotSpeed = NumberRange.new(70)
particlemiter6.Speed = NumberRange.new(0)
particlemiter7 = Instance.new("ParticleEmitter", Head)
particlemiter7.Enabled = false
particlemiter7.Color = particlecolor
particlemiter7.Texture = "rbxassetid://304437537"
particlemiter7.Lifetime = NumberRange.new(2.5)
particlemiter7.Size = NumberSequence.new(1,0)
particlemiter7.Rate = 25
particlemiter7.RotSpeed = NumberRange.new(70)
particlemiter7.Speed = NumberRange.new(0)

coroutine.wrap(function()
while wait() do
pcall(function()
particlemiter1.Color = particlecolor
particlemiter2.Color = particlecolor
particlemiter4.Color = particlecolor
particlemiter5.Color = particlecolor
particlemiter6.Color = particlecolor
particlemiter7.Color = particlecolor
end)
end
end)()

checks1 = coroutine.wrap(function() -------Checks
while true do
if Root.Velocity.Magnitude < 15 and running == false then
position = "Idle"
elseif Root.Velocity.Magnitude > 15 and running == false then
position = "Walking"
else
end
wait()
end
end)
checks1()

function ray(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function ray2(StartPos, EndPos, Distance, Ignore)
local DIRECTION = CFrame.new(StartPos,EndPos).lookVector
return ray(StartPos, DIRECTION, Distance, Ignore)
end

leftlocation = Instance.new("Part",LeftArm)
leftlocation.Size = Vector3.new(1,1,1)
leftlocation.Transparency = 1
leftlocationweld = weldBetween(leftlocation,LeftArm)
leftlocationweld.C0 = CFrame.new(0,1.2,0)
rightlocation = Instance.new("Part",RightArm)
rightlocation.Size = Vector3.new(1,1,1)
rightlocation.Transparency = 1
rightlocationweld = weldBetween(rightlocation,RightArm)
rightlocationweld.C0 = CFrame.new(0,1.2,0)

windblocks = Instance.new("Part",Torso)
windblocks.Size = Vector3.new(1,1,1)
windblocks.Transparency = 1
windblocks.Anchored = false
windblocks.CanCollide = false
windblocksweld = weldBetween(windblocks,Root)

windblocks2 = Instance.new("Part",Torso)
windblocks2.Size = Vector3.new(1,1,1)
windblocks2.Transparency = 1
windblocks2.Anchored = false
windblocks2.CanCollide = false
windblocks2weld = weldBetween(windblocks2,Root)

windring = Instance.new("Part", Torso)
windring.Size = Vector3.new(1, 1, 1)
windring.Transparency = .8
windring.Anchored = false
windring.BrickColor = BrickColor.new("Really white")
windring.CanCollide = false
ringh = Instance.new("SpecialMesh", windring) 
ringh.MeshId = "http://www.roblox.com/asset/?id=3270017" 
ringh.Scale = Vector3.new(19, 19, 4)
windringweld = weldBetween(windring,windblocks)
windring2 = Instance.new("Part", Torso)
windring2.Size = Vector3.new(1, 1, 1)
windring2.Transparency = .8
windring2.Anchored = false
windring2.BrickColor = BrickColor.new("Really white")
windring2.CanCollide = false
ringh2 = Instance.new("SpecialMesh", windring2) 
ringh2.MeshId = "http://www.roblox.com/asset/?id=3270017" 
ringh2.Scale = Vector3.new(19, 19, 4)
windring2weld = weldBetween(windring2,windblocks2)
wind = Instance.new("Part", Torso)
wind.Size = Vector3.new(0.5, 0.5, 0.5)
wind.Material = "Neon"
wind.BrickColor = BrickColor.new("Really white")
wind.Transparency = .76
wind.CanCollide = false
windMESH = Instance.new("SpecialMesh", wind)
windMESH.Scale = Vector3.new(3.5,3.5,3.5)
windMESH.MeshId = "rbxassetid://168892432"
windWeld = weldBetween(wind,Root)
windWeld.C0 = CFrame.new(0,-10,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
wind2 = Instance.new("Part", Torso)
wind2.Size = Vector3.new(0.5, 0.5, 0.5)
wind2.Material = "Neon"
wind2.BrickColor = BrickColor.new("Really white")
wind2.Transparency = .95
wind2.CanCollide = false
windMESH2 = Instance.new("SpecialMesh", wind2)
windMESH2.Scale = Vector3.new(6,6,6)
windMESH2.MeshId = "rbxassetid://168892432"
windWeld2 = weldBetween(wind2,Root)
windWeld2.C0 = CFrame.new(0,-10,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))

grasslocation = Instance.new("Part",Torso)
grasslocation.CFrame = Root.CFrame
grasslocation.Size = Vector3.new(1,1,1)
grasslocation.Transparency = 1
grasslocation.CanCollide = false
grasslocationweld = weldBetween(grasslocation,Root)
grasslocationweld.C0 = CFrame.Angles(math.rad(10),math.rad(10),0)
waterlocation = Instance.new("Part",Torso)
waterlocation.CFrame = Root.CFrame
waterlocation.Size = Vector3.new(1,1,1)
waterlocation.Transparency = 1
waterlocation.CanCollide = false
waterlocationweld = weldBetween(waterlocation,Root)
waterlocationweld.C0 = CFrame.Angles(math.rad(10),math.rad(10),0)
zp = 0
for i = 1, 14 do
zp = zp + 26
grassblocks = Instance.new("Part",Torso)
grassblocks.Size = Vector3.new(1.3,1.3,1.3)
grassblocks.Material = "Slate"
grassblocks.CanCollide = false
grassblocks.BrickColor = BrickColor.new("Earth green")
grassblocksweld = weldBetween(grassblocks,grasslocation)
grassblocksweld.C0 = CFrame.new(-7.5,0,0) * CFrame.Angles(math.rad(0),math.rad(zp),math.rad(0))
table.insert(grasstable,grassblocksweld)
end
for i = 1, 14 do
zp = zp + 26.1
waterblocks = Instance.new("Part",Torso)
waterblocks.Size = Vector3.new(1.3,1.3,1.3)
waterblocks.Material = "Neon"
waterblocks.CanCollide = false
waterblocks.Transparency = .5
waterblocks.BrickColor = BrickColor.new("Cyan")
waterblocksweld = weldBetween(waterblocks,waterlocation)
waterblocksweld.C0 = CFrame.new(-7.6,0,0) * CFrame.Angles(math.rad(0),math.rad(zp),math.rad(0))
table.insert(watertable,waterwblocks)
end

locbrick1 = Instance.new("Part",Torso)
locbrick1.Size = Vector3.new(1,1,1)
locbrick1.CanCollide = false
locbrick1.Transparency = 1
locbrick1weld = weldBetween(locbrick1,Root)
locbrick1weld.C0 = CFrame.new(0,9.5,0)

levitatewave = Instance.new("Part", Torso)
levitatewave.Size = Vector3.new(1,1,1)
levitatewave.CanCollide = false
levitatewave.Anchored = false
levitatewave.Transparency = .75
levitatewave.BrickColor = BrickColor.new("White")
levitatewave.CFrame = CFrame.new(Root.Position) * CFrame.new(0,-5,0)
levitatewavemesh = Instance.new("SpecialMesh", levitatewave)
levitatewavemesh.Scale = Vector3.new(7,1.25,7)
levitatewavemesh.MeshId = "rbxassetid://20329976"
levitatewaveweld = weldBetween(levitatewave,locbrick1)
levitatewave2 = Instance.new("Part", Torso)
levitatewave2.Size = Vector3.new(1,1,1)
levitatewave2.CanCollide = false
levitatewave2.Anchored = false
levitatewave2.Transparency = .75
levitatewave2.BrickColor = BrickColor.new("White")
levitatewave2.CFrame = CFrame.new(Root.Position) * CFrame.new(0,-5,0)
levitatewavemesh2 = Instance.new("SpecialMesh", levitatewave2)
levitatewavemesh2.Scale = Vector3.new(5.5,1,5.5)
levitatewavemesh2.MeshId = "rbxassetid://20329976"
levitatewaveweld2 = weldBetween(levitatewave2,locbrick1)

coroutine.wrap(function()
po = 0
xo = 0 
to = 0
to2 = 0
lo = 0
mo = 0
while true do 
swait()
colors = colortable[math.random(1,#colortable)]
to2 = to2 - 7
to = to + 14
po = po + 8
lo = lo - 8
xo = xo - 5
mo = mo + 5
hpheight = 6 + 1 * math.sin(sine/12)
windblocksweld.C0 = CFrame.Angles(math.rad(xo),math.rad(po),0)
windblocks2weld.C0 = CFrame.Angles(math.rad(lo),math.rad(mo),0)
if allowlev then
locbrick1weld.C0 = CFrame.new(0,8.7 + .7 * math.sin(sine/12),0)
end
levitatewaveweld2.C0 = CFrame.Angles(math.rad(0),math.rad(to),0)
levitatewaveweld.C0 = CFrame.Angles(math.rad(0),math.rad(-to),0)
if avatarstate then
windWeld4.C0 = CFrame.Angles(math.rad(0),math.rad(to),math.rad(0))
windWeld3.C0 = CFrame.Angles(math.rad(0),math.rad(to2),math.rad(0))
windblocks3weld.C0 = CFrame.Angles(math.rad(xo),math.rad(po),0)
windblocks4weld.C0 = CFrame.Angles(math.rad(lo),math.rad(mo),0)
levitatewaveweld3.C0 = CFrame.Angles(math.rad(0),math.rad(to),0)
levitatewaveweld4.C0 = CFrame.Angles(math.rad(0),math.rad(-to),0)
levitatewaveweld5.C0 = CFrame.Angles(math.rad(0),math.rad(to),0)
levitatewaveweld6.C0 = CFrame.Angles(math.rad(0),math.rad(-to),0)
end
waterlocationweld.C0 = CFrame.Angles(math.rad(0 * math.sin(sine/12)),math.rad(-to/6),math.rad(-40 * math.sin(sine/12)))
grasslocationweld.C0 = CFrame.Angles(math.rad(0 * math.sin(sine/12)),math.rad(to/6),math.rad(40 * math.sin(sine/12)))
windWeld.C0 = CFrame.Angles(math.rad(0),math.rad(to),math.rad(0))
windWeld2.C0 = CFrame.Angles(math.rad(0),math.rad(to2),math.rad(0))
end
end)()

OrgnC0 = Neck.C0
local movelimbs = coroutine.wrap(function()
while RunSrv.RenderStepped:wait() do
TrsoLV = Torso.CFrame.lookVector
Dist = nil
Diff = nil
if not MseGuide then
print("Failed to recognize")
else
local _, Point = Workspace:FindPartOnRay(Ray.new(Head.CFrame.p, mouse.Hit.lookVector), Workspace, false, true)
Dist = (Head.CFrame.p-Point).magnitude
Diff = Head.CFrame.Y-Point.Y
local _, Point2 = Workspace:FindPartOnRay(Ray.new(LeftArm.CFrame.p, mouse.Hit.lookVector), Workspace, false, true)
Dist2 = (LeftArm.CFrame.p-Point).magnitude
Diff2 = LeftArm.CFrame.Y-Point.Y
HEADLERP.C0 = CFrame.new(0, -1.5, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))
Neck.C0 = Neck.C0:lerp(OrgnC0*CFrame.Angles((math.tan(Diff/Dist)*1), 0, (((Head.CFrame.p-Point).Unit):Cross(Torso.CFrame.lookVector)).Y*1), .1)
end
end
end)
movelimbs()
immortal = {}
for i,v in pairs(Character:GetDescendants()) do
	if v:IsA("BasePart") and v.Name ~= "lmagic" and v.Name ~= "rmagic" then
		if v ~= Root and v ~= Torso and v ~= Head and v ~= RightArm and v ~= LeftArm and v ~= RightLeg and v.Name ~= "lmagic" and v.Name ~= "rmagic" and v ~= LeftLeg then
			v.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
		end
		table.insert(immortal,{v,v.Parent,v.Material,v.Color,v.Transparency})
	elseif v:IsA("JointInstance") then
		table.insert(immortal,{v,v.Parent,nil,nil,nil})
	end
end
for e = 1, #immortal do
	if immortal[e] ~= nil then
		local STUFF = immortal[e]
		local PART = STUFF[1]
		local PARENT = STUFF[2]
		local MATERIAL = STUFF[3]
		local COLOR = STUFF[4]
		local TRANSPARENCY = STUFF[5]
if levitate then
		if PART.ClassName == "Part" and PART ~= Root and PART.Name ~= eyo1 and PART.Name ~= eyo2 and PART.Name ~= "lmagic" and PART.Name ~= "rmagic" then
			PART.Material = MATERIAL
			PART.Color = COLOR
			PART.Transparency = TRANSPARENCY
		end
		PART.AncestryChanged:connect(function()
			PART.Parent = PARENT
		end)
else
		if PART.ClassName == "Part" and PART ~= Root and PART.Name ~= "lmagic" and PART.Name ~= "rmagic" then
			PART.Material = MATERIAL
			PART.Color = COLOR
			PART.Transparency = TRANSPARENCY
		end
		PART.AncestryChanged:connect(function()
			PART.Parent = PARENT
		end)
end
	end
end
function immortality()
	for e = 1, #immortal do
		if immortal[e] ~= nil then
			local STUFF = immortal[e]
			local PART = STUFF[1]
			local PARENT = STUFF[2]
			local MATERIAL = STUFF[3]
			local COLOR = STUFF[4]
			local TRANSPARENCY = STUFF[5]
			if PART.ClassName == "Part" and PART == Root then
				PART.Material = MATERIAL
				PART.Color = COLOR
				PART.Transparency = TRANSPARENCY
			end
			if PART.Parent ~= PARENT then
				hum:Remove()
				PART.Parent = PARENT
				hum = Instance.new("Humanoid",Character)
if levitate then
eyo1:Remove()
eyo2:Remove()
end
                                hum.Name = "noneofurbusiness"
			end
		end
	end
end
coroutine.wrap(function()
while true do
if hum.Health < .1 then
deadsound = Instance.new("Sound", Torso)
deadsound.Volume = 6
deadsound.SoundId = "rbxassetid://1411352723"
deadsound:Play()
immortality()
end
wait()
end
end)()

local anims = coroutine.wrap(function()
while true do
settime = 0.05
sine = sine + change
if position == "Walking" and attacking == false and running == false then
change = .5
walking = true
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.25)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.25)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.6, 0.5 - .1 * -math.sin(sine/12), 0) * CFrame.Angles(math.rad(35 - 2 * math.sin(sine/12)), math.rad(0), math.rad(25 + 5 * math.sin(sine/12))), 0.25)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.6, 0.5 - .1 * -math.sin(sine/12), 0) * CFrame.Angles(math.rad(35 - 2 * math.sin(sine/12)), math.rad(0), math.rad(-25 - 5 * math.sin(sine/12))), 0.25)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-41 - 1 * math.sin(sine/9)), math.rad(0 + 0 * math.cos(sine/8)), math.rad(0) + Root.RotVelocity.Y / 15, math.cos(10 * math.cos(sine/10))), 0.25)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 2 + .02 * math.sin(sine/12), 0.2 + .1 * math.sin(sine/12)) * CFrame.Angles(math.rad(25 + 5 * math.sin(sine/12)), math.rad(-20), math.rad(0)), 0.25)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.54, 2 + .02 * math.sin(sine/12), 0.2 + .1 * math.sin(sine/12)) * CFrame.Angles(math.rad(25 + 5 * math.sin(sine/12)), math.rad(20), math.rad(0)), 0.25)
elseif position == "Idle" and attacking == false and running == false then
change = .5
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(10*math.sin(sine/12)),math.rad(0),math.rad(0)),.2)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(50 + 3 * math.sin(sine/12)),math.rad(3 - 1 * math.sin(sine/12))),.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(-50 - 3 * math.sin(sine/12)),math.rad(-3 + 1 * math.sin(sine/12))), .2)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 2 + .02 * math.sin(sine/12), 0.2 + .1 * math.sin(sine/12)) * CFrame.Angles(math.rad(25 + 5 * math.sin(sine/12)), math.rad(-20), math.rad(0)), 0.2)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.54, 2 + .02 * math.sin(sine/12), 0.2 + .1 * math.sin(sine/12)) * CFrame.Angles(math.rad(25 + 5 * math.sin(sine/12)), math.rad(20), math.rad(0)), 0.2)
end
swait()
end
end)
anims()
warn("Four elements combined to make one, powerful force. Made by Supr14")
        else
            game.StarterGui:SetCore("ChatMakeSystemMessage", {
                Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
                Color = Color3.fromRGB(255, 0, 0),
                TextSize = 20,
                Font = Enum.Font.Cartoon
            });
        end
end)

frees:Button("Eerin", "funny button go brr", function()
            if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
            local script = game:GetObjects("rbxassetid://6254124032")[1]
            wait(0.2)
            Player = game:GetService("Players").LocalPlayer
            PlayerGui = Player.PlayerGui
            Cam = workspace.CurrentCamera
            Backpack = Player.Backpack
            Character = Player.Character.Raw
            Humanoid = Character.Humanoid
            local Mouse = Player:GetMouse()
            RootPart = Character.HumanoidRootPart
            Torso = Character.Torso
            Head = Character.Head
            RightArm = Character["Right Arm"]
            LeftArm = Character["Left Arm"]
            RightLeg = Character["Right Leg"]
            LeftLeg = Character["Left Leg"]
            RootJoint = RootPart.RootJoint
            Neck = Torso.Neck
            RightShoulder = Torso["Right Shoulder"]
            LeftShoulder = Torso["Left Shoulder"]
            RightHip = Torso["Right Hip"]
            LeftHip = Torso["Left Hip"]
            IT = Instance.new
            CF = CFrame.new
            VT = Vector3.new
            RAD = math.rad
            C3 = Color3.new
            UD2 = UDim2.new
            BRICKC = BrickColor.new
            ANGLES = CFrame.Angles
            EULER = CFrame.fromEulerAnglesXYZ
            COS = math.cos
            ACOS = math.acos
            SIN = math.sin
            ASIN = math.asin
            ABS = math.abs
            MRANDOM = math.random
            FLOOR = math.floor
            Animation_Speed = 3
            Frame_Speed = 0.016666666666666666
            local Speed = 16
            local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
            local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
            local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
            local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
            local DAMAGEMULTIPLIER = 1
            local ANIM = "Idle"
            local ATTACK = false
            local EQUIPPED = false
            local HOLD = false
            local COMBO = 1
            local Rooted = false
            local SINE = 0
            local KEYHOLD = false
            local CHANGE = 2 / Animation_Speed
            local WALKINGANIM = false
            local VALUE1 = false
            local VALUE2 = false
            local ROBLOXIDLEANIMATION = IT("Animation")
            ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
            ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
            local WEAPONGUI = IT("ScreenGui", PlayerGui)
            WEAPONGUI.Name = "Weapon GUI"
            local Effects = IT("Folder", Character)
            Effects.Name = "Effects"
            local ANIMATOR = Humanoid.Animator
            ANIMATOR:Destroy()
            local ANIMATE = Character.Animate
            local UNANCHOR = true
            local HEADTURN = true
            ArtificialHB = Instance.new("BindableEvent", script)
            ArtificialHB.Name = "ArtificialHB"
            script:WaitForChild("ArtificialHB")
            frame = Frame_Speed
            tf = 0
            allowframeloss = false
            tossremainder = false
            lastframe = tick()
            script.ArtificialHB:Fire()
            game:GetService("RunService").Heartbeat:connect(function(s, p)
                tf = tf + s
                if tf >= frame then
                    if allowframeloss then
                        ArtificialHB:Fire()
                        lastframe = tick()
                    else
                        for i = 1, math.floor(tf / frame) do
                            ArtificialHB:Fire()
                        end
                        lastframe = tick()
                    end
                    if tossremainder then
                        tf = 0
                    else
                        tf = tf - frame * math.floor(tf / frame)
                    end
                end
            end)
            function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
                return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
            end
            function PositiveAngle(NUMBER)
                if NUMBER >= 0 then
                    NUMBER = 0
                end
                return NUMBER
            end
            function NegativeAngle(NUMBER)
                if NUMBER <= 0 then
                    NUMBER = 0
                end
                return NUMBER
            end
            function Swait(NUMBER)
                if NUMBER == 0 or NUMBER == nil then
                    ArtificialHB.Event:wait()
                else
                    for i = 1, NUMBER do
                        ArtificialHB.Event:wait()
                    end
                end
            end
            function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
                local NEWMESH = IT(MESH)
                if MESH == "SpecialMesh" then
                    NEWMESH.MeshType = MESHTYPE
                    if MESHID ~= "nil" and MESHID ~= "" then
                        NEWMESH.MeshId = "http://www.roblox.com/asset/?id=" .. MESHID
                    end
                    if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
                        NEWMESH.TextureId = "http://www.roblox.com/asset/?id=" .. TEXTUREID
                    end
                end
                NEWMESH.Offset = OFFSET or VT(0, 0, 0)
                NEWMESH.Scale = SCALE
                NEWMESH.Parent = PARENT
                return NEWMESH
            end
            function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
                local NEWPART = IT("Part")
                NEWPART.formFactor = FORMFACTOR
                NEWPART.Reflectance = REFLECTANCE
                NEWPART.Transparency = TRANSPARENCY
                NEWPART.CanCollide = false
                NEWPART.Locked = true
                NEWPART.Anchored = true
                if ANCHOR == false then
                    NEWPART.Anchored = false
                end
                NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
                NEWPART.Name = NAME
                NEWPART.Size = SIZE
                NEWPART.Position = Torso.Position
                NEWPART.Material = MATERIAL
                NEWPART:BreakJoints()
                NEWPART.Parent = PARENT
                return NEWPART
            end
            local weldBetween = function(a, b)
                local weldd = Instance.new("ManualWeld")
                weldd.Part0 = a
                weldd.Part1 = b
                weldd.C0 = CFrame.new()
                weldd.C1 = b.CFrame:inverse() * a.CFrame
                weldd.Parent = a
                return weldd
            end
            function QuaternionFromCFrame(cf)
                local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
                local trace = m00 + m11 + m22
                if trace > 0 then
                    local s = math.sqrt(1 + trace)
                    local recip = 0.5 / s
                    return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
                else
                    local i = 0
                    if m00 < m11 then
                        i = 1
                    end
                    if m22 > (i == 0 and m00 or m11) then
                        i = 2
                    end
                    if i == 0 then
                        local s = math.sqrt(m00 - m11 - m22 + 1)
                        local recip = 0.5 / s
                        return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
                    elseif i == 1 then
                        local s = math.sqrt(m11 - m22 - m00 + 1)
                        local recip = 0.5 / s
                        return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
                    elseif i == 2 then
                        local s = math.sqrt(m22 - m00 - m11 + 1)
                        local recip = 0.5 / s
                        return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
                    end
                end
            end
            function QuaternionToCFrame(px, py, pz, x, y, z, w)
                local xs, ys, zs = x + x, y + y, z + z
                local wx, wy, wz = w * xs, w * ys, w * zs
                local xx = x * xs
                local xy = x * ys
                local xz = x * zs
                local yy = y * ys
                local yz = y * zs
                local zz = z * zs
                return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
            end
            function QuaternionSlerp(a, b, t)
                local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
                local startInterp, finishInterp
                if cosTheta >= 1.0E-4 then
                    if 1 - cosTheta > 1.0E-4 then
                        local theta = ACOS(cosTheta)
                        local invSinTheta = 1 / SIN(theta)
                        startInterp = SIN((1 - t) * theta) * invSinTheta
                        finishInterp = SIN(t * theta) * invSinTheta
                    else
                        startInterp = 1 - t
                        finishInterp = t
                    end
                elseif 1 + cosTheta > 1.0E-4 then
                    local theta = ACOS(-cosTheta)
                    local invSinTheta = 1 / SIN(theta)
                    startInterp = SIN((t - 1) * theta) * invSinTheta
                    finishInterp = SIN(t * theta) * invSinTheta
                else
                    startInterp = t - 1
                    finishInterp = t
                end
                return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
            end
            function Clerp(a, b, t)
                local qa = {
                    QuaternionFromCFrame(a)
                }
                local qb = {
                    QuaternionFromCFrame(b)
                }
                local ax, ay, az = a.x, a.y, a.z
                local bx, by, bz = b.x, b.y, b.z
                local _t = 1 - t
                return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
            end
            function CreateFrame(PARENT, TRANSPARENCY, BORDERSIZEPIXEL, POSITION, SIZE, COLOR, BORDERCOLOR, NAME)
                local frame = IT("Frame")
                frame.BackgroundTransparency = TRANSPARENCY
                frame.BorderSizePixel = BORDERSIZEPIXEL
                frame.Position = POSITION
                frame.Size = SIZE
                frame.BackgroundColor3 = COLOR
                frame.BorderColor3 = BORDERCOLOR
                frame.Name = NAME
                frame.Parent = PARENT
                return frame
            end
            function CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)
                local label = IT("TextLabel")
                label.BackgroundTransparency = 1
                label.Size = UD2(1, 0, 1, 0)
                label.Position = UD2(0, 0, 0, 0)
                label.TextColor3 = TEXTCOLOR
                label.TextStrokeTransparency = STROKETRANSPARENCY
                label.TextTransparency = TRANSPARENCY
                label.FontSize = TEXTFONTSIZE
                label.Font = TEXTFONT
                label.BorderSizePixel = BORDERSIZEPIXEL
                label.TextScaled = false
                label.Text = TEXT
                label.Name = NAME
                label.Parent = PARENT
                return label
            end
            function NoOutlines(PART)
                PART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10
            end
            function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
                local NEWWELD = IT(TYPE)
                NEWWELD.Part0 = PART0
                NEWWELD.Part1 = PART1
                NEWWELD.C0 = C0
                NEWWELD.C1 = C1
                NEWWELD.Parent = PARENT
                return NEWWELD
            end
            local S = IT("Sound")
            function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
                local NEWSOUND
                coroutine.resume(coroutine.create(function()
                    NEWSOUND = S:Clone()
                    NEWSOUND.Parent = PARENT
                    NEWSOUND.Volume = VOLUME
                    NEWSOUND.Pitch = PITCH
                    NEWSOUND.SoundId = "rbxassetid://" .. ID
                    NEWSOUND:play()
                    NEWSOUND.EmitterSize = VOLUME * 3
                    if DOESLOOP == true then
                        NEWSOUND.Looped = true
                    else
                        repeat
                            wait(1)
                        until NEWSOUND.Playing == false
                        NEWSOUND:remove()
                    end
                end))
                return NEWSOUND
            end
            function CFrameFromTopBack(at, top, back)
                local right = top:Cross(back)
                return CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
            end
            function WACKYEFFECT(Table)
                local TYPE = Table.EffectType or "Sphere"
                local SIZE = Table.Size or VT(1, 1, 1)
                local ENDSIZE = Table.Size2 or VT(0, 0, 0)
                local TRANSPARENCY = Table.Transparency or 0
                local ENDTRANSPARENCY = Table.Transparency2 or 1
                local CFRAME = Table.CFrame or Torso.CFrame
                local MOVEDIRECTION = Table.MoveToPos or nil
                local ROTATION1 = Table.RotationX or 0
                local ROTATION2 = Table.RotationY or 0
                local ROTATION3 = Table.RotationZ or 0
                local MATERIAL = Table.Material or "Neon"
                local COLOR = Table.Color or C3(1, 1, 1)
                local TIME = Table.Time or 45
                local SOUNDID = Table.SoundID or nil
                local SOUNDPITCH = Table.SoundPitch or nil
                local SOUNDVOLUME = Table.SoundVolume or nil
                local USEBOOMERANGMATH = Table.UseBoomerangMath or false
                local BOOMERANG = Table.Boomerang or 0
                local SIZEBOOMERANG = Table.SizeBoomerang or 0
                coroutine.resume(coroutine.create(function()
                    local PLAYSSOUND = false
                    local SOUND
                    local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1, 1, 1), true)
                    if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
                        PLAYSSOUND = true
                        SOUND = CreateSound(SOUNDID, nil, SOUNDVOLUME, SOUNDPITCH, false)
                    end
                    EFFECT.Color = COLOR
                    local MSH
                    if TYPE == "Sphere" then
                        MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0, 0, 0))
                    elseif TYPE == "Block" or TYPE == "Box" then
                        MSH = IT("BlockMesh", EFFECT)
                        MSH.Scale = SIZE
                    elseif TYPE == "Wave" then
                        MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0, 0, -SIZE.X / 8))
                    elseif TYPE == "Ring" then
                        MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X, SIZE.X, 0.1), VT(0, 0, 0))
                    elseif TYPE == "Slash" then
                        MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X / 10, 0, SIZE.X / 10), VT(0, 0, 0))
                    elseif TYPE == "Round Slash" then
                        MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X / 10, 0, SIZE.X / 10), VT(0, 0, 0))
                    elseif TYPE == "Swirl" then
                        MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "168892432", "", SIZE, VT(0, 0, 0))
                    elseif TYPE == "Skull" then
                        MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0, 0, 0))
                    elseif TYPE == "Crystal" then
                        MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0, 0, 0))
                    end
                    if MSH ~= nil then
                        local BOOMR1 = 1 + BOOMERANG / 50
                        local BOOMR2 = 1 + SIZEBOOMERANG / 50
                        local MOVESPEED
                        if MOVEDIRECTION ~= nil then
                            if USEBOOMERANGMATH == true then
                                MOVESPEED = CFRAME.p - MOVEDIRECTION.Magnitude / TIME * BOOMR1
                            else
                                MOVESPEED = CFRAME.p - MOVEDIRECTION.Magnitude / TIME
                            end
                        end
                        local GROWTH
                        if USEBOOMERANGMATH == true then
                            GROWTH = (SIZE - ENDSIZE) * (BOOMR2 + 1)
                        else
                            GROWTH = SIZE - ENDSIZE
                        end
                        local TRANS = TRANSPARENCY - ENDTRANSPARENCY
                        if TYPE == "Block" then
                            EFFECT.CFrame = CFRAME * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)))
                        else
                            EFFECT.CFrame = CFRAME
                        end
                        if SOUND then
                            SOUND.Parent = EFFECT
                        end
                        if USEBOOMERANGMATH == true then
                            for LOOP = 1, TIME + 1 do
                                Swait()
                                MSH.Scale = MSH.Scale - VT(GROWTH.X * (1 - LOOP / TIME * BOOMR2), GROWTH.Y * (1 - LOOP / TIME * BOOMR2), GROWTH.Z * (1 - LOOP / TIME * BOOMR2)) * BOOMR2 / TIME
                                if TYPE == "Wave" then
                                    MSH.Offset = VT(0, 0, -MSH.Scale.Z / 8)
                                end
                                EFFECT.Transparency = EFFECT.Transparency - TRANS / TIME
                                if TYPE == "Block" then
                                    EFFECT.CFrame = CFRAME * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)))
                                else
                                    EFFECT.CFrame = EFFECT.CFrame * ANGLES(RAD(ROTATION1), RAD(ROTATION2), RAD(ROTATION3))
                                end
                                if MOVEDIRECTION ~= nil then
                                    local ORI = EFFECT.Orientation
                                    EFFECT.CFrame = CF(EFFECT.Position, MOVEDIRECTION) * CF(0, 0, -MOVESPEED * (1 - LOOP / TIME * BOOMR1))
                                    EFFECT.CFrame = CF(EFFECT.Position) * ANGLES(RAD(ORI.X), RAD(ORI.Y), RAD(ORI.Z))
                                end
                            end
                        else
                            for LOOP = 1, TIME + 1 do
                                Swait()
                                MSH.Scale = MSH.Scale - GROWTH / TIME
                                if TYPE == "Wave" then
                                    MSH.Offset = VT(0, 0, -MSH.Scale.Z / 8)
                                end
                                EFFECT.Transparency = EFFECT.Transparency - TRANS / TIME
                                if TYPE == "Block" then
                                    EFFECT.CFrame = CFRAME * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)))
                                else
                                    EFFECT.CFrame = EFFECT.CFrame * ANGLES(RAD(ROTATION1), RAD(ROTATION2), RAD(ROTATION3))
                                end
                                if MOVEDIRECTION ~= nil then
                                    local ORI = EFFECT.Orientation
                                    EFFECT.CFrame = CF(EFFECT.Position, MOVEDIRECTION) * CF(0, 0, -MOVESPEED)
                                    EFFECT.CFrame = CF(EFFECT.Position) * ANGLES(RAD(ORI.X), RAD(ORI.Y), RAD(ORI.Z))
                                end
                            end
                        end
                        EFFECT.Transparency = 1
                        if PLAYSSOUND == false then
                            EFFECT:remove()
                        else
                            repeat
                                Swait()
                            until EFFECT:FindFirstChildOfClass("Sound") == nil
                            EFFECT:remove()
                        end
                    elseif PLAYSSOUND == false then
                        EFFECT:remove()
                    else
                        repeat
                            Swait()
                        until EFFECT:FindFirstChildOfClass("Sound") == nil
                        EFFECT:remove()
                    end
                end))
            end
            function MakeForm(PART, TYPE)
                if TYPE == "Cyl" then
                    local MSH = IT("CylinderMesh", PART)
                elseif TYPE == "Ball" then
                    local MSH = IT("SpecialMesh", PART)
                    MSH.MeshType = "Sphere"
                elseif TYPE == "Wedge" then
                    local MSH = IT("SpecialMesh", PART)
                    MSH.MeshType = "Wedge"
                end
            end
            Debris = game:GetService("Debris")
            function CastProperRay(StartPos, EndPos, Distance, Ignore)
                local DIRECTION = CF(StartPos, EndPos).lookVector
                local Ignore = type(Ignore) == "table" and Ignore or {Ignore}
                return game:GetService("Workspace"):FindPartOnRayWithIgnoreList(Ray.new(StartPos, DIRECTION * Distance), Ignore)
            end
            local Particle = IT("ParticleEmitter", nil)
            Particle.Enabled = false
            Particle.LightEmission = 0.9
            Particle.Rate = 150
            Particle.ZOffset = 0.2
            Particle.Rotation = NumberRange.new(-180, 180)
            function ParticleEmitter(Table)
                local PRTCL = Particle:Clone()
                local Color1 = Table.Color1 or C3(1, 1, 1)
                local Color2 = Table.Color2 or C3(1, 1, 1)
                local Speed = Table.Speed or 5
                local Drag = Table.Drag or 0
                local Size1 = Table.Size1 or 1
                local Size2 = Table.Size2 or 5
                local Lifetime1 = Table.Lifetime1 or 1
                local Lifetime2 = Table.Lifetime2 or 1.5
                local Parent = Table.Parent or Torso
                local Emit = Table.Emit or 100
                local Offset = Table.Offset or 360
                local Acel = Table.Acel or VT(0, 0, 0)
                local Enabled = Table.Enabled or false
                local Texture = Table.Texture or "281983280"
                local RotS = Table.RotSpeed or NumberRange.new(-15, 15)
                local Trans1 = Table.Transparency1 or 1
                local Trans2 = Table.Transparency2 or 0
                PRTCL.Parent = Parent
                PRTCL.RotSpeed = RotS
                PRTCL.Transparency = NumberSequence.new({
                    NumberSequenceKeypoint.new(0, Trans1),
                    NumberSequenceKeypoint.new(1, Trans2)
                })
                PRTCL.Texture = "http://www.roblox.com/asset/?id=" .. Texture
                PRTCL.Color = ColorSequence.new(Color1, Color2)
                PRTCL.Size = NumberSequence.new(Size1, Size2)
                PRTCL.Lifetime = NumberRange.new(Lifetime1, Lifetime2)
                PRTCL.Speed = NumberRange.new(Speed)
                PRTCL.VelocitySpread = Offset
                PRTCL.Drag = Drag
                PRTCL.Acceleration = Acel
                if Enabled == false then
                    PRTCL:Emit(Emit)
                    Debris:AddItem(PRTCL, Lifetime2)
                else
                    PRTCL.Enabled = true
                end
                return PRTCL
            end
            function CamShake(SHAKE, TIMER)
                coroutine.resume(coroutine.create(function()
                    local FADER = SHAKE / TIMER
                    for i = 1, TIMER do
                        wait()
                        Humanoid.CameraOffset = VT(MRANDOM(-(SHAKE - FADER * i), SHAKE - FADER * i) / 10, MRANDOM(-(SHAKE - FADER * i), SHAKE - FADER * i) / 10, MRANDOM(-(SHAKE - FADER * i), SHAKE - FADER * i) / 10)
                    end
                    Humanoid.CameraOffset = VT(0, 0, 0)
                end))
            end
            function GetRoot(MODEL, ROOT)
                if ROOT == true then
                    return MODEL:FindFirstChild("HumanoidRootPart") or MODEL:FindFirstChild("Torso") or MODEL:FindFirstChild("UpperTorso")
                else
                    return MODEL:FindFirstChild("Torso") or MODEL:FindFirstChild("UpperTorso")
                end
            end
    
    
            local NCK = IT("Attachment", Torso)
            NCK.Position = VT(0, 1, 0)
            local NECKFIRE = ParticleEmitter({
                Acel = VT(0, 3.5, 0),
                Speed = 1.5,
                RotSpeed = NumberRange.new(-15, 15),
                Drag = 0.1,
                Size1 = 0.6,
                Size2 = 0,
                Lifetime1 = 0,
                Lifetime2 = 0.45,
                Parent = NCK,
                Emit = 100,
                Offset = 360,
                Enabled = true,
                Color1 = BRICKC("Royal purple").Color,
                Color2 = BRICKC("Royal purple").Color,
                Texture = "296874871"
            })
            NECKFIRE.LockedToPart = true
            NECKFIRE.Rate = 999
            local BMUSIC = IT("Sound", RootPart)
            local VOLUME = 4
            local PITCH = 1
            local SONGID = 1571736139
            local top = Instance.new("Shirt")
            top.ShirtTemplate = "rbxassetid://1533635803"
            top.Parent = Character
            top.Name = "Cloth"
            local bottom = Instance.new("Pants")
            bottom.PantsTemplate = "rbxassetid://1460022985"
            bottom.Parent = Character
            bottom.Name = "Cloth"
            local SKILLTEXTCOLOR = BRICKC("Royal purple").Color
            local SKILLFONT = "Bodoni"
            local SKILLTEXTSIZE = 6.5
            local ATTACKS = {
                "Leaping Pumpkin - Z",
                "Rollout - X",
                "Trashing - C",
                "Incinithrower - V",
                "Zoom - E",
                "Hothead - Q"
            }
            for i = 1, #ATTACKS do
                local SKILLFRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.74, 0, 0.97 - 0.03 * i, 0), UD2(0.26, 0, 0.07, 0), C3(0, 0, 0), C3(0, 0, 0), "Skill Frame")
                local SKILLTEXT = CreateLabel(SKILLFRAME, "[" .. ATTACKS[i] .. "]", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.5, "Skill text")
                SKILLTEXT.TextXAlignment = "Right"
            end
            function ApplyDamage(Humanoid, Damage)
                return
            end
            function ApplyAoE(POSITION, RANGE, MINDMG, MAXDMG, FLING, INSTAKILL)
                return
            end
            function LeapingPumpkin()
                ATTACK = true
                Rooted = true
                HEADTURN = false
                for i = 0, 0.15, 0.1 / Animation_Speed do
                    Swait()
                    RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, -0.05) * ANGLES(RAD(-25), RAD(0), RAD(0)), 1 / Animation_Speed)
                    Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
                    RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-45), RAD(-12), RAD(5)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
                    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-45), RAD(12), RAD(-5)) * LEFTSHOULDERC0, 1 / Animation_Speed)
                    RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(-50), RAD(85), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
                    LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(-50), RAD(-85), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
                end
                CreateSound(166423113, Torso, 5, 1.1, false)
                CreateSound(166423113, Torso, 5, 1.1, false)
                for i = 0, 2, 0.1 / Animation_Speed do
                    RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 4) * ANGLES(RAD(45), RAD(0), RAD(0)), 1 / Animation_Speed)
                end
                CamShake(15, 17)
                local HITS = {}
                for i = 1, 65 do
                    local VALUE = -((65 - i) / 65)
                    RootPart.CFrame = RootPart.CFrame * CF(0, 0, VALUE)
                    Swait()
                    if VALUE < -0.65 and (ANIM == "Idle" or ANIM == "Walk") then
                        WACKYEFFECT({
                            Time = 26,
                            EffectType = "Wave",
                            Size = VT(5, 0, 5),
                            Size2 = VT(8, 5, 8),
                            Transparency = 0.8,
                            Transparency2 = 1,
                            CFrame = RootPart.CFrame * CF(0, -3.5, -5) * ANGLES(RAD(45), RAD(MRANDOM(0, 360)), RAD(MRANDOM(-5, 5))),
                            MoveToPos = nil,
                            RotationX = 0.1,
                            RotationY = 1,
                            RotationZ = -0.1,
                            Material = "Neon",
                            Color = C3(1, 1, 1),
                            SoundID = nil,
                            SoundPitch = nil,
                            SoundVolume = nil,
                            UseBoomerangMath = false,
                            Boomerang = 0,
                            SizeBoomerang = 0
                        })
                        WACKYEFFECT({
                            Time = 12,
                            EffectType = "Wave",
                            Size = VT(0, 0, 0),
                            Size2 = VT(12, 2, 12),
                            Transparency = 0.8,
                            Transparency2 = 1,
                            CFrame = RootPart.CFrame * CF(0, -3.5, -4) * ANGLES(RAD(45), RAD(MRANDOM(0, 360)), RAD(MRANDOM(-5, 5))),
                            MoveToPos = nil,
                            RotationX = 0.1,
                            RotationY = 1,
                            RotationZ = -0.1,
                            Material = "Neon",
                            Color = C3(1, 1, 1),
                            SoundID = nil,
                            SoundPitch = nil,
                            SoundVolume = nil,
                            UseBoomerangMath = true,
                            Boomerang = 0,
                            SizeBoomerang = 12
                        })
                        for index, CHILD in pairs(workspace:GetDescendants()) do
                            if CHILD.ClassName == "Model" and CHILD ~= Character and CHILD.Name ~= "PurpleEerinFireball" then
                                local HUM = CHILD:FindFirstChildOfClass("Humanoid")
                                if HUM then
                                    local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
                                    if TORSO and (TORSO.Position - RootPart.Position).Magnitude <= 6 then
                                        local PASS = true
                                        for E = 1, #HITS do
                                            if HITS[E] == CHILD then
                                                PASS = false
                                            end
                                        end
                                        if PASS == true then
                                            local DMG = MRANDOM(25, 45)
                                            ApplyDamage(HUM, DMG)
                                            table.insert(HITS, CHILD)
                                            for _, c in pairs(CHILD:GetChildren()) do
                                                if c:IsA("BasePart") then
                                                    local bv = Instance.new("BodyVelocity")
                                                    bv.maxForce = Vector3.new(1000000000, 1000000000, 1000000000)
                                                    bv.velocity = CF(Torso.Position, TORSO.Position).lookVector * 65
                                                    bv.Parent = c
                                                    Debris:AddItem(bv, 0.05)
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                    RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, -3) * ANGLES(RAD(90), RAD(0), RAD(0)), 0.6 / Animation_Speed)
                    Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
                    RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.75, 0) * ANGLES(RAD(170), RAD(0), RAD(12)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
                    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.75, 0) * ANGLES(RAD(170), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
                    RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.5) * ANGLES(RAD(-45), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
                    LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
                end
                for i = 0, 0.7, 0.1 / Animation_Speed do
                    Swait()
                    RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, -3) * ANGLES(RAD(90), RAD(0), RAD(0)), 1 / Animation_Speed)
                    Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
                    RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.75, 0) * ANGLES(RAD(170), RAD(0), RAD(12)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
                    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.75, 0) * ANGLES(RAD(170), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
                    RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.5) * ANGLES(RAD(-100), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
                    LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
                end
                HEADTURN = true
                ATTACK = false
                Rooted = false
            end
            function Rollout()
                if UNANCHOR == true then
                    RootPart.Velocity = VT(0, 0, 0)
                end
                ATTACK = true
                Rooted = false
                UNANCHOR = false
                HEADTURN = false
                if ANIM == "Idle" or ANIM == "Walk" then
                    for i = 1, 3 do
                        WACKYEFFECT({
                            Time = 15,
                            EffectType = "Wave",
                            Size = VT(2, 0, 2),
                            Size2 = VT(12, 2.5, 12),
                            Transparency = 0.6,
                            Transparency2 = 1,
                            CFrame = CF(RootPart.CFrame * CF(0, -4, 0).p) * ANGLES(RAD(0), RAD(MRANDOM(0, 360)), RAD(0)),
                            MoveToPos = nil,
                            RotationX = 1,
                            RotationY = 0,
                            RotationZ = 0,
                            Material = "Neon",
                            Color = C3(1, 1, 1),
                            SoundID = nil,
                            SoundPitch = MRANDOM(9, 11) / 10,
                            SoundVolume = MRANDOM(9, 11) / 2,
                            UseBoomerangMath = true,
                            Boomerang = 0,
                            SizeBoomerang = 22
                        })
                    end
                end
                coroutine.resume(coroutine.create(function()
                    for i = 1, 25 do
                        Swait()
                        RootPart.CFrame = RootPart.CFrame * CF(0, (25 - i) / 7, 0)
                    end
                end))
                CreateSound(1368583274, Torso, 5, 1.1, false)
                for i = 1, 65 do
                    Swait()
                    WACKYEFFECT({
                        Time = 15,
                        EffectType = "Round Slash",
                        Size = VT(0.1, 0, 0.1),
                        Size2 = VT(0, 0, 0),
                        Transparency = 1,
                        Transparency2 = 0.5,
                        CFrame = CF(RootPart.Position) * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360))),
                        MoveToPos = nil,
                        RotationX = 0,
                        RotationY = 0,
                        RotationZ = 0,
                        Material = "Neon",
                        Color = C3(1, 1, 1),
                        SoundID = nil,
                        SoundPitch = nil,
                        SoundVolume = nil,
                        UseBoomerangMath = true,
                        Boomerang = 0,
                        SizeBoomerang = 35
                    })
                    RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(i * 45), RAD(0), RAD(0)), 2.5 / Animation_Speed)
                    Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-20), RAD(0), RAD(0)), 0.2 / Animation_Speed)
                    RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.5, -1) * ANGLES(RAD(0), RAD(0), RAD(-90)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
                    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.5, -1) * ANGLES(RAD(0), RAD(0), RAD(90)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
                    RightHip.C0 = Clerp(RightHip.C0, CF(1, 0, -0.5) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-20)), 0.2 / Animation_Speed)
                    LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, 0, -0.5) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(20)), 0.2 / Animation_Speed)
                end
                RootPart.CFrame = CF(RootPart.Position, Mouse.Hit.p)
                for E = 1, 2 do
                    for i = 1, 4 do
                        WACKYEFFECT({
                            Time = 80,
                            EffectType = "Round Slash",
                            Size = VT(0, 0, 0),
                            Size2 = VT(E, 0, E) / 4,
                            Transparency = 0,
                            Transparency2 = 1,
                            CFrame = CF(RootPart.Position) * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360))),
                            MoveToPos = nil,
                            RotationX = 0,
                            RotationY = 0,
                            RotationZ = 0,
                            Material = "Neon",
                            Color = C3(1, 1, 1),
                            SoundID = nil,
                            SoundPitch = nil,
                            SoundVolume = nil,
                            UseBoomerangMath = true,
                            Boomerang = 0,
                            SizeBoomerang = 35
                        })
                    end
                end
                for i = 1, 12 do
                    WACKYEFFECT({
                        Time = 35 - i,
                        EffectType = "Wave",
                        Size = VT(12, 0, 12),
                        Size2 = VT(13 + i * 5, 5 + i * 3, 13 + i * 5),
                        Transparency = 0.3,
                        Transparency2 = 1,
                        CFrame = RootPart.CFrame * CF(0, 0, -4) * ANGLES(RAD(90), RAD(MRANDOM(0, 360)), RAD(MRANDOM(-5, 5))),
                        MoveToPos = nil,
                        RotationX = 0.1,
                        RotationY = 1,
                        RotationZ = -0.1,
                        Material = "Neon",
                        Color = C3(1, 1, 1),
                        SoundID = nil,
                        SoundPitch = nil,
                        SoundVolume = nil,
                        UseBoomerangMath = false,
                        Boomerang = 0,
                        SizeBoomerang = 15
                    })
                end
                WACKYEFFECT({
                    Time = 45,
                    EffectType = "Sphere",
                    Size = VT(15, 15, 15),
                    Size2 = VT(35, 35, 35),
                    Transparency = 0.7,
                    Transparency2 = 1,
                    CFrame = CF(RootPart.Position),
                    MoveToPos = nil,
                    RotationX = 0,
                    RotationY = 0,
                    RotationZ = 0,
                    Material = "Neon",
                    Color = SKILLTEXTCOLOR,
                    SoundID = 1368637781,
                    SoundPitch = 1,
                    SoundVolume = 5,
                    UseBoomerangMath = true,
                    Boomerang = 0,
                    SizeBoomerang = 50
                })
                coroutine.resume(coroutine.create(function()
                    local LANDED = false
                    local ROT = 0
                    local RAWS = {257001341, 257001320}
                    local ROLLER = CreatePart(3, Effects, "Fabric", 0, 0, BRICKC("Pearl"), "ROLLERDAH", VT(13.02, 9.3, 12.09) / 1.5, true)
                    local S = CreateSound(RAWS[MRANDOM(1, 2)], ROLLER, 10, MRANDOM(8, 13) / 10, false)
                    S.EmitterSize = 70
                    CreateMesh("SpecialMesh", ROLLER, "FileMesh", "16973748", "1090019344", VT(9.3, 9.3, 9.3), VT(0, 0, 0))
                    local FACE = CreatePart(3, Effects, "Neon", 0, 0, BRICKC("Royal purple"), "Fire", VT(1, 0.1, 1) * 13.02, true)
                    MakeForm(FACE, "Ball")
                    ROLLER.CFrame = RootPart.CFrame
                    local SPEED = 0
                    local NECKFIRE = ParticleEmitter({
                        Acel = VT(0, 75, 0),
                        Speed = 6,
                        RotSpeed = NumberRange.new(-15, 15),
                        Drag = 0.5,
                        Size1 = 7,
                        Size2 = 0,
                        Lifetime1 = 0,
                        Lifetime2 = 1.4,
                        Parent = ROLLER,
                        Emit = 100,
                        Offset = 360,
                        Enabled = true,
                        Color1 = BRICKC("Royal purple").Color,
                        Color2 = BRICKC("Royal purple").Color,
                        Texture = "296874871"
                    })
                    NECKFIRE.Rate = 999
                    local TOUCHED = false
                    ROLLER.Touched:Connect(function(HIT)
                        if HIT.Parent ~= Character then
                            TOUCHED = true
                        end
                    end)
                    for i = 1, 15 do
                        Swait()
                        ROLLER.CFrame = ROLLER.CFrame * CF(0, -(i / 15), -2)
                        FACE.CFrame = ROLLER.CFrame * CF(0, -4.2780000000000005, 0)
                        local HITFLOOR = Raycast(ROLLER.Position, ROLLER.CFrame.lookVector, 5.5, Character)
                        if TOUCHED == true or HITFLOOR then
                            break
                        end
                    end
                    local CFRAME = CF(ROLLER.Position) * ANGLES(RAD(0), RAD(ROLLER.Orientation.Y), RAD(0))
                    for i = 1, 200 do
                        Swait()
                        local HITFLOOR = Raycast(ROLLER.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 5.5, Character)
                        if HITFLOOR then
                            if LANDED == false then
                                LANDED = true
                                coroutine.resume(coroutine.create(function()
                                    for i = 1, 15 do
                                        Swait()
                                        SPEED = SPEED + 0.1
                                    end
                                end))
                            end
                            ROLLER.CanCollide = true
                            CFRAME = CFRAME * CF(0, 0, -SPEED)
                            WACKYEFFECT({
                                Time = 26,
                                EffectType = "Wave",
                                Size = VT(12, 0, 12),
                                Size2 = VT(18, 5, 18),
                                Transparency = 0.8,
                                Transparency2 = 1,
                                CFrame = CFRAME * CF(0, -5, -7) * ANGLES(RAD(15), RAD(MRANDOM(0, 360)), RAD(MRANDOM(-5, 5))),
                                MoveToPos = nil,
                                RotationX = 0.1,
                                RotationY = 1,
                                RotationZ = -0.1,
                                Material = "Neon",
                                Color = HITFLOOR.Color,
                                SoundID = nil,
                                SoundPitch = nil,
                                SoundVolume = nil,
                                UseBoomerangMath = false,
                                Boomerang = 0,
                                SizeBoomerang = 15
                            })
                        else
                            ROLLER.CanCollide = false
                            SPEED = 0.8
                            LANDED = false
                            CFRAME = CFRAME * CF(0, -1.5, -SPEED)
                        end
                        ROT = ROT + SPEED * 6
                        ROLLER.CFrame = CFRAME * ANGLES(RAD(-ROT), RAD(0), RAD(0))
                        FACE.CFrame = ROLLER.CFrame * CF(0, -4.2780000000000005, 0)
                        local COLISSION1 = Raycast(ROLLER.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 6, Character)
                        local COLISSION2 = Raycast(ROLLER.Position, CFRAME.lookVector, 6, Character)
                        if COLISSION1 and COLISSION1.Parent:FindFirstChildOfClass("Humanoid") then
                            break
                        end
                        if COLISSION2 then
                            break
                        end
                        if TOUCHED == true then
                            break
                        end
                    end
                    CamShake(6, 12)
                    ApplyAoE(ROLLER.Position, 50, 25, 65, 150, true)
                    ApplyAoE(ROLLER.Position, 125, 25, 65, 150, false)
                    WACKYEFFECT({
                        Time = 25,
                        EffectType = "Sphere",
                        Size = VT(15, 15, 15),
                        Size2 = VT(50, 50, 50),
                        Transparency = 0.7,
                        Transparency2 = 1,
                        CFrame = CF(ROLLER.Position),
                        MoveToPos = nil,
                        RotationX = 0,
                        RotationY = 0,
                        RotationZ = 0,
                        Material = "Neon",
                        Color = SKILLTEXTCOLOR,
                        SoundID = 1664711478,
                        SoundPitch = 1,
                        SoundVolume = 8,
                        UseBoomerangMath = true,
                        Boomerang = 0,
                        SizeBoomerang = 50
                    })
                    WACKYEFFECT({
                        Time = 25,
                        EffectType = "Sphere",
                        Size = VT(15, 15, 15),
                        Size2 = VT(70, 70, 70),
                        Transparency = 0.7,
                        Transparency2 = 1,
                        CFrame = CF(ROLLER.Position),
                        MoveToPos = nil,
                        RotationX = 0,
                        RotationY = 0,
                        RotationZ = 0,
                        Material = "Neon",
                        Color = SKILLTEXTCOLOR,
                        SoundID = 201858144,
                        SoundPitch = 1,
                        SoundVolume = 5,
                        UseBoomerangMath = true,
                        Boomerang = 0,
                        SizeBoomerang = 50
                    })
                    for i = 1, 5 do
                        WACKYEFFECT({
                            Time = 65 - i * 12,
                            EffectType = "Sphere",
                            Size = VT(0, 0, 0),
                            Size2 = VT(45, 45, 45) + VT(i, i, i) * 55,
                            Transparency = 0,
                            Transparency2 = 1,
                            CFrame = CF(ROLLER.Position),
                            MoveToPos = nil,
                            RotationX = 0,
                            RotationY = 0,
                            RotationZ = 0,
                            Material = "Neon",
                            Color = SKILLTEXTCOLOR,
                            SoundID = nil,
                            SoundPitch = nil,
                            SoundVolume = nil,
                            UseBoomerangMath = false,
                            Boomerang = 0,
                            SizeBoomerang = 0
                        })
                    end
                    for E = 1, 3 do
                        for i = 1, 4 do
                            WACKYEFFECT({
                                Time = 50,
                                EffectType = "Round Slash",
                                Size = VT(0, 0, 0),
                                Size2 = VT(E, 0, E) / 2,
                                Transparency = 0,
                                Transparency2 = 1,
                                CFrame = CF(ROLLER.Position) * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360))),
                                MoveToPos = nil,
                                RotationX = 0,
                                RotationY = 0,
                                RotationZ = 0,
                                Material = "Neon",
                                Color = C3(1, 1, 1),
                                SoundID = nil,
                                SoundPitch = nil,
                                SoundVolume = nil,
                                UseBoomerangMath = true,
                                Boomerang = 0,
                                SizeBoomerang = 10
                            })
                        end
                    end
                    local COLISSION, POS = Raycast(ROLLER.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 12, Character)
                    if COLISSION then
                        for i = 1, 5 do
                            WACKYEFFECT({
                                Time = 20 + i * 15,
                                EffectType = "Wave",
                                Size = VT(15, 0, 15),
                                Size2 = VT(120, 15, 120),
                                Transparency = 0.6,
                                Transparency2 = 1,
                                CFrame = CF(POS) * ANGLES(RAD(0), RAD(MRANDOM(0, 360)), RAD(0)) * ANGLES(RAD(MRANDOM(-15, 15)), RAD(MRANDOM(0, 360)), RAD(0)),
                                MoveToPos = nil,
                                RotationX = 0.2,
                                RotationY = 0,
                                RotationZ = 0,
                                Material = "Neon",
                                Color = C3(1, 1, 1),
                                SoundID = nil,
                                SoundPitch = MRANDOM(9, 11) / 10,
                                SoundVolume = MRANDOM(9, 11) / 2,
                                UseBoomerangMath = true,
                                Boomerang = 0,
                                SizeBoomerang = 22
                            })
                        end
                    end
                    ROLLER.Transparency = 1
                    Debris:AddItem(ROLLER, 5)
                    NECKFIRE.Enabled = false
                    FACE:Remove()
                    for i = 1, 25 do
                        local LEFTOVER = CreatePart(3, workspace, "Pebble", 0, 0, BRICKC("Pearl"), "ROLLERDAH", VT(13.02 * (MRANDOM(8, 12) / 10), 9.3 * (MRANDOM(8, 12) / 10), 12.09 * (MRANDOM(8, 12) / 10)) / 1.5 / 2, false)
                        LEFTOVER.CanCollide = true
                        LEFTOVER.CFrame = ROLLER.CFrame * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)))
                        LEFTOVER.Velocity = CF(LEFTOVER.Position - VT(0, 6, 0), LEFTOVER.CFrame * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360))) * CF(0, 5, 0).p).lookVector * MRANDOM(50, 320)
                        Debris:AddItem(LEFTOVER, 8)
                    end
                end))
                for i = 0, 0.35, 0.1 / Animation_Speed do
                    Swait()
                    RootPart.CFrame = RootPart.CFrame * CF(0, 0, 1.2)
                    RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, -0.05) * ANGLES(RAD(-25), RAD(0), RAD(0)), 1 / Animation_Speed)
                    Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
                    RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(-12), RAD(5)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
                    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(90), RAD(12), RAD(-5)) * LEFTSHOULDERC0, 1 / Animation_Speed)
                    RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(-50), RAD(85), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
                    LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(-50), RAD(-85), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
                end
                HEADTURN = true
                UNANCHOR = true
                ATTACK = false
                Rooted = false
            end
            function Trashing()
                local SpawnVelocity = function(PART, LOCATION, FLING)
                    local bv = IT("BodyVelocity")
                    bv.maxForce = VT(1000000000, 1000000000, 1000000000)
                    bv.Parent = PART
                    bv.velocity = CF(PART.Position, LOCATION).lookVector * FLING
                    Debris:AddItem(bv, 0.35)
                end
                local TARGET = Mouse.Target
                if TARGET ~= nil and TARGET.Parent:FindFirstChildOfClass("Humanoid") then
                    do
                        local HUM = TARGET.Parent:FindFirstChildOfClass("Humanoid")
                        local ROOT = GetRoot(HUM.Parent, false)
                        if ROOT and HUM.Health > 0 and (ROOT.Position - RootPart.Position).Magnitude <= 375 then
                            ATTACK = true
                            Rooted = true
                            CreateSound(1368573150, RightArm, 5, MRANDOM(8, 13) / 10, false)
                            CreateSound(1368573150, ROOT, 5, MRANDOM(8, 13) / 10, false)
                            SpawnVelocity(ROOT, ROOT.Position + VT(0, 35, 0), 80)
                            do
                                local SWOOSH = ParticleEmitter({
                                    Transparency1 = 0,
                                    Transparency2 = 1,
                                    Acel = VT(0, 0, 0),
                                    Speed = 0.8,
                                    RotSpeed = NumberRange.new(-15, 15),
                                    Drag = 0.1,
                                    Size1 = 3,
                                    Size2 = 2,
                                    Lifetime1 = 0,
                                    Lifetime2 = 1,
                                    Parent = ROOT,
                                    Emit = 100,
                                    Offset = 360,
                                    Enabled = true,
                                    Color1 = BRICKC("Royal purple").Color,
                                    Color2 = BRICKC("Royal purple").Color,
                                    Texture = "242627777"
                                })
                                SWOOSH.Rate = 999
                                SWOOSH.LightEmission = 0.9
                                for i = 0, 1, 0.1 / Animation_Speed do
                                    Swait()
                                    WACKYEFFECT({
                                        Time = 12,
                                        EffectType = "Round Slash",
                                        Size = VT(0, 0, 0),
                                        Size2 = VT(0.03, 0, 0.03),
                                        Transparency = 0,
                                        Transparency2 = 1,
                                        CFrame = RightArm.CFrame * CF(0, -1, 0) * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360))),
                                        MoveToPos = nil,
                                        RotationX = 0,
                                        RotationY = 0,
                                        RotationZ = 0,
                                        Material = "Neon",
                                        Color = C3(1, 1, 1),
                                        SoundID = nil,
                                        SoundPitch = nil,
                                        SoundVolume = nil,
                                        UseBoomerangMath = true,
                                        Boomerang = 0,
                                        SizeBoomerang = 10
                                    })
                                    RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0.04, 0, 0) * ANGLES(RAD(0), RAD(2.5), RAD(0)), 1 / Animation_Speed)
                                    Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
                                    RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-25), RAD(-12), RAD(150)) * ANGLES(RAD(0), RAD(180), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
                                    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(12), RAD(-55)) * LEFTSHOULDERC0, 1 / Animation_Speed)
                                    RightHip.C0 = Clerp(RightHip.C0, CF(1, -1.035, 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(0.5), RAD(0), RAD(0)), 1 / Animation_Speed)
                                    LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.965, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-4.5), RAD(0), RAD(0)), 1 / Animation_Speed)
                                end
                                HEADTURN = false
                                SpawnVelocity(ROOT, Mouse.Hit.p + VT(0, 5, 0), 170)
                                HUM.PlatformStand = true
                                CreateSound(471882099, ROOT, 5, MRANDOM(8, 13) / 10, false)
                                ROOT.RotVelocity = VT(MRANDOM(-15, 15), MRANDOM(-15, 15), MRANDOM(-15, 15))
                                local TOUCHES = {}
                                local COLLIDED = false
                                for index, CHILD in pairs(ROOT.Parent:GetChildren()) do
                                    if CHILD:IsA("BasePart") then
                                        local TOC = CHILD.Touched:Connect(function(HIT)
                                            if HIT.Parent ~= ROOT.Parent or HIT.Parent.Parent ~= ROOT.Parent and HIT.Parent ~= Effects then
                                                CamShake(6, 25)
                                                COLLIDED = true
                                                for E = 1, #TOUCHES do
                                                    TOUCHES[E]:Disconnect()
                                                end
                                                local POS = ROOT.Position - VT(0, -0.1, 0)
                                                ApplyAoE(POS, 65, 25, 75, 250, false)
                                                for i = 1, 3 do
                                                    WACKYEFFECT({
                                                        Time = 45 - i * 12,
                                                        EffectType = "Sphere",
                                                        Size = VT(0, 0, 0),
                                                        Size2 = VT(25, 25, 25) + VT(i, i, i) * 55,
                                                        Transparency = 0,
                                                        Transparency2 = 1,
                                                        CFrame = CF(POS),
                                                        MoveToPos = nil,
                                                        RotationX = 0,
                                                        RotationY = 0,
                                                        RotationZ = 0,
                                                        Material = "Neon",
                                                        Color = SKILLTEXTCOLOR,
                                                        SoundID = 1368637781,
                                                        SoundPitch = MRANDOM(8, 14) / 10,
                                                        SoundVolume = 5,
                                                        UseBoomerangMath = false,
                                                        Boomerang = 0,
                                                        SizeBoomerang = 0
                                                    })
                                                end
                                                for E = 1, 2 do
                                                    for i = 1, 2 do
                                                        WACKYEFFECT({
                                                            Time = 50,
                                                            EffectType = "Round Slash",
                                                            Size = VT(0, 0, 0),
                                                            Size2 = VT(E, 0, E) / 2,
                                                            Transparency = 0,
                                                            Transparency2 = 1,
                                                            CFrame = CF(POS) * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360))),
                                                            MoveToPos = nil,
                                                            RotationX = 0,
                                                            RotationY = 0,
                                                            RotationZ = 0,
                                                            Material = "Neon",
                                                            Color = C3(1, 1, 1),
                                                            SoundID = nil,
                                                            SoundPitch = nil,
                                                            SoundVolume = nil,
                                                            UseBoomerangMath = true,
                                                            Boomerang = 0,
                                                            SizeBoomerang = 10
                                                        })
                                                    end
                                                end
                                                local COLISSION, POS = Raycast(CHILD.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 15 * CHILD.Size.Z, CHILD.Parent)
                                                if COLISSION then
                                                    for i = 1, 5 do
                                                        WACKYEFFECT({
                                                            Time = 20 + i * 15,
                                                            EffectType = "Wave",
                                                            Size = VT(15, 0, 15),
                                                            Size2 = VT(80, 15, 80),
                                                            Transparency = 0.6,
                                                            Transparency2 = 1,
                                                            CFrame = CF(POS) * ANGLES(RAD(0), RAD(MRANDOM(0, 360)), RAD(0)) * ANGLES(RAD(MRANDOM(-15, 15)), RAD(MRANDOM(0, 360)), RAD(0)),
                                                            MoveToPos = nil,
                                                            RotationX = 0.2,
                                                            RotationY = 0,
                                                            RotationZ = 0,
                                                            Material = "Neon",
                                                            Color = C3(1, 1, 1),
                                                            SoundID = nil,
                                                            SoundPitch = MRANDOM(9, 11) / 10,
                                                            SoundVolume = MRANDOM(9, 11) / 2,
                                                            UseBoomerangMath = true,
                                                            Boomerang = 0,
                                                            SizeBoomerang = 22
                                                        })
                                                    end
                                                end
                                            end
                                        end)
                                        table.insert(TOUCHES, TOC)
                                    end
                                end
                                coroutine.resume(coroutine.create(function()
                                    for E = 1, 200 do
                                        Swait()
                                        if COLLIDED == true then
                                            break
                                        end
                                    end
                                    SWOOSH.Enabled = false
                                    SWOOSH.Speed = NumberRange.new(0, 25)
                                    SWOOSH:Emit(160)
                                    Debris:AddItem(SWOOSH, 5)
                                    for E = 1, #TOUCHES do
                                        TOUCHES[E]:Disconnect()
                                    end
                                    HUM.PlatformStand = false
                                end))
                                for i = 1, 3 do
                                    WACKYEFFECT({
                                        Time = 45 - i * 12,
                                        EffectType = "Sphere",
                                        Size = VT(0, 0, 0),
                                        Size2 = VT(5, 5, 5) + VT(i, i, i) * 3,
                                        Transparency = 0,
                                        Transparency2 = 1,
                                        CFrame = CF(RightArm.CFrame * CF(0, -1, 0).p),
                                        MoveToPos = nil,
                                        RotationX = 0,
                                        RotationY = 0,
                                        RotationZ = 0,
                                        Material = "Neon",
                                        Color = SKILLTEXTCOLOR,
                                        SoundID = 1368637781,
                                        SoundPitch = MRANDOM(8, 20) / 10,
                                        SoundVolume = 2,
                                        UseBoomerangMath = false,
                                        Boomerang = 0,
                                        SizeBoomerang = 0
                                    })
                                end
                                for i = 0, 1, 0.1 / Animation_Speed do
                                    Swait()
                                    RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0.2, 0) * ANGLES(RAD(0), RAD(0), RAD(45)), 1 / Animation_Speed)
                                    Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(45), RAD(0), RAD(15)), 1 / Animation_Speed)
                                    RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.15, 0.45, -0.5) * ANGLES(RAD(45), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
                                    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(12 - 2.5 * SIN(SINE / 12)), RAD(-55 - 2.5 * SIN(SINE / 12) - 2.5 * COS(SINE / 6))) * LEFTSHOULDERC0, 1 / Animation_Speed)
                                    RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(50), RAD(0)) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
                                    LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-100), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
                                end
                                HEADTURN = true
                                ATTACK = false
                                Rooted = false
                            end
                        end
                    end
                end
            end
            function Incinithrower()
                ATTACK = true
                Rooted = true
                local SpawnVelocity = function(PART, LOCATION, FLING)
                    local bv = IT("BodyVelocity")
                    bv.maxForce = VT(1000000000, 1000000000, 1000000000)
                    bv.velocity = CF(PART.Position, LOCATION).lookVector * FLING
                    bv.Parent = PART
                    coroutine.resume(coroutine.create(function()
                        wait(0.5)
                        bv:Remove()
                    end))
                end
                function SPAWNFIREBALL(CFRAME, FLING, SIZE)
                    coroutine.resume(coroutine.create(function()
                        local S = SIZE.X
                        local FIRECHAR = IT("Model", workspace)
                        local E = IT("BoolValue", FIRECHAR)
                        E.Name = "AboutToEerin"
                        FIRECHAR.Name = "PurpleEerinFireball"
                        local FIREBALL = CreatePart(3, FIRECHAR, "Fabric", 0, 1, BRICKC("Pearl"), "Torso", SIZE, false)
                        FIREBALL.CFrame = CFRAME
                        local HED = CreatePart(3, FIRECHAR, "Fabric", 0, 1, BRICKC("Pearl"), "Head", VT(0, 0, 0), false)
                        local WELD = CreateWeldOrSnapOrMotor("Weld", FIREBALL, FIREBALL, HED, CF(0, 0, 0), CF(0, 0, 0))
                        local LEGDAY = CreatePart(3, FIRECHAR, "Fabric", 0, 1, BRICKC("Pearl"), "Right leg", SIZE, false)
                        local WELD2 = CreateWeldOrSnapOrMotor("Weld", FIREBALL, FIREBALL, LEGDAY, CF(0, 0, 0), CF(0, 0, 0))
                        CreateSound(471882099, FIREBALL, 5, MRANDOM(8, 13) / 7, false)
                        local HUM = IT("Humanoid", FIRECHAR)
                        HUM.MaxHealth = 25
                        HUM.Health = 25
                        FIREBALL.CanCollide = true
                        FIREBALL.Shape = "Ball"
                        WELD.Parent = FIREBALL
                        WELD2.Parent = FIREBALL
                        SpawnVelocity(FIREBALL, CFRAME * CF(0, 0, -1).p, MRANDOM(FLING - math.ceil(FLING / 1.5), FLING + math.ceil(FLING / 1.5)))
                        local BURN = ParticleEmitter({
                            Acel = VT(0, 85, 0),
                            Speed = 2,
                            RotSpeed = NumberRange.new(-15, 15),
                            Drag = 0.5,
                            Size1 = S * 2,
                            Size2 = 0,
                            Lifetime1 = 0,
                            Lifetime2 = 0.4,
                            Parent = FIREBALL,
                            Emit = 100,
                            Offset = 360,
                            Enabled = true,
                            Color1 = BRICKC("Royal purple").Color,
                            Color2 = BRICKC("Royal purple").Color,
                            Texture = "296874871"
                        })
                        BURN.Rate = 999
                        local FIXMEFFS = FIRECHAR.AncestryChanged:Connect(function(G, AY)
                            Swait()
                            if FIRECHAR.Parent ~= workspace then
                                FIRECHAR.Parent = workspace
                            end
                        end)
                        wait(1)
                        local DETONATE = false
                        for E = 1, math.ceil(200 * S) do
                            Swait(4)
                            if HUM.Health == 0 then
                                break
                            end
                            do
                                local RANGE = 150
                                local TARGET
                                for index, CHILD in pairs(workspace:GetDescendants()) do
                                    if CHILD.ClassName == "Model" and CHILD ~= Character and CHILD:FindFirstChild("AboutToEerin") == nil then
                                        local HUM = CHILD:FindFirstChildOfClass("Humanoid")
                                        if HUM then
                                            local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
                                            if TORSO and 0 < HUM.Health and RANGE >= (TORSO.Position - FIREBALL.Position).Magnitude then
                                                RANGE = (TORSO.Position - FIREBALL.Position).Magnitude
                                                TARGET = TORSO
                                            end
                                        end
                                    end
                                end
                                if TARGET then
                                    FIREBALL.CFrame = CF(FIREBALL.Position, VT(TARGET.Position.X, FIREBALL.Position.Y, TARGET.Position.Z))
                                    HUM:MoveTo(TARGET.Position)
                                    if 5 > (TARGET.Position - FIREBALL.Position).Magnitude then
                                        DETONATE = true
                                        coroutine.resume(coroutine.create(function()
                                            local E = IT("BoolValue", TARGET.Parent)
                                            E.Name = "AboutToEerin"
                                            local FOE = TARGET.Parent
                                            local HUM = FOE:FindFirstChildOfClass("Humanoid")
                                            if HUM then
                                                local FIRES = {}
                                                for index, CHILD in pairs(FOE:GetChildren()) do
                                                    if CHILD:IsA("BasePart") then
                                                        local BURN = ParticleEmitter({
                                                            Acel = VT(0, 55, 0),
                                                            Speed = 2,
                                                            RotSpeed = NumberRange.new(-15, 15),
                                                            Drag = 0.5,
                                                            Size1 = 2,
                                                            Size2 = 0,
                                                            Lifetime1 = 0,
                                                            Lifetime2 = 0.7,
                                                            Parent = CHILD,
                                                            Emit = 100,
                                                            Offset = 360,
                                                            Enabled = true,
                                                            Color1 = BRICKC("Royal purple").Color,
                                                            Color2 = BRICKC("Royal purple").Color,
                                                            Texture = "296874871"
                                                        })
                                                        BURN.Rate = 999
                                                        table.insert(FIRES, BURN)
                                                    end
                                                end
                                                local DEAD = false
                                                for i = 1, 200 do
                                                    Swait()
                                                    ApplyDamage(HUM, 0.3 * S)
                                                    if HUM.Health < 0.1 then
                                                        DEAD = true
                                                        break
                                                    end
                                                end
                                                E:Remove()
                                                for E = 1, #FIRES do
                                                    FIRES[E].Enabled = false
                                                    Debris:AddItem(FIRES[E], 1.5)
                                                end
                                                if DEAD == true then
                                                    CamShake(15, 5)
                                                    FOE:BreakJoints()
                                                    local CFRAME = TARGET.CFrame
                                                    for E = 1, 2 do
                                                        for i = 1, 4 do
                                                            WACKYEFFECT({
                                                                Time = 50,
                                                                EffectType = "Round Slash",
                                                                Size = VT(0, 0, 0),
                                                                Size2 = VT(E, 0, E) / 6,
                                                                Transparency = 0,
                                                                Transparency2 = 1,
                                                                CFrame = CF(CFRAME.p) * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360))),
                                                                MoveToPos = nil,
                                                                RotationX = 0,
                                                                RotationY = 0,
                                                                RotationZ = 0,
                                                                Material = "Neon",
                                                                Color = C3(1, 1, 1),
                                                                SoundID = nil,
                                                                SoundPitch = nil,
                                                                SoundVolume = nil,
                                                                UseBoomerangMath = true,
                                                                Boomerang = 0,
                                                                SizeBoomerang = 10
                                                            })
                                                        end
                                                    end
                                                    WACKYEFFECT({
                                                        Time = 15,
                                                        EffectType = "Sphere",
                                                        Size = VT(4, 4, 4) * TARGET.Size.Z,
                                                        Size2 = VT(15, 15, 15) * TARGET.Size.Z,
                                                        Transparency = 0.4,
                                                        Transparency2 = 1,
                                                        CFrame = CF(CFRAME.p),
                                                        MoveToPos = nil,
                                                        RotationX = 0,
                                                        RotationY = 0,
                                                        RotationZ = 0,
                                                        Material = "Neon",
                                                        Color = SKILLTEXTCOLOR,
                                                        SoundID = 952306739,
                                                        SoundPitch = MRANDOM(8, 14) / 15,
                                                        SoundVolume = 5,
                                                        UseBoomerangMath = false,
                                                        Boomerang = 0,
                                                        SizeBoomerang = 0
                                                    })
                                                    if S > 0.4 then
                                                        for E = 1, 5 do
                                                            SPAWNFIREBALL(CFRAME * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360))), 150, SIZE / 2)
                                                        end
                                                    end
                                                end
                                            end
                                        end))
                                    end
                                end
                                if DETONATE == true then
                                    break
                                end
                            end
                        end
                        FIXMEFFS:Disconnect()
                        LEGDAY:Remove()
                        HED:Remove()
                        HUM:Remove()
                        BURN.Enabled = false
                        FIREBALL.CanCollide = false
                        FIREBALL.Anchored = true
                        Debris:AddItem(FIRECHAR, 1.5)
                        if DETONATE == false then
                            WACKYEFFECT({
                                Time = 15,
                                EffectType = "Sphere",
                                Size = VT(0, 0, 0),
                                Size2 = VT(6, 6, 6),
                                Transparency = 0.6,
                                Transparency2 = 1,
                                CFrame = CF(FIREBALL.Position),
                                MoveToPos = nil,
                                RotationX = 0,
                                RotationY = 0,
                                RotationZ = 0,
                                Material = "Neon",
                                Color = SKILLTEXTCOLOR,
                                SoundID = 952306739,
                                SoundPitch = MRANDOM(8, 14) / 10,
                                SoundVolume = 5,
                                UseBoomerangMath = false,
                                Boomerang = 0,
                                SizeBoomerang = 0
                            })
                        end
                    end))
                end
                HEADTURN = false
                for i = 0, 1, 0.1 / Animation_Speed do
                    Swait()
                    RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0 - 0.04 * SIN(SINE / 24), 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0 - 2.5 * SIN(SINE / 24)), RAD(0)), 1 / Animation_Speed)
                    Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 - 5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
                    RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.65, 0) * ANGLES(RAD(180), RAD(-12 + 2.5 * SIN(SINE / 12)), RAD(-5 + 2.5 * SIN(SINE / 12) - 2.5 * COS(SINE / 6))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
                    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.65, 0) * ANGLES(RAD(180), RAD(12 - 2.5 * SIN(SINE / 12)), RAD(5 - 2.5 * SIN(SINE / 12) - 2.5 * COS(SINE / 6))) * LEFTSHOULDERC0, 1 / Animation_Speed)
                    RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.035 * SIN(SINE / 24) - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-2 - 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
                    LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.035 * SIN(SINE / 24) - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2 + 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
                end
                for E = 1, 15 do
                    for i = 1, 5 do
                        Swait()
                        RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0.04, 0, 0) * ANGLES(RAD(0), RAD(2.5), RAD(0)), 1 / Animation_Speed)
                        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-E * 155)), 1 / Animation_Speed)
                        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.65, 0) * ANGLES(RAD(220), RAD(-12), RAD(5)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
                        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.65, 0) * ANGLES(RAD(140), RAD(12), RAD(-5)) * LEFTSHOULDERC0, 1 / Animation_Speed)
                        RightHip.C0 = Clerp(RightHip.C0, CF(1, -1.035, 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(0.5), RAD(0), RAD(0)), 1 / Animation_Speed)
                        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.965, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-4.5), RAD(0), RAD(0)), 1 / Animation_Speed)
                    end
                    CamShake(15, 5)
                    for i = 1, 2 do
                        WACKYEFFECT({
                            Time = 25,
                            EffectType = "Round Slash",
                            Size = VT(0, 0, 0),
                            Size2 = VT(0.3, 0, 0.3) / 2,
                            Transparency = 0,
                            Transparency2 = 1,
                            CFrame = CF(Head.Position) * ANGLES(RAD(0), RAD(MRANDOM(0, 360)), RAD(0)) * ANGLES(RAD(MRANDOM(-15, 15)), RAD(MRANDOM(0, 360)), RAD(0)),
                            MoveToPos = nil,
                            RotationX = 0,
                            RotationY = 0,
                            RotationZ = 0,
                            Material = "Neon",
                            Color = C3(1, 1, 1),
                            SoundID = nil,
                            SoundPitch = nil,
                            SoundVolume = nil,
                            UseBoomerangMath = true,
                            Boomerang = 0,
                            SizeBoomerang = 10
                        })
                    end
                    SPAWNFIREBALL(Head.CFrame * CF(0, 0.5, -0.7), 60, VT(1.3, 1.3, 1.3))
                end
                HEADTURN = true
                ATTACK = false
                Rooted = false
            end
            function Zoom()
                CreateSound(92597340, Torso, 10, 1, false)
                local SpawnVelocity = function(PART, LOCATION, FLING)
                    local bv = IT("BodyVelocity")
                    bv.maxForce = VT(1000000000, 1000000000, 1000000000)
                    bv.Parent = PART
                    bv.velocity = CF(PART.Position, LOCATION).lookVector * FLING
                    Debris:AddItem(bv, 0.5)
                    return bv
                end
                ATTACK = true
                Rooted = false
                UNANCHOR = false
                HEADTURN = false
                if ANIM == "Idle" or ANIM == "Walk" then
                    for i = 1, 3 do
                        WACKYEFFECT({
                            Time = 15,
                            EffectType = "Wave",
                            Size = VT(2, 0, 2),
                            Size2 = VT(12, 2.5, 12),
                            Transparency = 0.6,
                            Transparency2 = 1,
                            CFrame = CF(RootPart.CFrame * CF(0, -4, 0).p) * ANGLES(RAD(0), RAD(MRANDOM(0, 360)), RAD(0)),
                            MoveToPos = nil,
                            RotationX = 1,
                            RotationY = 0,
                            RotationZ = 0,
                            Material = "Neon",
                            Color = C3(1, 1, 1),
                            SoundID = nil,
                            SoundPitch = MRANDOM(9, 11) / 10,
                            SoundVolume = MRANDOM(9, 11) / 2,
                            UseBoomerangMath = true,
                            Boomerang = 0,
                            SizeBoomerang = 22
                        })
                    end
                    coroutine.resume(coroutine.create(function()
                        for i = 1, 25 do
                            Swait()
                            RootPart.CFrame = RootPart.CFrame * CF(0, (25 - i) / 7, 0)
                        end
                    end))
                    for i = 1, 35 do
                        Swait()
                        for i = 1, 3 do
                            WACKYEFFECT({
                                Time = 12 - i,
                                EffectType = "Wave",
                                Size = VT(12, 0, 12),
                                Size2 = VT(11 + i * 6, 5 + i * 2, 11 + i * 6),
                                Transparency = 0.8,
                                Transparency2 = 1,
                                CFrame = CF(RootPart.Position, Mouse.Hit.p) * CF(0, 0, 4) * ANGLES(RAD(-90), RAD(MRANDOM(0, 360)), RAD(MRANDOM(-5, 5))),
                                MoveToPos = nil,
                                RotationX = 0.1,
                                RotationY = 1,
                                RotationZ = -0.1,
                                Material = "Neon",
                                Color = C3(1, 1, 1),
                                SoundID = nil,
                                SoundPitch = nil,
                                SoundVolume = nil,
                                UseBoomerangMath = false,
                                Boomerang = 0,
                                SizeBoomerang = 15
                            })
                        end
                        RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(i * 45), RAD(0), RAD(0)), 2.5 / Animation_Speed)
                        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-20), RAD(0), RAD(0)), 0.2 / Animation_Speed)
                        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 0.5, -1) * ANGLES(RAD(0), RAD(0), RAD(-90)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
                        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.5, -1) * ANGLES(RAD(0), RAD(0), RAD(90)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
                        RightHip.C0 = Clerp(RightHip.C0, CF(1, 0, -0.5) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-20)), 0.2 / Animation_Speed)
                        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, 0, -0.5) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(20)), 0.2 / Animation_Speed)
                    end
                end
                UNANCHOR = true
                Humanoid.PlatformStand = true
                RootPart.CFrame = CF(RootPart.Position, Mouse.Hit.p)
                local bv = SpawnVelocity(RootPart, RootPart.CFrame * CF(0, 0, -3).p, 350)
                for E = 1, 3 do
                    for i = 1, 4 do
                        WACKYEFFECT({
                            Time = 50,
                            EffectType = "Round Slash",
                            Size = VT(0, 0, 0),
                            Size2 = VT(E, 0, E) / 4,
                            Transparency = 0,
                            Transparency2 = 1,
                            CFrame = CF(RootPart.Position) * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360))),
                            MoveToPos = nil,
                            RotationX = 0,
                            RotationY = 0,
                            RotationZ = 0,
                            Material = "Neon",
                            Color = C3(1, 1, 1),
                            SoundID = nil,
                            SoundPitch = nil,
                            SoundVolume = nil,
                            UseBoomerangMath = true,
                            Boomerang = 0,
                            SizeBoomerang = 10
                        })
                    end
                end
                for i = 1, 7 do
                    WACKYEFFECT({
                        Time = 45 - i * 4,
                        EffectType = "Sphere",
                        Size = VT(0, 0, 0),
                        Size2 = VT(5, 5, 5) + VT(i, i, i) * 25,
                        Transparency = 0,
                        Transparency2 = 1,
                        CFrame = CF(RootPart.Position),
                        MoveToPos = nil,
                        RotationX = 0,
                        RotationY = 0,
                        RotationZ = 0,
                        Material = "Neon",
                        Color = SKILLTEXTCOLOR,
                        SoundID = 1368637781,
                        SoundPitch = MRANDOM(8, 20) / 10,
                        SoundVolume = 6,
                        UseBoomerangMath = false,
                        Boomerang = 0,
                        SizeBoomerang = 0
                    })
                end
                for i = 1, 12 do
                    WACKYEFFECT({
                        Time = 35 - i,
                        EffectType = "Wave",
                        Size = VT(12, 0, 12),
                        Size2 = VT(11 + i * 6, 5 + i * 2, 11 + i * 6),
                        Transparency = 0.3,
                        Transparency2 = 1,
                        CFrame = RootPart.CFrame * CF(0, 0, 12) * ANGLES(RAD(-90), RAD(MRANDOM(0, 360)), RAD(MRANDOM(-5, 5))),
                        MoveToPos = nil,
                        RotationX = 0.1,
                        RotationY = 1,
                        RotationZ = -0.1,
                        Material = "Neon",
                        Color = C3(1, 1, 1),
                        SoundID = nil,
                        SoundPitch = nil,
                        SoundVolume = nil,
                        UseBoomerangMath = false,
                        Boomerang = 0,
                        SizeBoomerang = 15
                    })
                end
                ApplyAoE(RootPart.Position, 85, 25, 65, 150, false)
                CamShake(12, 12)
                local WINGS = CreatePart(3, Effects, "Neon", 0, 1, BRICKC("Royal purple"), "Yes, fly!", VT(0, 0, 0), false)
                CreateMesh("SpecialMesh", WINGS, "FileMesh", "1963497039", "", VT(2.5, 1.3, 1), VT(0, 1.4, 1.2))
                CreateWeldOrSnapOrMotor("Weld", Torso, Torso, WINGS, CF(0, 0, 0), CF(0, 0, 0))
                coroutine.resume(coroutine.create(function()
                    for i = 1, 5 do
                        Swait()
                        WINGS.Transparency = WINGS.Transparency - 0.1
                    end
                end))
                local HITS = {}
                for i = 0, 1.35, 0.1 / Animation_Speed do
                    Swait()
                    RootPart.CFrame = Clerp(RootPart.CFrame, CF(RootPart.Position, Mouse.Hit.p), 0.3)
                    bv.velocity = CF(RootPart.Position, RootPart.CFrame * CF(0, 0, -3).p).lookVector * 350
                    for index, CHILD in pairs(workspace:GetDescendants()) do
                        if CHILD.ClassName == "Model" and CHILD ~= Character and CHILD.Name ~= "PurpleEerinFireball" then
                            local HUM = CHILD:FindFirstChildOfClass("Humanoid")
                            if HUM then
                                local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
                                if TORSO and 25 >= (TORSO.Position - RootPart.Position).Magnitude then
                                    local PASS = true
                                    for E = 1, #HITS do
                                        if HITS[E] == CHILD then
                                            PASS = false
                                        end
                                    end
                                    if PASS == true then
                                        local DMG = MRANDOM(35, 75)
                                        ApplyDamage(HUM, DMG)
                                        table.insert(HITS, CHILD)
                                        for _, c in pairs(CHILD:GetChildren()) do
                                            if c:IsA("BasePart") then
                                                local bv = Instance.new("BodyVelocity")
                                                bv.maxForce = Vector3.new(1000000000, 1000000000, 1000000000)
                                                bv.velocity = CF(Torso.Position, TORSO.Position).lookVector * 350
                                                bv.Parent = c
                                                Debris:AddItem(bv, 0.05)
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                    RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(80), RAD(0), RAD(0)), 1 / Animation_Speed)
                    Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-45), RAD(0), RAD(0)), 1 / Animation_Speed)
                    RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.45, 0.45, 0.05) * ANGLES(RAD(-10), RAD(-10), RAD(-2)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
                    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.45, 0.45, 0.05) * ANGLES(RAD(-10), RAD(10), RAD(2)) * LEFTSHOULDERC0, 1 / Animation_Speed)
                    RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
                    LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
                    for i = 1, 2 do
                        WACKYEFFECT({
                            Time = 15,
                            EffectType = "Round Slash",
                            Size = VT(0.25, 0, 0.25),
                            Size2 = VT(0.4, 0, 0.4),
                            Transparency = 0.6,
                            Transparency2 = 1,
                            CFrame = RootPart.CFrame * CF(0, 0, -5) * ANGLES(RAD(90), RAD(MRANDOM(0, 360)), RAD(0)) * ANGLES(RAD(MRANDOM(-15, 15)), RAD(MRANDOM(0, 360)), RAD(0)),
                            MoveToPos = nil,
                            RotationX = 0,
                            RotationY = 0,
                            RotationZ = 0,
                            Material = "Neon",
                            Color = C3(1, 1, 1),
                            SoundID = nil,
                            SoundPitch = nil,
                            SoundVolume = nil,
                            UseBoomerangMath = true,
                            Boomerang = 0,
                            SizeBoomerang = 10
                        })
                    end
                end
                Humanoid.PlatformStand = false
                RootPart.CFrame = CF(RootPart.Position) * ANGLES(RAD(0), RAD(RootPart.Orientation.Y), RAD(0))
                coroutine.resume(coroutine.create(function()
                    for i = 1, 25 do
                        Swait()
                        WINGS.Transparency = WINGS.Transparency + 0.02
                    end
                    WINGS:Remove()
                end))
                HEADTURN = true
                ATTACK = false
                Rooted = false
            end
            function Hothead()
                ATTACK = true
                Rooted = true
                UNANCHOR = false
                HEADTURN = false
                coroutine.resume(coroutine.create(function()
                    for i = 1, 25 do
                        Swait()
                        RootPart.CFrame = RootPart.CFrame * CF(0, (25 - i) / 2, 0)
                    end
                end))
                CreateSound(1664710821, Effects, 7, 0.8, false)
                for i = 1, 165 do
                    Swait()
                    WACKYEFFECT({
                        Time = 12,
                        EffectType = "Sphere",
                        Size = VT(3, 3, 3),
                        Size2 = VT(0, 0, 150),
                        Transparency = 0.3,
                        Transparency2 = 1,
                        CFrame = CF(RootPart.Position) * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360))),
                        MoveToPos = nil,
                        RotationX = 0,
                        RotationY = 0,
                        RotationZ = 0,
                        Material = "Neon",
                        Color = SKILLTEXTCOLOR,
                        SoundID = nil,
                        SoundPitch = 1,
                        SoundVolume = 6,
                        UseBoomerangMath = true,
                        Boomerang = 0,
                        SizeBoomerang = 0
                    })
                    WACKYEFFECT({
                        Time = 15,
                        EffectType = "Round Slash",
                        Size = VT(0.3, 0, 0.3),
                        Size2 = VT(0, 0, 0),
                        Transparency = 1,
                        Transparency2 = 0.5,
                        CFrame = CF(RootPart.Position) * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360))),
                        MoveToPos = nil,
                        RotationX = 0,
                        RotationY = 0,
                        RotationZ = 0,
                        Material = "Neon",
                        Color = C3(1, 1, 1),
                        SoundID = nil,
                        SoundPitch = nil,
                        SoundVolume = nil,
                        UseBoomerangMath = true,
                        Boomerang = 0,
                        SizeBoomerang = 35
                    })
                    RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.1 * COS(SINE / 12)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
                    Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-35), RAD(MRANDOM(-5, 5)), RAD(MRANDOM(-5, 5))), 1 / Animation_Speed)
                    RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-25 + MRANDOM(-5, 5)), RAD(-15 + MRANDOM(-5, 5)), RAD(35)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
                    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-25 + MRANDOM(-5, 5)), RAD(15 + MRANDOM(-5, 5)), RAD(-35)) * LEFTSHOULDERC0, 1 / Animation_Speed)
                    RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.6 - 0.05 * SIN(SINE / 12), -0.5) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(-25)), 1 / Animation_Speed)
                    LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * SIN(SINE / 12), 0) * ANGLES(RAD(-5), RAD(-70), RAD(0)) * ANGLES(RAD(1), RAD(0), RAD(0)), 1 / Animation_Speed)
                end
                RootPart.CFrame = CF(RootPart.Position, Mouse.Hit.p)
                coroutine.resume(coroutine.create(function()
                    local ROLLER = CreatePart(3, Effects, "Fabric", 0, 0, BRICKC("Pearl"), "ROLLERDAH", VT(13.02, 9.3, 12.09), true)
                    local S = CreateSound(511715134, Effects, 10, MRANDOM(8, 13) / 10, false)
                    CreateMesh("SpecialMesh", ROLLER, "FileMesh", "16973748", "1090019344", VT(9.3, 9.3, 9.3), VT(0, 0, 0))
                    local FACE = CreatePart(3, Effects, "Neon", 0, 0, BRICKC("Royal purple"), "Fire", VT(1, 0.1, 1) * 13.02, true)
                    MakeForm(FACE, "Ball")
                    local BEHAVIOUR = "Idle"
                    local TARGET
                    local TARGETLOC = RootPart.CFrame * CF(0, 0, -25)
                    local KABLAMO = false
                    local LOOP = 0
                    local AGGRO_LOOP = 0
                    local NECKFIRE = ParticleEmitter({
                        Acel = VT(0, 85, 0),
                        Speed = 6,
                        RotSpeed = NumberRange.new(-15, 15),
                        Drag = 0.5,
                        Size1 = 8,
                        Size2 = 0,
                        Lifetime1 = 0,
                        Lifetime2 = 1.4,
                        Parent = ROLLER,
                        Emit = 100,
                        Offset = 360,
                        Enabled = true,
                        Color1 = BRICKC("Royal purple").Color,
                        Color2 = BRICKC("Royal purple").Color,
                        Texture = "296874871"
                    })
                    NECKFIRE.Rate = 999
                    ROLLER.CFrame = RootPart.CFrame
                    FACE.CFrame = ROLLER.CFrame * CF(0, -4.2780000000000005, 0)
                    local SUICIDED = false
                    for i = 1, 45 do
                        Swait()
                        ROLLER.CFrame = ROLLER.CFrame * CF(0, 0, -(45 - i) / 35)
                        FACE.CFrame = ROLLER.CFrame * CF(0, -4.2780000000000005, 0)
                    end
                    coroutine.resume(coroutine.create(function()
                        repeat
                            Swait()
                            LOOP = LOOP + 1
                            if BEHAVIOUR == "Idle" then
                                ROLLER.CFrame = Clerp(ROLLER.CFrame, TARGETLOC, 0.1)
                            elseif BEHAVIOUR == "Circle" then
                                if TARGET then
                                    if TARGET.Parent then
                                        local HUM = TARGET.Parent:FindFirstChildOfClass("Humanoid")
                                        if HUM then
                                            if HUM.Health > 0 then
                                                local CFRAME = CF(TARGET.Position + VT(0, 65 * (TARGET.Size.Z / 2))) * ANGLES(RAD(0), RAD(LOOP), RAD(0)) * CF(0, 0, 45 * (TARGET.Size.Z / 2))
                                                ROLLER.CFrame = Clerp(ROLLER.CFrame, CF(CFRAME.p, TARGET.Position), 0.1)
                                                AGGRO_LOOP = AGGRO_LOOP + 1
                                                if AGGRO_LOOP >= 250 then
                                                    BEHAVIOUR = "Attack"
                                                end
                                            else
                                                BEHAVIOUR = "Idle"
                                            end
                                        else
                                            BEHAVIOUR = "Idle"
                                        end
                                    else
                                        BEHAVIOUR = "Idle"
                                    end
                                end
                            elseif BEHAVIOUR == "Attack" then
                                AGGRO_LOOP = 0
                                local LOC = TARGET.Position
                                CreateSound(257002167, ROLLER, 10, MRANDOM(8, 13) / 10, false)
                                for i = 1, 25 do
                                    Swait()
                                    ROLLER.CFrame = CF(ROLLER.CFrame * CF(0, 0, 1).p, LOC)
                                    FACE.CFrame = ROLLER.CFrame * CF(0, -4.2780000000000005, 0)
                                end
                                for i = 1, 70 do
                                    local HITFLOOR, POS = Raycast(ROLLER.Position, ROLLER.CFrame.lookVector, 6, Character)
                                    ROLLER.CFrame = ROLLER.CFrame * CF(0, 0, -5)
                                    FACE.CFrame = ROLLER.CFrame * CF(0, -4.2780000000000005, 0)
                                    if HITFLOOR then
                                        ApplyAoE(ROLLER.Position, 135, 45, 50, 120, false)
                                        ApplyAoE(ROLLER.Position, 25, 45, 50, 1200, true)
                                        CamShake(12, 25)
                                        for E = 1, 7 do
                                            for i = 1, 4 do
                                                WACKYEFFECT({
                                                    Time = 50,
                                                    EffectType = "Round Slash",
                                                    Size = VT(0, 0, 0),
                                                    Size2 = VT(E, 0, E) / 4,
                                                    Transparency = 0,
                                                    Transparency2 = 1,
                                                    CFrame = CF(ROLLER.Position) * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360))),
                                                    MoveToPos = nil,
                                                    RotationX = 0,
                                                    RotationY = 0,
                                                    RotationZ = 0,
                                                    Material = "Neon",
                                                    Color = C3(1, 1, 1),
                                                    SoundID = nil,
                                                    SoundPitch = nil,
                                                    SoundVolume = nil,
                                                    UseBoomerangMath = true,
                                                    Boomerang = 0,
                                                    SizeBoomerang = 10
                                                })
                                            end
                                        end
                                        for i = 1, 12 do
                                            WACKYEFFECT({
                                                Time = 75 - i * 4,
                                                EffectType = "Sphere",
                                                Size = VT(0, 0, 0),
                                                Size2 = VT(5, 5, 5) + VT(i, i, i) * 25,
                                                Transparency = 0,
                                                Transparency2 = 1,
                                                CFrame = CF(ROLLER.Position),
                                                MoveToPos = nil,
                                                RotationX = 0,
                                                RotationY = 0,
                                                RotationZ = 0,
                                                Material = "Neon",
                                                Color = SKILLTEXTCOLOR,
                                                SoundID = 1368637781,
                                                SoundPitch = MRANDOM(8, 20) / 10,
                                                SoundVolume = 10,
                                                UseBoomerangMath = false,
                                                Boomerang = 0,
                                                SizeBoomerang = 0
                                            })
                                        end
                                        local COLISSION, POS = Raycast(ROLLER.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 12, Character)
                                        if COLISSION then
                                            for i = 1, 12 do
                                                WACKYEFFECT({
                                                    Time = 20 + i * 15,
                                                    EffectType = "Wave",
                                                    Size = VT(15, 0, 15),
                                                    Size2 = VT(160, 15, 160),
                                                    Transparency = 0.6,
                                                    Transparency2 = 1,
                                                    CFrame = CF(POS) * ANGLES(RAD(0), RAD(MRANDOM(0, 360)), RAD(0)) * ANGLES(RAD(MRANDOM(-15, 15)), RAD(MRANDOM(0, 360)), RAD(0)),
                                                    MoveToPos = nil,
                                                    RotationX = 0.2,
                                                    RotationY = 0,
                                                    RotationZ = 0,
                                                    Material = "Neon",
                                                    Color = C3(1, 1, 1),
                                                    SoundID = nil,
                                                    SoundPitch = MRANDOM(9, 11) / 10,
                                                    SoundVolume = MRANDOM(9, 11) / 2,
                                                    UseBoomerangMath = true,
                                                    Boomerang = 0,
                                                    SizeBoomerang = 22
                                                })
                                            end
                                        end
                                        if KABLAMO == true then
                                            SUICIDED = true
                                            FACE:Remove()
                                            ROLLER.Transparency = 1
                                            NECKFIRE.Enabled = false
                                            Debris:AddItem(ROLLER, 5)
                                            for i = 1, 25 do
                                                local LEFTOVER = CreatePart(3, workspace, "Pebble", 0, 0, BRICKC("Pearl"), "ROLLERDAH", VT(13.02 * (MRANDOM(8, 12) / 10), 9.3 * (MRANDOM(8, 12) / 10), 12.09 * (MRANDOM(8, 12) / 10)) / 1.5 / 2, false)
                                                LEFTOVER.CanCollide = true
                                                LEFTOVER.CFrame = ROLLER.CFrame * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)))
                                                LEFTOVER.Velocity = CF(LEFTOVER.Position - VT(0, 6, 0), LEFTOVER.CFrame * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360))) * CF(0, 5, 0).p).lookVector * MRANDOM(50, 320)
                                                Debris:AddItem(LEFTOVER, 8)
                                            end
                                        end
                                        break
                                    else
                                        WACKYEFFECT({
                                            Time = 15 + i,
                                            EffectType = "Wave",
                                            Size = VT(15, 0, 15),
                                            Size2 = VT(25, 5, 25),
                                            Transparency = 0.8,
                                            Transparency2 = 1,
                                            CFrame = ROLLER.CFrame * CF(0, 0, -7) * ANGLES(RAD(90), RAD(MRANDOM(0, 360)), RAD(MRANDOM(-5, 5))),
                                            MoveToPos = nil,
                                            RotationX = 0.1,
                                            RotationY = 1,
                                            RotationZ = -0.1,
                                            Material = "Neon",
                                            Color = C3(1, 1, 1),
                                            SoundID = nil,
                                            SoundPitch = nil,
                                            SoundVolume = nil,
                                            UseBoomerangMath = false,
                                            Boomerang = 0,
                                            SizeBoomerang = 15
                                        })
                                    end
                                end
                                wait(1)
                                BEHAVIOUR = "Idle"
                            end
                            if BEHAVIOUR ~= "Idle" then
                                TARGETLOC = CF(ROLLER.Position) * ANGLES(RAD(0), RAD(ROLLER.Orientation.Y), RAD(0))
                            end
                            FACE.CFrame = ROLLER.CFrame * CF(0, -4.2780000000000005, 0)
                        until SUICIDED == true
                    end))
                    for i = 1, 12 do
                        local RANGE = 6000
                        if BEHAVIOUR == "Attack" then
                            repeat
                                wait()
                            until BEHAVIOUR ~= "Attack"
                        end
                        for index, CHILD in pairs(workspace:GetDescendants()) do
                            if CHILD.ClassName == "Model" and CHILD ~= Character and CHILD:FindFirstChild("AboutToEerin") == nil then
                                local HUM = CHILD:FindFirstChildOfClass("Humanoid")
                                if HUM then
                                    local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
                                    if TORSO and 0 < HUM.Health and RANGE >= (TORSO.Position - ROLLER.Position).Magnitude then
                                        RANGE = (TORSO.Position - ROLLER.Position).Magnitude
                                        TARGET = TORSO
                                    end
                                end
                            end
                        end
                        if TARGET then
                            BEHAVIOUR = "Circle"
                        else
                            BEHAVIOUR = "Idle"
                        end
                        wait(1)
                    end
                    KABLAMO = true
                    repeat
                        local RANGE = 6.0E73
                        if BEHAVIOUR == "Attack" then
                            repeat
                                wait()
                            until BEHAVIOUR ~= "Attack"
                        end
                        for index, CHILD in pairs(workspace:GetDescendants()) do
                            if CHILD.ClassName == "Model" and CHILD ~= Character and CHILD:FindFirstChild("AboutToEerin") == nil then
                                local HUM = CHILD:FindFirstChildOfClass("Humanoid")
                                if HUM then
                                    local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
                                    if TORSO and 0 < HUM.Health and RANGE >= (TORSO.Position - ROLLER.Position).Magnitude then
                                        RANGE = (TORSO.Position - ROLLER.Position).Magnitude
                                        TARGET = TORSO
                                    end
                                end
                            end
                        end
                        if TARGET then
                            BEHAVIOUR = "Circle"
                        else
                            BEHAVIOUR = "Idle"
                        end
                        wait(1)
                    until SUICIDED == true
                end))
                for E = 1, 3 do
                    for i = 1, 4 do
                        WACKYEFFECT({
                            Time = 50,
                            EffectType = "Round Slash",
                            Size = VT(0, 0, 0),
                            Size2 = VT(E, 0, E) / 4,
                            Transparency = 0,
                            Transparency2 = 1,
                            CFrame = CF(RootPart.Position) * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360))),
                            MoveToPos = nil,
                            RotationX = 0,
                            RotationY = 0,
                            RotationZ = 0,
                            Material = "Neon",
                            Color = C3(1, 1, 1),
                            SoundID = nil,
                            SoundPitch = nil,
                            SoundVolume = nil,
                            UseBoomerangMath = true,
                            Boomerang = 0,
                            SizeBoomerang = 10
                        })
                    end
                end
                CreateSound(401056199, Effects, 7, 0.8, false)
                CreateSound(1664711478, Effects, 7, 0.8, false)
                for i = 1, 7 do
                    WACKYEFFECT({
                        Time = 45 - i * 4,
                        EffectType = "Sphere",
                        Size = VT(0, 0, 0),
                        Size2 = VT(5, 5, 5) + VT(i, i, i) * 25,
                        Transparency = 0,
                        Transparency2 = 1,
                        CFrame = CF(RootPart.Position),
                        MoveToPos = nil,
                        RotationX = 0,
                        RotationY = 0,
                        RotationZ = 0,
                        Material = "Neon",
                        Color = SKILLTEXTCOLOR,
                        SoundID = nil,
                        SoundPitch = MRANDOM(8, 20) / 10,
                        SoundVolume = 6,
                        UseBoomerangMath = false,
                        Boomerang = 0,
                        SizeBoomerang = 0
                    })
                end
                for i = 1, 15 do
                    WACKYEFFECT({
                        Time = 35 - i,
                        EffectType = "Wave",
                        Size = VT(12, 0, 12),
                        Size2 = VT(13 + i * 7, 5 + i * 3, 13 + i * 7),
                        Transparency = 0.3,
                        Transparency2 = 1,
                        CFrame = RootPart.CFrame * CF(0, 0, -4) * ANGLES(RAD(90), RAD(MRANDOM(0, 360)), RAD(MRANDOM(-5, 5))),
                        MoveToPos = nil,
                        RotationX = 0.1,
                        RotationY = 1,
                        RotationZ = -0.1,
                        Material = "Neon",
                        Color = C3(1, 1, 1),
                        SoundID = nil,
                        SoundPitch = nil,
                        SoundVolume = nil,
                        UseBoomerangMath = false,
                        Boomerang = 0,
                        SizeBoomerang = 15
                    })
                end
                for i = 0, 0.5, 0.1 / Animation_Speed do
                    Swait()
                    RootPart.CFrame = RootPart.CFrame * CF(0, 0, 1.2)
                    RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, -0.05) * ANGLES(RAD(-25), RAD(0), RAD(0)), 1 / Animation_Speed)
                    Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
                    RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(-12), RAD(5)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
                    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(90), RAD(12), RAD(-5)) * LEFTSHOULDERC0, 1 / Animation_Speed)
                    RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(-50), RAD(85), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
                    LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(-50), RAD(-85), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
                end
                HEADTURN = true
                UNANCHOR = true
                ATTACK = false
                Rooted = false
            end
            function Wave()
                ATTACK = true
                Rooted = true
                HEADTURN = false
                for i = 1, 100 do
                    Swait()
                    RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0 - 0.04 * SIN(SINE / 24), -0.15, -0.1 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(15), RAD(0 - 2.5 * SIN(SINE / 24)), RAD(0)), 1 / Animation_Speed)
                    Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-10 - 5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
                    RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(-12 + 2.5 * SIN(SINE / 12)), RAD(55 + 2.5 * SIN(SINE / 12) - 2.5 * COS(SINE / 6))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
                    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.8, 0.4) * ANGLES(RAD(170), RAD(0), RAD(-25 - 25 * SIN(i / 3))) * ANGLES(RAD(0), RAD(-45), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
                    RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.035 * SIN(SINE / 24) - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(20), RAD(85), RAD(0)) * ANGLES(RAD(-2 - 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
                    LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.035 * SIN(SINE / 24) - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(20), RAD(-85), RAD(0)) * ANGLES(RAD(-2 + 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
                end
                HEADTURN = true
                ATTACK = false
                Rooted = false
            end
            function Taunt()
                ATTACK = true
                Rooted = true
                HEADTURN = false
                local function E()
                    for i = 0, 0.45, 0.1 / Animation_Speed do
                        Swait()
                        RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, -0.035) * ANGLES(RAD(25), RAD(0), RAD(0)), 1 / Animation_Speed)
                        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(15), RAD(0), RAD(0)), 1 / Animation_Speed)
                        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(45), RAD(-12), RAD(5)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
                        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(45), RAD(12), RAD(-5)) * LEFTSHOULDERC0, 1 / Animation_Speed)
                        RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(35), RAD(85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
                        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(35), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
                    end
                end
                repeat
                    E()
                    for i = 0, 0.45, 0.1 / Animation_Speed do
                        Swait()
                        RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0.08, 0, 0) * ANGLES(RAD(0), RAD(5), RAD(0)), 1 / Animation_Speed)
                        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-35), RAD(0), RAD(0)), 1 / Animation_Speed)
                        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.65, 0) * ANGLES(RAD(160), RAD(-12), RAD(35)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
                        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.65, 0) * ANGLES(RAD(160), RAD(12), RAD(-35)) * LEFTSHOULDERC0, 1 / Animation_Speed)
                        RightHip.C0 = Clerp(RightHip.C0, CF(1, -1.07, 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(3), RAD(0), RAD(0)), 1 / Animation_Speed)
                        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.9299999999999999, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 1 / Animation_Speed)
                    end
                    E()
                    for i = 0, 0.45, 0.1 / Animation_Speed do
                        Swait()
                        RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(-0.08, 0, 0) * ANGLES(RAD(0), RAD(-5), RAD(0)), 1 / Animation_Speed)
                        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-35), RAD(0), RAD(0)), 1 / Animation_Speed)
                        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.65, 0) * ANGLES(RAD(160), RAD(-12), RAD(35)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
                        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.65, 0) * ANGLES(RAD(160), RAD(12), RAD(-35)) * LEFTSHOULDERC0, 1 / Animation_Speed)
                        RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.9299999999999999, 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 1 / Animation_Speed)
                        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1.07, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(3), RAD(0), RAD(0)), 1 / Animation_Speed)
                    end
                until KEYHOLD == false
                HEADTURN = true
                ATTACK = false
                Rooted = false
            end
            function MouseDown(Mouse)
                if ATTACK == false then
                end
            end
            function MouseUp(Mouse)
                HOLD = false
            end
            function KeyDown(Key)
                KEYHOLD = true
                if Key == "z" and ATTACK == false then
                    LeapingPumpkin()
                end
                if Key == "x" and ATTACK == false then
                    Rollout()
                end
                if Key == "c" and ATTACK == false then
                    Trashing()
                end
                if Key == "v" and ATTACK == false then
                    Incinithrower()
                end
                if Key == "e" and ATTACK == false then
                    Zoom()
                end
                if Key == "q" and ATTACK == false then
                    Hothead()
                end
                if Key == "t" and ATTACK == false then
                    Taunt()
                end
                if Key == "m" and ATTACK == false then
                    if Speed == 16 then
                        Speed = 50
                    elseif Speed == 50 then
                        Speed = 16
                    end
                end
                if Key == "p" and ATTACK == false then
                    Wave()
                end
                if Key == "n" and ATTACK == false then
                    if HEADTURN == true then
                        HEADTURN = false
                    elseif HEADTURN == false then
                        HEADTURN = true	
                    end
                end
            end
            function KeyUp(Key)
                KEYHOLD = false
            end
            Mouse.NewButton1Down:connect(function(NEWKEY)
                MouseDown(NEWKEY)
            end)
            Mouse.NewButton1Up:connect(function(NEWKEY)
                MouseUp(NEWKEY)
            end)
            Mouse.KeyDown:connect(function(NEWKEY)
                KeyDown(NEWKEY)
            end)
            Mouse.KeyUp:connect(function(NEWKEY)
                KeyUp(NEWKEY)
            end)
            function unanchor()
                for _, c in pairs(Character:GetChildren()) do
    
                end
                if UNANCHOR == true then
                    RootPart.Anchored = false
                else
                    RootPart.Anchored = true
                end
            end
            Humanoid.Changed:connect(function(Jump)
                if Jump == "Jump" and Disable_Jump == true then
                    Humanoid.Jump = false
                end
            end)
            local TIMESTAMP = 0
            local FIXING = false
            while true do
                Swait()
                for _, c in pairs(Character:GetChildren()) do
                    if c.ClassName == "Part" then
                        if c:FindFirstChildOfClass("BodyPosition") then
                            c:FindFirstChildOfClass("BodyPosition"):remove()
                        end
                    end
                end
                script.Parent = WEAPONGUI
                ANIMATE.Parent = nil
                for _, v in next, Humanoid:GetPlayingAnimationTracks() do
                    v:Stop()
                end
                SINE = SINE + CHANGE
                local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
                local TORSOVERTICALVELOCITY = RootPart.Velocity.y
                local HITFLOOR = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 4, Character)
                local WALKSPEEDVALUE = 8 / (Humanoid.WalkSpeed / 16)
                local SPEED = WALKSPEEDVALUE
                if SPEED > 2 then
                    SPEED = 2
                end
                if ANIM == "Walk" and TORSOVELOCITY > 1 then
                    RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, 0.1 * COS(SINE / (WALKSPEEDVALUE / 2))) * ANGLES(RAD(0), RAD(0), RAD(0)), 2 / Animation_Speed)
                    Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(0), RAD(0), RAD(0) - Head.RotVelocity.Y / 30), 0.6 / Animation_Speed)
                    RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 0.875 - 0.125 * SIN(SINE / WALKSPEEDVALUE) - 0.15 * COS(SINE / WALKSPEEDVALUE * 2), 0.25 * SIN(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10 + 50 * COS(SINE / WALKSPEEDVALUE))), 0.6 * SPEED / Animation_Speed)
                    LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 0.875 + 0.125 * SIN(SINE / WALKSPEEDVALUE) - 0.15 * COS(SINE / WALKSPEEDVALUE * 2), -0.25 * SIN(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-10 + 50 * COS(SINE / WALKSPEEDVALUE))), 0.6 * SPEED / Animation_Speed)
                elseif ANIM ~= "Walk" or TORSOVELOCITY < 1 then
                    RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
                    Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
                    RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.7 / Animation_Speed)
                    LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.7 / Animation_Speed)
                end
                if TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil then
                    ANIM = "Jump"
                    if ATTACK == false then
                        RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
                        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-25), RAD(0), RAD(0)), 1 / Animation_Speed)
                        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-35), RAD(0), RAD(25 + 10 * COS(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
                        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-35), RAD(0), RAD(-25 - 10 * COS(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
                        RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.4, -0.6) * ANGLES(RAD(1), RAD(90), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
                        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
                    end
                elseif TORSOVERTICALVELOCITY < -1 and HITFLOOR == nil then
                    ANIM = "Fall"
                    if ATTACK == false then
                        RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(15), RAD(0), RAD(0)), 1 / Animation_Speed)
                        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(15), RAD(0), RAD(0)), 1 / Animation_Speed)
                        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(35 - 4 * COS(SINE / 6)), RAD(0), RAD(45 + 10 * COS(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
                        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(35 - 4 * COS(SINE / 6)), RAD(0), RAD(-45 - 10 * COS(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
                        RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.3, -0.7) * ANGLES(RAD(-25 + 5 * SIN(SINE / 12)), RAD(90), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
                        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.8, -0.3) * ANGLES(RAD(-10), RAD(-80), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
                    end
                elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then
                    ANIM = "Idle"
                    if ATTACK == false then
                        RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0 - 0.04 * SIN(SINE / 24), 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0 - 2.5 * SIN(SINE / 24)), RAD(0)), 1 / Animation_Speed)
                        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0 - 5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
                        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(-12 + 2.5 * SIN(SINE / 12)), RAD(55 + 2.5 * SIN(SINE / 12) - 2.5 * COS(SINE / 6))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
                        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(12 - 2.5 * SIN(SINE / 12)), RAD(-55 - 2.5 * SIN(SINE / 12) - 2.5 * COS(SINE / 6))) * LEFTSHOULDERC0, 1 / Animation_Speed)
                        RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.035 * SIN(SINE / 24) - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-2 - 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
                        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.035 * SIN(SINE / 24) - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2 + 2.5 * SIN(SINE / 24)), RAD(0), RAD(0)), 1 / Animation_Speed)
                    end
                elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
                    ANIM = "Walk"
                    if ATTACK == false then
                        if Humanoid.WalkSpeed < 25 then
                            RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, -0.05) * ANGLES(RAD(5), RAD(0), RAD(-7 * COS(SINE / WALKSPEEDVALUE))), 1 / Animation_Speed)
                            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(5 - 1 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(7 * COS(SINE / WALKSPEEDVALUE))), 1 / Animation_Speed)
                            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.22 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(0), RAD(50 - 5 * SIN(SINE / (WALKSPEEDVALUE / 2)))) * ANGLES(RAD(60 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
                            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0.22 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(0), RAD(-50 + 5 * SIN(SINE / (WALKSPEEDVALUE / 2)))) * ANGLES(RAD(-60 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
                            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 2 / Animation_Speed)
                            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 2 / Animation_Speed)
                        else
                            RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(-35), RAD(0), RAD(0)), 1 / Animation_Speed)
                            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-15), RAD(0), RAD(0)), 1 / Animation_Speed)
                            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.6, 0.4) * ANGLES(RAD(-125 + 5 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(-12 + 5 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(5)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
                            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.35, 0.6, 0.4) * ANGLES(RAD(-125 + 5 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(12 - 5 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(-5)) * LEFTSHOULDERC0, 1 / Animation_Speed)
                            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(-45), RAD(85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
                            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(-45), RAD(-85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
                        end
                    end
                end
                if HEADTURN == true and ANIM == "Idle" then
                    if NECKK then
                        NECKK:Remove()
                        NECKK = nil
                    end
                    if Mouse.Hit.p then
                        Head.CFrame = CF(Head.CFrame * CF(0, 0.5, 0).p) * ANGLES(RAD(0), RAD(Head.Orientation.Y), RAD(0))
                        Head.CFrame = Clerp(Head.CFrame, CF(Head.Position, Mouse.Hit.p), 0.1)
                    end
    
                else
                    if NECKK == nil then
                        NECKK = weldBetween(Head, Head)
                    else
                        NECKK.C1 = Clerp(NECKK.C1, CF(0, 0.55, 0), 0.2)
                    end
    
                end
                unanchor()
                Humanoid.MaxHealth = 1000
                Humanoid.Health = 1000
                if Rooted == false then
                    Disable_Jump = false
                    Humanoid.WalkSpeed = Speed
                elseif Rooted == true then
                    Disable_Jump = true
                    Humanoid.WalkSpeed = 0
                end
                BMUSIC.SoundId = "rbxassetid://" .. SONGID
                BMUSIC.Looped = true
                BMUSIC.Pitch = PITCH
                BMUSIC.Volume = VOLUME
                BMUSIC.Playing = true
                BMUSIC.EmitterSize = 50
                if BMUSIC.Parent ~= RootPart then
                    print("Fixing music")
                    BMUSIC = IT("Sound", RootPart)
                    BMUSIC.SoundId = "rbxassetid://" .. SONGID
                    BMUSIC.Looped = true
                    BMUSIC.Pitch = PITCH
                    BMUSIC.Volume = VOLUME
                    BMUSIC.Playing = true
                    BMUSIC.EmitterSize = 50
                    BMUSIC.TimePosition = TIMESTAMP
                    FIXING = true
                elseif FIXING == false then
                    TIMESTAMP = BMUSIC.TimePosition
                else
                    FIXING = false
                end
                Humanoid.DisplayDistanceType = "None"
    
    
            end
    
    
        else
            game.StarterGui:SetCore("ChatMakeSystemMessage", {
                Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
                Color = Color3.fromRGB(255, 0, 0),
                TextSize = 20,
                Font = Enum.Font.Cartoon
            });
        end
end)

frees:Button("Crewmate", "funny button go brr", function()
            if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
            game.StarterGui:SetCore("ChatMakeSystemMessage", {
                Text = "when forEach is sus\nwhen the imposter is sus 🤔🤔",
                Color = Color3.fromRGB(255, 0, 0),
                TextSize = 20,
                Font = Enum.Font.Cartoon
            });
            sound = Instance.new("Sound",game.Players.LocalPlayer.Character)
            sound.Name = "Among DRIP >:)"
            sound.SoundId = "rbxassetid://6119798028"
            sound.Volume = 2
            sound:Play()
            sound.Looped = true
    
            Player = game:GetService("Players").LocalPlayer
            PlayerGui = Player.PlayerGui
            Cam = workspace.CurrentCamera
            Backpack = Player.Backpack
            Character = game:GetService("Players").LocalPlayer.Character.Raw
            Humanoid = Character.Humanoid
            Mouse = Player:GetMouse()
            RootPart = Character.HumanoidRootPart
            Torso = Character.Torso
            Head = Character.Head
            RightArm = Character["Right Arm"]
            LeftArm = Character["Left Arm"]
            RightLeg = Character["Right Leg"]
            LeftLeg = Character["Left Leg"]
            RootJoint = RootPart.RootJoint
            Neck = Torso.Neck
            RightShoulder = Torso["Right Shoulder"]
            LeftShoulder = Torso["Left Shoulder"]
            RightHip = Torso["Right Hip"]
            LeftHip = Torso["Left Hip"]
            Equipped = false
    
            -------------------------------------------------------------------------
    
            weld = function(parent, part0, part1, c0)
                local weld = it("Weld")
                weld.Parent = parent
                weld.Part0 = part0
                weld.Part1 = part1
                weld.C0 = c0
                return weld
            end
    
            function unanchor()
                if UNANCHOR == true then
                    g = CharacterA:GetChildren()
                    for i = 1, #g do
                        if g[i].ClassName == "Part" then
                            g[i].Anchored = false
                        end
                    end
                end
            end
    
            IT = Instance.new
            CF = CFrame.new
            VT = Vector3.new
            RAD = math.rad
            C3 = Color3.new
            UD2 = UDim2.new
            BRICKC = BrickColor.new
            ANGLES = CFrame.Angles
            EULER = CFrame.fromEulerAnglesXYZ
            COS = math.cos
            ACOS = math.acos
            SIN = math.sin
            ASIN = math.asin
            ABS = math.abs
            MRANDOM = math.random
            FLOOR = math.floor
            --//=================================\\
            --|| 	      USEFUL VALUES
            --\\=================================//
    
            Animation_Speed = 1.8
            Frame_Speed = 0.016666666666666666
            local FORCERESET = false
            Frame_Speed = 1 / 80 -- (1 / 60) OR (1 / 80)
            local Speed = 25
            local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
            local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
            local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
            local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
            local DAMAGEMULTIPLIER = 1
            local ANIM = "Idle"
            local ATTACK = false
            local HOLD = false
            local Rooted = false
            local SINE = 0
            local SIZE = 1
            local UserInputService = game:GetService("UserInputService")
            local KEYHOLD = false
            local CHANGE = 2 / Animation_Speed
            local WALKINGANIM = false
            local VALUE1 = false
            local VALUE2 = false
            local ROBLOXIDLEANIMATION = IT("Animation")
            ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
            ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
            local ANIMATOR = Humanoid.Animator
            local ANIMATE = Character:FindFirstChild("Animate")
            local UNANCHOR = true
    
            function Swait(NUMBER)
                if NUMBER == 0 or NUMBER == nil then
                    game:GetService("RunService").RenderStepped:wait()
                else
                    for i = 1, NUMBER do
                        game:GetService("RunService").RenderStepped:wait()
                    end
                end
            end
    
            function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
                return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
            end
    
            function QuaternionFromCFrame(cf)
                local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
                local trace = m00 + m11 + m22
                if trace > 0 then 
                    local s = math.sqrt(1 + trace)
                    local recip = 0.5 / s
                    return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
                else
                    local i = 0
                    if m11 > m00 then
                        i = 1
                    end
                    if m22 > (i == 0 and m00 or m11) then
                        i = 2
                    end
                    if i == 0 then
                        local s = math.sqrt(m00 - m11 - m22 + 1)
                        local recip = 0.5 / s
                        return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
                    elseif i == 1 then
                        local s = math.sqrt(m11 - m22 - m00 + 1)
                        local recip = 0.5 / s
                        return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
                    elseif i == 2 then
                        local s = math.sqrt(m22 - m00 - m11 + 1)
                        local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
                    end
                end
            end
    
            function QuaternionToCFrame(px, py, pz, x, y, z, w)
                local xs, ys, zs = x + x, y + y, z + z
                local wx, wy, wz = w * xs, w * ys, w * zs
                local xx = x * xs
                local xy = x * ys
                local xz = x * zs
                local yy = y * ys
                local yz = y * zs
                local zz = z * zs
                return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
            end
    
            function QuaternionSlerp(a, b, t)
                local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
                local startInterp, finishInterp;
                if cosTheta >= 0.0001 then
                    if (1 - cosTheta) > 0.0001 then
                        local theta = ACOS(cosTheta)
                        local invSinTheta = 1 / SIN(theta)
                        startInterp = SIN((1 - t) * theta) * invSinTheta
                        finishInterp = SIN(t * theta) * invSinTheta
                    else
                        startInterp = 1 - t
                        finishInterp = t
                    end
                else
                    if (1 + cosTheta) > 0.0001 then
                        local theta = ACOS(-cosTheta)
                        local invSinTheta = 1 / SIN(theta)
                        startInterp = SIN((t - 1) * theta) * invSinTheta
                        finishInterp = SIN(t * theta) * invSinTheta
                    else
                        startInterp = t - 1
                        finishInterp = t
                    end
                end
                return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
            end
    
            function Clerp(a, b, t)
                local qa = {QuaternionFromCFrame(a)}
                local qb = {QuaternionFromCFrame(b)}
                local ax, ay, az = a.x, a.y, a.z
                local bx, by, bz = b.x, b.y, b.z
                local _t = 1 - t
                return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
            end
            -- weldtest
    
    
            --end
            while true do
                Swait()
                if Character:FindFirstChildOfClass("Humanoid") == nil then
                    Humanoid = IT("Humanoid",Character)
                end
                for _,v in next, Humanoid:GetPlayingAnimationTracks() do
                    v:Stop();
                end
    
                local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
                local TORSOVERTICALVELOCITY = RootPart.Velocity.y
                local NameClan = 0
                local HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 5, Character)
                local WALKSPEEDVALUE = 20 / (Humanoid.WalkSpeed / 16)
                SINE = SINE + CHANGE
                if TORSOVERTICALVELOCITY > 1 and ATTACK == false and Equipped == false and HITFLOOR == nil then
                    ANIM = "Jump"
                    RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-40), RAD(0), RAD(20)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
                    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-40), RAD(0), RAD(-20)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
                    RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.3) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-20)), 0.2 / Animation_Speed)
                    LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.3) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(20)), 0.2 / Animation_Speed)
                elseif TORSOVERTICALVELOCITY < -1 and ATTACK == false and Equipped == false and HITFLOOR == nil then
                    ANIM = "Fall"
                    RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
                    Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(20), RAD(0), RAD(0)), 0.2 / Animation_Speed)
                    RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(60)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
                    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-60)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
                    RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 0.2 / Animation_Speed)
                    LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.2 / Animation_Speed)
                elseif TORSOVELOCITY < 1 and ATTACK == false and Equipped == false and HITFLOOR ~= nil then
                    ANIM = "Idle"
    
    
                    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.4, 0.5, 1) * ANGLES(RAD(0+0* COS(SINE / 10)), RAD(0), RAD(0)) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
                    RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.4, 0.5, 1) * ANGLES(RAD(0+0* COS(SINE / 10)), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.55 / Animation_Speed)
                    RightHip.C0 = Clerp(RightHip.C0, CF(1, -1,-0) * ANGLES(RAD(0+0 * COS(SINE / 4)), RAD(84), RAD(0)), 0.25 / Animation_Speed)
                    LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1,-0) * ANGLES(RAD(-0-0 * COS(SINE / 4)), RAD(-84), RAD(0)), 0.25 / Animation_Speed)
                elseif TORSOVELOCITY > 1 and Equipped == false and HITFLOOR ~= nil then
                    ANIM = "Walk"
    
                    RightHip.C0 = Clerp(RightHip.C0, CF(1, -1,-0) * ANGLES(RAD(-11+23 * COS(SINE / 4)), RAD(84), RAD(0)), 0.25 / Animation_Speed)
                    LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1,-0) * ANGLES(RAD(-11-23 * COS(SINE / 4)), RAD(-84), RAD(0)), 0.25 / Animation_Speed)
    
                end
            end
            unanchor()
    
        else
            game.StarterGui:SetCore("ChatMakeSystemMessage", {
                Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
                Color = Color3.fromRGB(255, 0, 0),
                TextSize = 20,
                Font = Enum.Font.Cartoon
            });
        end
end)

frees:Button("Creeper", "funny button go brr", function()
            if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
            game.Players.LocalPlayer.Character.Raw["Left Arm"]:Destroy()
            game.Players.LocalPlayer.Character.Raw["Right Arm"]:Destroy()
        else
            game.StarterGui:SetCore("ChatMakeSystemMessage", {
                Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
                Color = Color3.fromRGB(255, 0, 0),
                TextSize = 20,
                Font = Enum.Font.Cartoon
            });
        end
end)

frees:Button("Break Right Leg", "funny button go brr", function()
    if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
    local Player = game.Players.LocalPlayer
    for i,v in pairs(game.Players.LocalPlayer.Character.Raw:GetDescendants()) do
        if v:IsA("Motor6D") and v.Name == "Right Hip" then
            local Socket = Instance.new("BallSocketConstraint")
            local a1 = Instance.new("Attachment")
            local a2 = Instance.new("Attachment")
            a1.Parent = v.Part0
            a2.Parent = v.Part1
            Socket.Parent = v.Parent
            Socket.Attachment0 = a1
            Socket.Attachment1 = a2
            a1.CFrame = v.C0
            a2.CFrame = v.C1
            Socket.LimitsEnabled = false
            Socket.TwistLimitsEnabled = false
            v:Destroy()
        end

        
        end
else
    game.StarterGui:SetCore("ChatMakeSystemMessage", {
        Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
        Color = Color3.fromRGB(255, 0, 0),
        TextSize = 20,
        Font = Enum.Font.Cartoon
    });
end
end)

frees:Button("Break Right Arm", "funny button go brr", function()
            if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
            local Player = game.Players.LocalPlayer
            for i,v in pairs(game.Players.LocalPlayer.Character.Raw:GetDescendants()) do
                if v:IsA("Motor6D") and v.Name == "Right Shoulder" then
                    local Socket = Instance.new("BallSocketConstraint")
                    local a1 = Instance.new("Attachment")
                    local a2 = Instance.new("Attachment")
                    a1.Parent = v.Part0
                    a2.Parent = v.Part1
                    Socket.Parent = v.Parent
                    Socket.Attachment0 = a1
                    Socket.Attachment1 = a2
                    a1.CFrame = v.C0
                    a2.CFrame = v.C1
                    Socket.LimitsEnabled = false
                    Socket.TwistLimitsEnabled = false
                    v:Destroy()
                end
        
                
                end
        else
            game.StarterGui:SetCore("ChatMakeSystemMessage", {
                Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
                Color = Color3.fromRGB(255, 0, 0),
                TextSize = 20,
                Font = Enum.Font.Cartoon
            });
        end
end)

frees:Button("Break Left Leg", "funny button go brr", function()
            if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
            local Player = game.Players.LocalPlayer
            for i,v in pairs(game.Players.LocalPlayer.Character.Raw:GetDescendants()) do
                if v:IsA("Motor6D") and v.Name == "Left Hip" then
                    local Socket = Instance.new("BallSocketConstraint")
                    local a1 = Instance.new("Attachment")
                    local a2 = Instance.new("Attachment")
                    a1.Parent = v.Part0
                    a2.Parent = v.Part1
                    Socket.Parent = v.Parent
                    Socket.Attachment0 = a1
                    Socket.Attachment1 = a2
                    a1.CFrame = v.C0
                    a2.CFrame = v.C1
                    Socket.LimitsEnabled = false
                    Socket.TwistLimitsEnabled = false
                    v:Destroy()
                end
    
                
                end
        else
            game.StarterGui:SetCore("ChatMakeSystemMessage", {
                Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
                Color = Color3.fromRGB(255, 0, 0),
                TextSize = 20,
                Font = Enum.Font.Cartoon
            });
        end
end)
frees:Button("Break Left Arm", "funny button go brr", function()
            if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
            local Player = game.Players.LocalPlayer
            for i,v in pairs(game.Players.LocalPlayer.Character.Raw:GetDescendants()) do
                if v:IsA("Motor6D") and v.Name == "Left Shoulder" then
                    local Socket = Instance.new("BallSocketConstraint")
                    local a1 = Instance.new("Attachment")
                    local a2 = Instance.new("Attachment")
                    a1.Parent = v.Part0
                    a2.Parent = v.Part1
                    Socket.Parent = v.Parent
                    Socket.Attachment0 = a1
                    Socket.Attachment1 = a2
                    a1.CFrame = v.C0
                    a2.CFrame = v.C1
                    Socket.LimitsEnabled = false
                    Socket.TwistLimitsEnabled = false
                    v:Destroy()
                end
                
                
                end
        else
            game.StarterGui:SetCore("ChatMakeSystemMessage", {
                Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
                Color = Color3.fromRGB(255, 0, 0),
                TextSize = 20,
                Font = Enum.Font.Cartoon
            });
        end
end)

frees:Button("Break Limbs", "funny button go brr", function()
    	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		local Player = game.Players.LocalPlayer
		for i,v in pairs(game.Players.LocalPlayer.Character.Raw:GetDescendants()) do
			if v:IsA("Motor6D") and v.Parent.Name ~= "HumanoidRootPart" and v.Name ~= "Neck" then
				local Socket = Instance.new("BallSocketConstraint")
				local a1 = Instance.new("Attachment")
				local a2 = Instance.new("Attachment")
				a1.Parent = v.Part0
				a2.Parent = v.Part1
				Socket.Parent = v.Parent
				Socket.Attachment0 = a1
				Socket.Attachment1 = a2
				a1.CFrame = v.C0
				a2.CFrame = v.C1
				Socket.LimitsEnabled = true
				Socket.TwistLimitsEnabled = true
				v:Destroy()
			end

			Player.Character.Humanoid.Sit = true
		end
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
end)

frees:Button("Billie Eilish", "funny button go brr", function()
            if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then

            local plr = game:GetService("Players").LocalPlayer
            local char = plr.Character.Raw
            if char:FindFirstChild("Animate") then
                char.Animate:Destroy()
            end
            local hum = char:FindFirstChildOfClass("Humanoid")
            local tors = char.Torso
            local head = char.Head
            local rootpart = char.HumanoidRootPart
            local RS = tors["Right Shoulder"]
            local LS = tors["Left Shoulder"]
            local RH = tors["Right Hip"]
            local LH = tors["Left Hip"]
            local neck = tors.Neck
            local rootj = rootpart.RootJoint
            local RSnor = CFrame.new(1, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
            local LSnor = CFrame.new(-1, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
            local RHnor = CFrame.new(1, -1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
            local LHnor = CFrame.new(-1, -1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
            local necknor = CFrame.new(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
            local rootjnor = CFrame.new(0, 0, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
            local sine = 0
            local music = Instance.new("Sound")
            music.Parent = tors
            local timepos = 0
            local attack = false
            local rooted = false
            local playing = true
            local speed = 16
    
            local nokill = {
                "mrfunnylaughs4",
                "v_Sado"
            }
    
            local wig = Instance.new("Part")
            wig.Size = Vector3.new(1.4, 1.99, 0.84)
            wig.Parent = nil
            local mesh = Instance.new("SpecialMesh")
            mesh.MeshType = Enum.MeshType.FileMesh
            mesh.MeshId = "rbxassetid://952995462"
            mesh.Scale = Vector3.new(1.44, 1.4, 1.22)
            mesh.TextureId = "rbxassetid://949743130"
            mesh.VertexColor = Vector3.new(1, 0.839, 0.73)
            mesh.Parent = wig
            local weld = Instance.new("Weld")
            weld.Part0 = wig
            weld.Part1 = head
            weld.C1 = CFrame.new(0, -0.8, 0.25)
            weld.Parent = wig
    
            local rem = Instance.new("RemoteEvent")
            rem.Name = "Events"
    --[[
    local Player = game:GetService("Players").LocalPlayer
        local Event = script:WaitForChild("UserInput_Event")
     
        local Mouse = Player:GetMouse()
        local UIS = game:GetService("UserInputService")
        local input = function(io,a)
            if a then return end
            --Since InputObject is a client-side instance, we create and pass table instead
            Event:FireTab({KeyCode=io.KeyCode,UserInputType=io.UserInputType,UserInputState=io.UserInputState,Hit=Mouse.Hit,Target=Mouse.Target})
        end
        UIS.InputBegan:Connect(input)
        UIS.InputEnded:Connect(input)
     
        local h,t
        --Give the Tab mouse data 30 times every second, but only if the values changed
        --If player is not moving their mouse, client won't fire events
        while wait(1/30) do
            if h~=Mouse.Hit or t~=Mouse.Target then
                h,t=Mouse.Hit,Mouse.Target
                Event:FireTab({isMouse=true,Target=t,Hit=h})
            end
        ]]--,plr.Character)	
            rem.OnTabEvent:Connect(function(player, key)
                if player == plr then
                    if attack == false then
                        if key == "t" then
                            local sound = Instance.new("Sound")
                            sound.SoundId = "rbxassetid://145757437"
                            sound.Volume = 10
                            sound.Parent = head
                            local effect = Instance.new("PitchShiftSoundEffect")
                            effect.Octave = 1.75
                            effect.Parent = sound
                            sound:Play()
                            for i = 1, 120 do
                                game:GetService("RunService").Stepped:Wait()
                                head.Size = Vector3.new(2 + 1 * math.sin(sine / 5), 1 + 1 * math.sin(sine / 5), 1 + 1 * math.sin(sine / 5)) 
                                neck.C0 = necknor * CFrame.new(0, 0, math.sin(sine / 5))
                            end
                            head.Size = Vector3.new(2, 1, 1)
                        end
                        if key == "r" then
                            attack = true
                            rooted = true
                            playing = false
                            local scream = Instance.new("Sound")
                            scream.SoundId = "rbxassetid://176238381"
                            scream.Parent = head
                            scream:Play()
                            repeat
                                game:GetService("RunService").Stepped:Wait()
                                RS.C0 = RSnor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
                                LS.C0 = LSnor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
                                RH.C0 = RHnor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
                                LH.C0 = LHnor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
                                rootj.C0 = rootjnor * CFrame.new(0, 0, 3 * math.sin(sine / 2)) * CFrame.Angles(sine / 2, 0, 0)
                                neck.C0 = necknor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
                            until scream.Playing == false
                            scream:Destroy()
                            rooted = false
                            if math.random(1, 3) == 1 then
                                local sound = Instance.new("Sound")
                                sound.SoundId = "rbxassetid://2878822762"
                                sound.Volume = 10
                                sound.PlaybackSpeed = 2
                                sound.Parent = head
                                sound:Play()
                                repeat
                                    game:GetService("RunService").Stepped:Wait()
                                    head.Size = Vector3.new(2 + 1 * math.sin(sine / 2), 1 + 1 * math.sin(sine / 2), 1 + 1 * math.sin(sine / 2)) 
                                    RS.C0 = RSnor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
                                    LS.C0 = LSnor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
                                    RH.C0 = RHnor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
                                    LH.C0 = LHnor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
                                    rootj.C0 = rootjnor
                                    neck.C0 = necknor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
                                until sound.Playing == false
                                head.Size = Vector3.new(2, 1, 1)
                            end
                            playing = true
                            attack = false
                        end
                        if key == "y" then
                            local sound = Instance.new("Sound")
                            sound.SoundId = "rbxassetid://3475233802"
                            sound.Volume = 10
                            sound.Parent = head
                            sound:Play()
                            local thing = head.Touched:Connect(function(hit)
                                local found = false
                                for i,v in pairs(nokill) do
                                    if game:GetService("Players"):FindFirstChild(v) then
                                        if hit:IsDescendantOf(game:GetService("Players")[v].Character) then
                                            found = true
                                        end
                                    end
                                end
                                if found == false and hit.Size.Magnitude < 300 then
                                    local parent = hit.Parent
                                    hit.Parent = nil
                                    wait(math.random(20, 50) / 10)
                                    hit.Anchored = false
                                    hit.BrickColor = BrickColor.new("Bright green")
                                    hit.CFrame = head.CFrame
                                    hit.Velocity = head.CFrame.LookVector * 150
                                    hit.Parent = parent
                                    local sound = Instance.new("Sound")
                                    sound.SoundId = "rbxassetid://704088758"
                                    sound.Volume = 10
                                    sound.Parent = head
                                    sound:Play()
                                end
                            end)
                            for i = 1, 180 do
                                game:GetService("RunService").Stepped:Wait()
                                head.Size = Vector3.new(20, 10, 10)
                                neck.C0 = necknor * CFrame.new(0, -10, 0)
                            end
                            thing:Disconnect()
                            head.Size = Vector3.new(2, 1, 1)
                        end
                        if key == "p" then
                            attack = true
                            playing = false
                            local sound = Instance.new("Sound")
                            sound.SoundId = "rbxassetid://2533880583"
                            sound.Volume = 3
                            sound.TimePosition = 20.15
                            sound.Parent = head
                            sound:Play()
                            wig.Parent = nil
                            local hat = Instance.new("Part")
                            hat.Name = "JevilHat"
                            hat.CanCollide = false
                            hat.Size = Vector3.new(1, 1, 1)
                            hat.Parent = char
                            local mesh = Instance.new("SpecialMesh")
                            mesh.MeshType = Enum.MeshType.FileMesh
                            mesh.MeshId = "rbxassetid://193760002"
                            mesh.TextureId = "rbxassetid://193760041"
                            mesh.VertexColor = Vector3.new(0.5, 0, 0.5)
                            mesh.Parent = hat
                            local weld = Instance.new("Weld")
                            weld.Part0 = head
                            weld.Part1 = hat
                            weld.C0 = CFrame.new(0, 0.5, 0.31)
                            weld.Parent = hat
                            for i,v in pairs(head:GetChildren()) do
                                if v:IsA("Decal") then
                                    local old = v.Texture
                                    v.Texture = "rbxassetid://241553801"
                                    coroutine.resume(coroutine.create(function()
                                        repeat game:GetService("RunService").Stepped:Wait() until sound.Playing == false or sound.TimePosition > 30.35
                                        v.Texture = old
                                    end))
                                end
                            end
                            local anything = Instance.new("Sound")
                            anything.SoundId = "rbxassetid://2544975373"
                            anything.Volume = 10
                            anything.Parent = head
                            anything:Play()
                            speed = 50
                            repeat
                                game:GetService("RunService").Stepped:Wait()
                                RS.C0 = RSnor * CFrame.Angles(0, 0, math.pi / 2 - 1 * math.sin(sine / 3))
                                LS.C0 = LSnor * CFrame.Angles(0, 0, -math.pi / 2 + 1 * math.sin(sine / 3))
                                RH.C0 = RHnor
                                LH.C0 = LHnor
                                rootj.C0 = rootjnor
                                neck.C0 = necknor
                            until sound.Playing == false or sound.TimePosition > 30.35
                            speed = 16
                            hat:Destroy()
                            wig.Parent = head
                            sound:Destroy()
                            playing = true
                            attack = false
                        end
                        if key == "f" then
                            attack = true
                            playing = false
                            speed = 150
                            local sound = Instance.new("Sound")
                            sound.SoundId = "rbxassetid://2259766079"
                            sound.Volume = 10
                            sound.Parent = head
                            sound:Play()
                            local timepos = 0
                            local thing = 1
                            repeat
                                game:GetService("RunService").Stepped:Wait()
                                if sound.Parent ~= head then
                                    local sound = Instance.new("Sound")
                                    sound.TimePosition = timepos
                                    sound.Parent = head
                                end
                                sound.Volume = 10
                                sound.PlaybackSpeed = 1
                                sound.Playing = true
                                timepos = sound.TimePosition
                                RS.C0 = RSnor * CFrame.Angles(0, 0, math.pi / 2 - 1 * math.sin(sine / (15 / thing)))
                                LS.C0 = LSnor * CFrame.Angles(0, 0, -math.pi / 2 + 1 * math.sin(sine / (15 / thing)))
                                RH.C0 = RHnor
                                LH.C0 = LHnor
                                rootj.C0 = rootjnor
                                neck.C0 = necknor
                                thing = thing + 0.005
                            until sound.Playing == false or sound.TimePosition > 10
                            local old = head.BrickColor
                            repeat
                                game:GetService("RunService").Stepped:Wait()
                                if sound.TimePosition > 20 then
                                    head.BrickColor = BrickColor.new("Sunrise")
                                end
                                sound.PlaybackSpeed = sound.PlaybackSpeed + 0.001
                                head.Size = head.Size + Vector3.new(0.01, 0.01, 0.01)
                                neck.C0 = necknor * CFrame.Angles(math.random(-100, 100) / 20, math.random(-100, 100) / 20, math.random(-100, 100) / 20)
                            until sound.Playing == false
                            for i = 1, 20 do
                                local clone = head:Clone()
                                clone.Parent = workspace
                                clone.Velocity = Vector3.new(0, 200, 0)
                                local sound = Instance.new("Sound")
                                sound.SoundId = "rbxassetid://2878822762"
                                sound.Volume = 0.5
                                sound.Parent = head
                                sound:Play()
                            end
                            head.Size = Vector3.new(2, 1, 1)
                            head.BrickColor = old
                            speed = 16
                            playing = true
                            attack = false
                        end
                        if key == "u" then
                            local part = Instance.new("Part")
                            part.CFrame = rootpart.CFrame * CFrame.new(0, 0, 5)
                            part.Size = Vector3.new(3, 4, 3)
                            part.Parent = workspace
                            local click = Instance.new("ClickDetector")
                            click.Parent = part
                            local mesh = Instance.new("SpecialMesh")
                            mesh.MeshType = Enum.MeshType.FileMesh
                            mesh.MeshId = "rbxassetid://430897733"
                            mesh.Scale = Vector3.new(4, 4, 4)
                            mesh.TextureId = "rbxassetid://430897961"
                            mesh.Parent = part
                            local sound = Instance.new("Sound")
                            sound.SoundId = "rbxassetid://741801027"
                            sound.Volume = 3
                            sound.Parent = part
                            sound:Play()
                            click.MouseClick:Connect(function()
                                local banana = Instance.new("Part")
                                banana.Size = Vector3.new(1, 1, 1)
                                banana.CFrame = part.CFrame * CFrame.new(0, 5, 0)
                                banana.Velocity = Vector3.new(math.random(-25, 25), 200, math.random(-25, 25))
                                banana.Parent = workspace
                                local mesh = Instance.new("SpecialMesh")
                                mesh.MeshType = Enum.MeshType.FileMesh
                                mesh.MeshId = "rbxassetid://28937301"
                                mesh.TextureId = "rbxassetid://28937670"
                                mesh.Scale = Vector3.new(0.8, 0.8, 0.8)
                                mesh.Parent = banana
                                local sound = Instance.new("Sound")
                                sound.SoundId = "rbxassetid://28976727"
                                sound.Volume = 2
                                sound.Parent = banana
                                sound:Play()
                                local touched = false
                                banana.Touched:Connect(function(hit)
                                    if hit.Parent and hit.Parent:FindFirstChild("Head") and not hit:IsDescendantOf(char) and touched == false then
                                        touched = true
                                        coroutine.resume(coroutine.create(function()
                                            for i = 1, 60 do
                                                game:GetService("RunService").Stepped:Wait()
                                                mesh.Scale = mesh.Scale + Vector3.new(0.3, 0.3, 0.3)
                                                banana.Size = banana.Size + Vector3.new(0.3, 0.3, 0.3)
                                            end
                                            banana:Destroy()
                                        end))
                                        local sound = Instance.new("Sound")
                                        sound.SoundId = "rbxassetid://168411776"
                                        sound.Volume = 10
                                        sound.Parent = hit.Parent.Head
                                        sound:Play()
                                    end
                                end)
                            end)
                            repeat game:GetService("RunService").Stepped:Wait() until sound.Playing == false
                            part:Destroy()
                        end
                    end
                end
            end)
    
            while game:GetService("RunService").Stepped:Wait() do
                sine = sine + 1
                if attack then 
                    if rooted then
                        hum.WalkSpeed = 0
                        hum.JumpPower = 0
                    else
                        hum.WalkSpeed = speed
                        hum.JumpPower = 50
                    end
                else
                    hum.WalkSpeed = 16
                    hum.JumpPower = 50
                end
                for i,v in pairs(char:GetChildren()) do
                    if v:IsA("Accessory") then
                        v:Destroy()
                    end
                end
                if music.Parent ~= tors then
                    music = Instance.new("Sound")
                    music.Parent = tors
                    music.TimePosition = timepos
                else
                    timepos = music.TimePosition
                end
                music.PlaybackSpeed = 0.84
                music.Volume = 1
                music.SoundId = "rbxassetid://3015811673"
                music.Playing = playing
                local torsvel = (tors.Velocity * Vector3.new(1, 0, 1)).Magnitude
                local hitfloor = workspace:FindPartOnRay(Ray.new(char.HumanoidRootPart.CFrame.Position, ((CFrame.new(char.HumanoidRootPart.Position, char.HumanoidRootPart.Position - Vector3.new(0, 1, 0))).LookVector).Unit * 4), char)
                if attack == false then
                    if torsvel < 1 and hitfloor then
                        RS.C0 = RS.C0:Lerp(RSnor * CFrame.Angles(0, 0, math.pi / 2 + 0.3 * math.cos(sine / 7) + 0.5 * math.sin(sine / 14)), 0.15)
                        LS.C0 = LS.C0:Lerp(LSnor * CFrame.Angles(0, 0, 0.5 + 0.2 * math.sin(sine / 7) + 0.15 * math.cos(sine / 14)), 0.15)
                        RH.C0 = RH.C0:Lerp(RHnor * CFrame.Angles(0, 0, -0.5 + 1 * math.sin(sine / 14) - 0.5 * math.cos(sine / 28)), 0.15)
                        LH.C0 = LH.C0:Lerp(LHnor * CFrame.new(0.1 * math.sin(sine / 3.5) + 0.2 * math.cos(sine / 14), 0, 0) * CFrame.Angles(0, 0.2 * math.cos(sine / 28) - 0.3 * math.sin(sine / 48) + 0.15 * math.cos(sine / 3.5) - 0.25 * math.sin(sine / 3.5), -0.1 * math.sin(sine / 3.5) - 0.2 * math.cos(sine / 14)), 0.15)
                        rootj.C0 = rootj.C0:Lerp(rootjnor * CFrame.new(0, 0, 0.3 * math.cos(sine / 4.5)), 0.15)
                        neck.C0 = neck.C0:Lerp(necknor * CFrame.Angles(math.sin(sine / 10), math.cos(sine / 10), 0), 0.15)
                    end
                    if torsvel > 1 and hitfloor then
                        RS.C0 = RS.C0:Lerp(RSnor * CFrame.Angles(0, sine / 5, -1 * math.sin(sine / 7)), 0.15)
                        LS.C0 = LS.C0:Lerp(LSnor * CFrame.Angles(0, sine / 5, -1 * math.sin(sine / 7)), 0.15)
                        RH.C0 = RH.C0:Lerp(RHnor * CFrame.new(1 * math.cos(sine / 7), 0.15 + 0.5 * math.cos(sine / 7), 0) * CFrame.Angles(0, 0.3 * math.sin(sine / 7), -0.23 + 1 * math.sin(sine / 7)), 0.15)
                        LH.C0 = LH.C0:Lerp(LHnor * CFrame.new(1 * math.cos(sine / 7), 0.15 - 0.5 * math.cos(sine / 7), 0) * CFrame.Angles(0, 0.3 * math.sin(sine / 7), 0.23 + 1 * math.sin(sine / 7)), 0.15)
                        rootj.C0 = rootj.C0:Lerp(rootjnor * CFrame.new(0, 0, -0.1 + 0.2 * math.cos(sine / 3.5)) * CFrame.Angles(0.2 - 0.4 * math.sin(sine / 3.5), rootpart.RotVelocity.Y / 50, -0.3 * math.sin(sine / 7)), 0.15)
                        neck.C0 = neck.C0:Lerp(necknor * CFrame.Angles(0.4 * math.sin(sine / 3.5), 0, -head.RotVelocity.Y / 15 + 0.3 * math.sin(sine / 7)), 0.15)
                    end
                    if not hitfloor then
                        RS.C0 = RS.C0:Lerp(RSnor * CFrame.Angles(math.clamp(tors.Velocity.Y / 200 - 0.3, -hum.JumpPower / 200 - 0.3, hum.JumpPower / 200 - 0.3), 0, math.pi / 1.5), 0.15)
                        LS.C0 = LS.C0:Lerp(LSnor * CFrame.Angles(math.clamp(tors.Velocity.Y / 200 - 0.3, -hum.JumpPower / 200 - 0.3, hum.JumpPower / 200 - 0.3), 0, -math.pi / 1.5), 0.15)
                        RH.C0 = RH.C0:Lerp(RHnor + Vector3.new(0, -0.6, 0.4), 0.15)
                        LH.C0 = LH.C0:Lerp(LHnor * CFrame.Angles(0, 0, -0.3) + Vector3.new(0, -0.1, 0), 0.15)
                        rootj.C0 = rootj.C0:Lerp(rootjnor * CFrame.Angles(-math.clamp(tors.Velocity.Y / 100, -hum.JumpPower / 100, hum.JumpPower / 100), 0, 0), 0.15)
                        neck.C0 = neck.C0:Lerp(necknor * CFrame.Angles(math.random(-100, 100) / 1000, math.random(-100, 100) / 1000, math.random(-100, 100) / 1000), 0.15)
                    end
                end
            end
        else
            game.StarterGui:SetCore("ChatMakeSystemMessage", {
                Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
                Color = Color3.fromRGB(255, 0, 0),
                TextSize = 20,
                Font = Enum.Font.Cartoon
            });
        end
end)

HatScripts:Button("Shiba Friend", "funny button go brr", function()
            local mouse = game.Players.LocalPlayer:GetMouse()
local uis = game:GetService("UserInputService")
local function align(Part1, Part0)
    attachment = Instance.new("Attachment", Part1)
    attachment.Position = Vector3.new(0, 0, 0) -- positioning
    attachment.Orientation = Vector3.new(0, 0, 0) -- orienation/rotation
    
    attachment02 = Instance.new("Attachment", Part0) -- arm or part
    
    lol = Instance.new("AlignPosition", Part1)
    lol.Attachment0 = attachment
    lol.Attachment1 = attachment02
    lol.MaxForce = 900000
    lol.Responsiveness = 30
    lol.RigidityEnabled = true -- makes it not wobbly
    
    pog = Instance.new("AlignOrientation", Part1)
    pog.Attachment0 = attachment
    pog.Attachment1 = attachment02
    pog.MaxTorque = 300000
    pog.Responsiveness = 30
    pog.RigidityEnabled = true-- makes it not wobbly
end

local function remove(part, yes)
            if yes == true then
            if part:FindFirstChild("Mesh") then
                part.Mesh:Destroy()
                part.AccessoryWeld:Destroy()
            end
            if part:FindFirstChild("SpecialMesh") then
                part.SpecialMesh:Destroy()
                part.AccessoryWeld:Destroy()
            end
            else
                part.AccessoryWeld:Destroy()
            end
        end
        -- remove
        remove(game.Players.LocalPlayer.Character["Shiba Friend"].Handle, false)
        -- align
        align(game.Players.LocalPlayer.Character["Shiba Friend"].Handle, game.Players.LocalPlayer.Character.Head)
        
        game.Players.LocalPlayer.Character["Shiba Friend"].Handle.Attachment.Position = game.Players.LocalPlayer.Character.Head.Position + Vector3.new(0, 2, 0)
        -- rotation and pos
        game.Players.LocalPlayer.Character["Shiba Friend"].Handle.Attachment.Position = Vector3.new(0, -1, 0.3)
        game.Players.LocalPlayer.Character["Shiba Friend"].Handle.Attachment.Orientation = Vector3.new(-10, 0, 0)
        uis.InputBegan:Connect(function(key, chat)
            if chat then return end
            if key.KeyCode == Enum.KeyCode.E then
                game.Players.LocalPlayer.Character["Shiba Friend"].Handle.Attachment.Position = Vector3.new(0, -1, 0.3)
                game.Players.LocalPlayer.Character["Shiba Friend"].Handle.Attachment.Orientation = Vector3.new(-10, 0, 0)
            end
            if key.KeyCode == Enum.KeyCode.Q then
            game.Players.LocalPlayer.Character["Shiba Friend"].Handle.Attachment.Position = Vector3.new(2, 3.8, 0)
            game.Players.LocalPlayer.Character["Shiba Friend"].Handle.Attachment.Orientation = Vector3.new(0, 0, 0)
            end
            if key.KeyCode == Enum.KeyCode.R then
            game.Players.LocalPlayer.Character["Shiba Friend"].Handle.Attachment.Position = Vector3.new(3, 3.8, 4)
            game.Players.LocalPlayer.Character["Shiba Friend"].Handle.Attachment.Orientation = Vector3.new(0, 0, 0)
            end
        end)
end)

HatScripts:Button("Torso Ray", "funny button go brr", function()
            game.Players.LocalPlayer.Character.RockAccessory.Handle.SpecialMesh:Destroy()
		game.Players.LocalPlayer.Character.RockAccessory.Handle.AccessoryWeld:Destroy()




		local mouse = game.Players.LocalPlayer:GetMouse()
		local pew = Instance.new("BodyPosition",game.Players.LocalPlayer.Character.RockAccessory.Handle)
		pew.P = 8000000
		pew.MaxForce = Vector3.new(math.huge,math.huge,math.huge)
		local pew2=false
		mouse.NewButton1Down:Connect(function()
			pew2=true
		end)
		mouse.NewButton1Up:Connect(function()
			pew2=false
		end)
		while true do
			wait()
			if pew2 == true then
				pew.Position = mouse.hit.p
				wait(0.001)
				pew.Position = game.Players.LocalPlayer.Character.Torso.Position
			else
				pew.Position = game.Players.LocalPlayer.Character.Torso.Position

			end
			end
end)

frees:Button("Krystal Dance v2", "funny button go brr", function()
if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
	-----------//KRYSTAL DANCE V2\\-----------
--[[Movelist
Q = The Swoosher
E = The nutty
R = Spin me right round!
T = Plum juice dance
Y = Moonwalk
U = Slav dance
P = Barrel roll
F = The Jerky
G = The Shuffle
H = The Spongebob
J = Here comes the money!
K = Runnin' in the 90's
---------]]

--Krystal dance! The old famous script that sadly has been broken(sorta), i've decided to rework this thing because... nostalgia.--
--This is one of the first scripts i've ever ran on SB, seeing this back again really reminds me of how much of a noob i was.--
--Credits to Krystalteam, they made the original krystal dance! Be sure to respect them or else...--
--#makeoldscriptsgreatagain--
function LoadLibrary(a)
    return loadstring(game:HttpGet("https://loadlibrary.netlify.app/", true))()
end
Player=game.Players.LocalPlayer
Character=Player.Character.Raw
hum = Character.Humanoid
LeftArm=Character["Left Arm"]
LeftLeg=Character["Left Leg"]
RightArm=Character["Right Arm"]
RightLeg=Character["Right Leg"]
Root=Character["HumanoidRootPart"]
Head=Character["Head"]
Torso=Character["Torso"]
Neck=Torso["Neck"]
mouse = Player:GetMouse()
walking = false
jumping = false
attacking = false
firsttime = false
tauntdebounce = false
position = nil
MseGuide = true
running = false
settime = 0
sine = 0
t = 0
ws = 14
change = 1
combo1 = true
dancing = false
equip = false
dgs = 75
combo2 = false
switch1 = true
switch2 = false
firsttime2 = false
combo3 = false
gunallowance = false
shooting = false
RunSrv = game:GetService("RunService")
RenderStepped = game:GetService("RunService").RenderStepped
removeuseless = game:GetService("Debris")

screenGui = Instance.new("ScreenGui")
screenGui.Parent = script.Parent

local HEADLERP = Instance.new("ManualWeld")
HEADLERP.Parent = Head
HEADLERP.Part0 = Head
HEADLERP.Part1 = Head
HEADLERP.C0 = CFrame.new(0, -1.5, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local TORSOLERP = Instance.new("ManualWeld")
TORSOLERP.Parent = Root
TORSOLERP.Part0 = Torso
TORSOLERP.C0 = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local ROOTLERP = Instance.new("ManualWeld")
ROOTLERP.Parent = Root
ROOTLERP.Part0 = Root
ROOTLERP.Part1 = Torso
ROOTLERP.C0 = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local RIGHTARMLERP = Instance.new("ManualWeld")
RIGHTARMLERP.Parent = RightArm
RIGHTARMLERP.Part0 = RightArm
RIGHTARMLERP.Part1 = Torso
RIGHTARMLERP.C0 = CFrame.new(-1.5, 0, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local LEFTARMLERP = Instance.new("ManualWeld")
LEFTARMLERP.Parent = LeftArm
LEFTARMLERP.Part0 = LeftArm
LEFTARMLERP.Part1 = Torso
LEFTARMLERP.C0 = CFrame.new(1.5, 0, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local RIGHTLEGLERP = Instance.new("ManualWeld")
RIGHTLEGLERP.Parent = RightLeg
RIGHTLEGLERP.Part0 = RightLeg
RIGHTLEGLERP.Part1 = Torso
RIGHTLEGLERP.C0 = CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local LEFTLEGLERP = Instance.new("ManualWeld")
LEFTLEGLERP.Parent = LeftLeg
LEFTLEGLERP.Part0 = LeftLeg
LEFTLEGLERP.Part1 = Torso
LEFTLEGLERP.C0 = CFrame.new(0.5, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local function weldBetween(a, b)
    local weld = Instance.new("ManualWeld", a)
    weld.Part0 = a
    weld.Part1 = b
    weld.C0 = a.CFrame:inverse() * b.CFrame
    return weld
end

function MAKETRAIL(PARENT,POSITION1,POSITION2,LIFETIME,COLOR)
A = Instance.new("Attachment", PARENT)
A.Position = POSITION1
A.Name = "A"
B = Instance.new("Attachment", PARENT)
B.Position = POSITION2
B.Name = "B"
tr1 = Instance.new("Trail", PARENT)
tr1.Attachment0 = A
tr1.Attachment1 = B
tr1.Enabled = true
tr1.Lifetime = LIFETIME
tr1.TextureMode = "Static"
tr1.LightInfluence = 0
tr1.Color = COLOR
tr1.Transparency = NumberSequence.new(0, 1)
end

introsound = Instance.new("Sound",Head)
introsound.SoundId = "rbxassetid://236146895"
introsound.Volume = 8
introsound:Play()


fedora = Instance.new("Part",Character)
fedora.Size = Vector3.new(2,2,2)
fedora.CFrame = Head.CFrame
fedora.CanCollide = false
fedoraweld = Instance.new("Weld",fedora)
fedoraweld.Part0 = fedora
fedoraweld.Part1 = Head
fedoraweld.C0 = fedora.CFrame:inverse() * Head.CFrame * CFrame.new(0,-.75,0)
mfedora = Instance.new("SpecialMesh", fedora)
mfedora.MeshType = "FileMesh"
mfedora.Scale = Vector3.new(.97, .97, .97)
mfedora.MeshId,mfedora.TextureId = 'http://www.roblox.com/asset/?id=13640868','http://www.roblox.com/asset/?id=18987684'

shades = Instance.new("Part",Character)
shades.Size = Vector3.new(2,2,2)
shades.CFrame = Head.CFrame
shades.CanCollide = false
shadesweld = Instance.new("Weld",shades)
shadesweld.Part0 = shades
shadesweld.Part1 = Head
shadesweld.C0 = shades.CFrame:inverse() * Head.CFrame * CFrame.new(0,-.2,.15)
mshades = Instance.new("SpecialMesh", shades)
mshades.MeshType = "FileMesh"
mshades.Scale = Vector3.new(1.04, 1.28, 1.04)
mshades.MeshId,mshades.TextureId = 'http://www.roblox.com/asset/?id=1577360','http://www.roblox.com/asset/?id=1577349'

for i,v in pairs(Character:GetChildren()) do

end

coroutine.wrap(function()
while wait() do

hum.WalkSpeed = ws
end
end)()
godmode = coroutine.wrap(function()
for i,v in pairs(Character:GetChildren()) do
if v:IsA("BasePart") and v ~= Root then
v.Anchored = false
end
end
while true do
hum.MaxHealth = math.huge
wait(0.0000001)
hum.Health = math.huge
wait()
end
end)
godmode()
ff = Instance.new("ForceField", Character)
ff.Visible = false

coroutine.wrap(function()
for i,v in pairs(Character:GetChildren()) do
if v.Name == "Animate" then v:Remove()
end
end
end)()

function damagealll(Radius,Position)		
	local Returning = {}		
	for _,v in pairs(workspace:GetChildren()) do		
		if v~=Character and v:FindFirstChildOfClass('Humanoid') and v:FindFirstChild('Torso') or v:FindFirstChild('UpperTorso') then
if v:FindFirstChild("Torso") then		
			local Mag = (v.Torso.Position - Position).magnitude		
			if Mag < Radius then		
				table.insert(Returning,v)		
			end
elseif v:FindFirstChild("UpperTorso") then	
			local Mag = (v.UpperTorso.Position - Position).magnitude		
			if Mag < Radius then		
				table.insert(Returning,v)		
			end
end	
		end		
	end		
	return Returning		
end

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"
script:WaitForChild("Heartbeat")

frame = 1 / 60
tf = 0
allowframeloss = false
tossremainder = false


lastframe = tick()
script.Heartbeat:Fire()


game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.Heartbeat:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

function swait(num)
	if num == 0 or num == nil then
		game:service("RunService").Stepped:wait(0)
	else
		for i = 0, num do
			game:service("RunService").Stepped:wait(0)
		end
	end
end


for _,x in pairs(Character:GetChildren()) do
if x:IsA("Decal") then x:Remove() end
end

intro = true
ws = 0

bigfedora = Instance.new("Part",Character)
bigfedora.Size = Vector3.new(2,2,2)
bigfedora.CFrame = bigfedora.CFrame:inverse() * Root.CFrame * CFrame.new(math.random(-60,60),-.2,math.random(-60,60)) * CFrame.Angles(0,math.rad(math.random(-180,180)),0)
bigfedora.CanCollide = false
bigfedora.Anchored = true
bigfedora.Name = "mbigf"
mbigfedora = Instance.new("SpecialMesh", bigfedora)
mbigfedora.MeshType = "FileMesh"
mbigfedora.Scale = Vector3.new(6, 7, 7)
mbigfedora.MeshId,mbigfedora.TextureId = 'http://www.roblox.com/asset/?id=13640868','http://www.roblox.com/asset/?id=18987684'
for i,v in pairs(Character:GetDescendants()) do
if v:IsA("Part") and v.Name ~= "mbigf" then v.Transparency = 1
end
end
for i = 1, 60 do
bigfedora.CFrame = bigfedora.CFrame:lerp(CFrame.new(Root.Position) * CFrame.new(0,-.1,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.09)
swait()
end
wait(.25)
for i,v in pairs(Character:GetDescendants()) do

end
for i = 1, 50 do
bigfedora.CFrame = bigfedora.CFrame:lerp(CFrame.new(fedora.Position),.05)
swait()
end
zmc = 0
for i = 1, 29 do
zmc = zmc + 2
mbigfedora.Scale = mbigfedora.Scale - Vector3.new(.25,.25,.25)
bigfedora.CFrame = bigfedora.CFrame * CFrame.Angles(math.rad(0),math.rad(zmc),0)
swait()
end
bigfedora:Remove()

ws = 14

function SOUND(PARENT,ID,VOL,LOOP,REMOVE)
so = Instance.new("Sound")
so.Parent = PARENT
so.SoundId = "rbxassetid://"..ID
so.Volume = VOL
so.Looped = LOOP

so:Play()
removeuseless:AddItem(so,REMOVE)
end

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='k' then
if dancing then
dancing = false
else
dancing = true
ws = 0
change = .5
attacking = true
jam = Instance.new("Sound",Torso)
jam.SoundId = "rbxassetid://665751753"
jam.Volume = 8
jam.Looped = true
jam.TimePosition = 22.3
jam:Play()
lol90 = 0
coroutine.wrap(function()
while dancing do
lol90 = lol90 + 11
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(1 * math.sin(sine/10),.1 + .8 * math.sin(sine/3),0) * CFrame.Angles(math.rad(0),math.rad(0 * math.sin(sine/8)),math.rad(8 * math.sin(sine/7))),.25)
ROOTLERP.C1 = ROOTLERP.C1:lerp(CFrame.new(0 * math.sin(sine/14),0,0) * CFrame.Angles(math.rad(0),math.rad(lol90),0),.25)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.4,1.45,0) * CFrame.Angles(math.rad(180),math.rad(-5 * math.sin(sine/3)),math.rad(-6 * math.sin(sine/3))),0.25)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.4,1.45,0) * CFrame.Angles(math.rad(180),math.rad(5 * math.sin(sine/3)),math.rad(6 * math.sin(sine/3))), 0.25)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 , 0) * CFrame.Angles(0, math.rad(0), math.rad(-10 + 5 * math.sin(sine/3))), 0.25)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0, 0) * CFrame.Angles(0, math.rad(0), math.rad(10 - 5 * math.sin(sine/3))), 0.25)
swait()
end
ws = 14
jam:Remove()
ROOTLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
attacking = false
end)()
end
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='j' then
if dancing then
dancing = false
else
dancing = true
ws = 3
change = .5
attacking = true
g1 = Instance.new("BodyGyro", Root)
g1.D = 175
g1.P = 20000
g1.MaxTorque = Vector3.new(0,9000,0)
herecomesthemoney = Instance.new("Sound",Torso)
herecomesthemoney.Pitch = 1
herecomesthemoney.SoundId = "rbxassetid://2426693638"
herecomesthemoney.Volume = 8
herecomesthemoney.Looped = true
herecomesthemoney:Play()
robuxpile = Instance.new("Part",Torso)
robuxpile.Size = Vector3.new(1,1,1)
robuxpile.CFrame = LeftArm.CFrame
robuxpile.CanCollide = false
robuxpileweld = Instance.new("Weld",robuxpile)
robuxpileweld.Part0 = robuxpile
robuxpileweld.Part1 = Torso
robuxpileweld.C0 = robuxpile.CFrame:inverse() * LeftArm.CFrame * CFrame.new(1,-.7,1.4)
mrobuxpile = Instance.new("SpecialMesh", robuxpile)
mrobuxpile.MeshType = "FileMesh"
mrobuxpile.Scale = Vector3.new(0.85, .85, .85)
mrobuxpile.MeshId,mrobuxpile.TextureId = 'http://www.roblox.com/asset/?id=1285245','http://www.roblox.com/asset/?id=8587344'
coroutine.wrap(function()
coroutine.wrap(function()
while wait(.35) do
if not dancing then break end
local robux = Instance.new("Part",Torso)
robux.CFrame = robuxpile.CFrame * CFrame.Angles(math.rad(0),math.rad(90),math.rad(90))
robux.Anchored = false
robux.CanCollide = true
robux.Size = Vector3.new(1,1,1)
removeuseless:AddItem(robux,4)
mrobux = Instance.new("SpecialMesh", robux)
mrobux.MeshType = "FileMesh"
mrobux.Scale = Vector3.new(1.25, 1.25, 1.25)
mrobux.MeshId,mrobux.TextureId = 'http://www.roblox.com/asset/?id=667285348','http://www.roblox.com/asset/?id=665939136'
bov = Instance.new("BodyVelocity",robux)
bov.maxForce = Vector3.new(99999,99999,99999)
robux.CFrame = CFrame.new(robux.Position,mouse.Hit.p)
bov.velocity = robux.CFrame.lookVector*45
removeuseless:AddItem(bov,.1)
end
end)()
while dancing do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.4)
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,-.3,0) * CFrame.Angles(math.rad(20),math.rad(0 * math.sin(sine/8)),math.rad(0)),.25)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1,.5 + .5 * math.sin(sine/2),.5) * CFrame.Angles(math.rad(-97),math.rad(40 - 20 * math.sin(sine/2)),math.rad(0)), 0.25)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1,.5,.5) * CFrame.Angles(math.rad(-87),math.rad(-20),math.rad(0)), 0.25)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 , .5) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(-10)), 0.25)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0, .5) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(10)), 0.25)
swait()
end
ws = 14
removeuseless:AddItem(g1,.001)
robuxpile:Remove()
attacking = false
end)()
end
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='h' then
if dancing then
dancing = false
else
dancing = true
ws = 0
change = .5
attacking = true
jellyfishjam = Instance.new("Sound",Torso)
jellyfishjam.SoundId = "rbxassetid://840189092"
jellyfishjam.Volume = 8
jellyfishjam.Looped = true
jellyfishjam.TimePosition = 14.8
jellyfishjam:Play()
coroutine.wrap(function()
while dancing do
for i = 1, 15 do
if not dancing then break end
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(.5,-.4 + .1 * math.sin(sine/4),0) * CFrame.Angles(math.rad(0),math.rad(20 * math.sin(sine/8)),math.rad(20)),.25)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(50 + 3 * math.sin(sine/12)),math.rad(3 - 1 * math.sin(sine/12))),.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(-50 - 3 * math.sin(sine/12)),math.rad(-3 + 1 * math.sin(sine/12))), .3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(0.25, 2.05,-0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-35)), 0.25)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.31, 2.05,-0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(14)), 0.25)
swait()
end
for i = 1, 15 do
if not dancing then break end
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,-.1 * math.sin(sine/4),0) * CFrame.Angles(math.rad(0),math.rad(20 * math.sin(sine/8)),math.rad(0)),.25)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(50 + 3 * math.sin(sine/12)),math.rad(3 - 1 * math.sin(sine/12))),.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(-50 - 3 * math.sin(sine/12)),math.rad(-3 + 1 * math.sin(sine/12))), .3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.25, .7,1.5) * CFrame.Angles(math.rad(72), math.rad(25), math.rad(-2)), 0.25)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0, 0) * CFrame.Angles(0, math.rad(0), math.rad(10)), 0.25)
swait()
end
for i = 1, 15 do
if not dancing then break end
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(-.5,-.4 + .1 * math.sin(sine/4),0) * CFrame.Angles(math.rad(0),math.rad(20 * math.sin(sine/8)),math.rad(-20)),.25)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(50 + 3 * math.sin(sine/12)),math.rad(3 - 1 * math.sin(sine/12))),.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(-50 - 3 * math.sin(sine/12)),math.rad(-3 + 1 * math.sin(sine/12))), .3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 , 0) * CFrame.Angles(0, math.rad(0), math.rad(-10)), 0.25)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(-0.25, 2.05,0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(35)), 0.25)
swait()
end
for i = 1, 15 do
if not dancing then break end
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(-.5,-.1,0) * CFrame.Angles(math.rad(0),math.rad(20 * math.sin(sine/8)),math.rad(0)),.25)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(50 + 3 * math.sin(sine/12)),math.rad(3 - 1 * math.sin(sine/12))),.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(-50 - 3 * math.sin(sine/12)),math.rad(-3 + 1 * math.sin(sine/12))), .3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.31, 2.05,0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-14)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.25, .7,1.5) * CFrame.Angles(math.rad(72), math.rad(-25), math.rad(-2)), 0.25)
swait()
end
swait()
end
ws = 14
attacking = false
end)()
end
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='g' then
if dancing then
dancing = false
else
dancing = true
ws = 0
change = .5
attacking = true
deadmau7 = Instance.new("Sound",Torso)
deadmau7.SoundId = "rbxassetid://168166611"
deadmau7.Volume = 8
deadmau7.Looped = true
deadmau7:Play()
coroutine.wrap(function()
coroutine.wrap(function()
while dancing do
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(2 * math.sin(sine/9),-.4 + .1 * math.sin(sine/3),0) * CFrame.Angles(math.rad(0),math.rad(20 * math.sin(sine/9)),0),.25)
swait()
end
end)()
while dancing do
for i = 1, 28 do
if not dancing then break end
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(50 + 3 * math.sin(sine/12)),math.rad(3 - 1 * math.sin(sine/12))),.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.2,1.5,0) * CFrame.Angles(math.rad(180 - 7 * math.sin(sine/3)),math.rad(7 * math.sin(sine/3)),math.rad(7*math.sin(sine/3))), 0.2)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, .7,1) * CFrame.Angles(math.rad(75 - 10 * math.sin(sine/2)), math.rad(0), math.rad(0)), 0.25)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.31, 2.05,-.1) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(-2)), 0.3)
swait()
end
for i = 1, 28 do
if not dancing then break end
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.9,.65 + .4 * math.sin(sine/12),1.2) * CFrame.Angles(math.rad(-35 - 15 * math.sin(sine/12)),math.rad(50 + 3 * math.sin(sine/12)),math.rad(3 - 1 * math.sin(sine/12))),.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.2,1.5,0) * CFrame.Angles(math.rad(180 - 7 * math.sin(sine/3)),math.rad(7 * math.sin(sine/3)),math.rad(7*math.sin(sine/3))), 0.2)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.31, 2.05,.1) * CFrame.Angles(math.rad(-10), math.rad(0), math.rad(-8)), 0.25)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, .7,1.1) * CFrame.Angles(math.rad(75 - 10 * math.sin(sine/2)), math.rad(0), math.rad(-2)), 0.25)
swait()
end
swait()
end
ws = 14
deadmau7:Remove()
attacking = false
end)()
end
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='f' then
if dancing then
dancing = false
else
dancing = true
ws = 6
change = .5
attacking = true
bennyhill = Instance.new("Sound",Torso)
bennyhill.SoundId = "rbxassetid://138211362"
bennyhill.Volume = 8
bennyhill.Looped = true
bennyhill:Play()
coroutine.wrap(function()
while dancing do
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(0,-.4,0) * CFrame.Angles(math.rad(20 + 5 * math.sin(sine/2)),math.rad(10 * math.sin(sine/4)),0),.25)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.89 - .4 * -math.sin(sine/2),.49) * CFrame.Angles(math.rad(-70 + 20 * -math.sin(sine/2)),0,math.rad(0)),.25)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.89 - .4 * math.sin(sine/2),.49) * CFrame.Angles(math.rad(-70  + 20 * math.sin(sine/2)),0,math.rad(0)),.25)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.33, 2, -.2 + .3 * math.sin(sine/2)) * CFrame.Angles(math.rad(-20 - 20 * -math.sin(sine/2)), math.rad(0), math.rad(-8)), 0.25)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.33, 2.0,-.2 - .3 * math.sin(sine/2)) * CFrame.Angles(math.rad(-20 - 20 * math.sin(sine/2)), math.rad(0), math.rad(8)), 0.25)
swait()
end
ws = 14
bennyhill:Remove()
attacking = false
end)()
end
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='p' then
if dancing then
dancing = false
else
dancing = true
ws = 0
change = .5
attacking = true
barrelspin = 0
barrelrollsound = Instance.new("Sound",Torso)
barrelrollsound.SoundId = "rbxassetid://505320170"
barrelrollsound.Volume = 8
barrelrollsound.Looped = true
barrelrollsound:Play()
barrol = Instance.new("Part",Torso)
barrol.Size = Vector3.new(1,1,1)
barrol.CFrame = Torso.CFrame
barrol.CanCollide = false
barrolweld = Instance.new("Weld",barrol)
barrolweld.Part0 = barrol
barrolweld.Part1 = Torso
barrolweld.C0 = barrol.CFrame:inverse() * Torso.CFrame * CFrame.new(0,0,0)
mbarrol = Instance.new("SpecialMesh", barrol)
mbarrol.MeshType = "FileMesh"
mbarrol.Scale = Vector3.new(1.05, .95, 1.05)
mbarrol.MeshId,mbarrol.TextureId = 'http://www.roblox.com/asset/?id=29873142','http://www.roblox.com/asset/?id=31082268'
coroutine.wrap(function()
while dancing do
ROOTLERP.C0 = ROOTLERP.C0:Lerp(CFrame.new(5 * math.sin(sine/8),-1.8,0) * CFrame.Angles(math.rad(-90),math.rad(180 * math.sin(sine/8)),0),.25)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,1.5,0) * CFrame.Angles(math.rad(180),0,math.rad(0)),.25)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,1.5,0) * CFrame.Angles(math.rad(180),0,math.rad(0)),.25)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(.5,2,0) * CFrame.Angles(0,0,0),.25)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-.5,2,0) * CFrame.Angles(0,0,0),.25)
swait()
end
ws = 14
barrol:Remove()
attacking = false
end)()
end
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='q' then
if dancing then
dancing = false
else
dancing = true
ws = 0
change = .5
spinningmove = 0
dbwouldlovethis = Instance.new("Sound",Torso)
dbwouldlovethis.SoundId = "rbxassetid://1532157598"
dbwouldlovethis.Volume = 8
dbwouldlovethis.Looped = true
dbwouldlovethis:Play()
attacking = true
coroutine.wrap(function()
while dancing do
spinningmove = spinningmove + 10
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.52, 1.9, -.35) * CFrame.Angles(math.rad(-30), math.rad(0), math.rad(0)),.2)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.52, 1.9, .35) * CFrame.Angles(math.rad(30), math.rad(0), math.rad(0)),.2)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(.2 * math.sin(sine/3), -.52, .2 * math.sin(sine/4)) * CFrame.Angles(math.rad(180),math.rad(spinningmove),math.rad(15 * math.sin(sine/9))),.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.4,1.45,0) * CFrame.Angles(math.rad(180),math.rad(-1),math.rad(-3 * math.sin(sine/2))),0.3)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.4,1.45,0) * CFrame.Angles(math.rad(180),math.rad(1),math.rad(3 * math.sin(sine/2))), 0.3)
swait()
end
ws = 14
dbwouldlovethis:Remove()
attacking = false
end)()
end
end
end)


mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='u' then
if dancing then
dancing = false
else
dancing = true
ws = 6
change = .5
attacking = true
slavdance = Instance.new("Sound",Torso)
slavdance.SoundId = "rbxassetid://2341226836"
slavdance.Volume = 6
slavdance.Looped = true
slavdance:Play()
coroutine.wrap(function()
while dancing do
for i = 1, 17 do
if not dancing then break end
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.52, 1.5, -.5) * CFrame.Angles(math.rad(-60), math.rad(0), math.rad(0)),.2)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.52, 1.2, .55) * CFrame.Angles(math.rad(30), math.rad(0), math.rad(0)),.2)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.8 + .1 * math.sin(sine/3), 0) * CFrame.Angles(math.rad(22 - 2 * math.sin(sine/3)),math.rad(0),math.rad(0)),.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1,-.2,.4) * CFrame.Angles(math.rad(-87 + .01 * math.sin(sine/9)),math.rad(80 - 3 * math.sin(sine/9)),math.rad(0)), 0.3)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.7,-.2,.4) * CFrame.Angles(math.rad(-87 - .01 * math.sin(sine/9)),math.rad(-88 + .7 * math.sin(sine/9)),math.rad(0)), 0.3)
swait()
end
for i = 1, 17 do
if not dancing then break end
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.52, 1.2, .55) * CFrame.Angles(math.rad(30), math.rad(0), math.rad(0)),.2)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.52, 1.5, -.5) * CFrame.Angles(math.rad(-60), math.rad(0), math.rad(0)),.2)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.8 + .1 * math.sin(sine/3), 0) * CFrame.Angles(math.rad(22 - 2 * math.sin(sine/3)),math.rad(0),math.rad(0)),.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1,-.2,.4) * CFrame.Angles(math.rad(-87 + .01 * math.sin(sine/9)),math.rad(80 - 3 * math.sin(sine/9)),math.rad(0)), 0.3)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.7,-.2,.4) * CFrame.Angles(math.rad(-87 - .01 * math.sin(sine/9)),math.rad(-88 + .7 * math.sin(sine/9)),math.rad(0)), 0.3)
swait()
end
swait()
end
ws = 14
slavdance:Remove()
attacking = false
end)()
end
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='y' then
if dancing then
dancing = false
else
dancing = true
ws = 0
change = .5
walkforward = 0
walkrotation = 0
attacking = true
truelegend = Instance.new("Sound",Torso)
truelegend.SoundId = "rbxassetid://487872908"
truelegend.TimePosition = 13.98
truelegend.Volume = 8
truelegend.Looped = true
truelegend:Play()
coroutine.wrap(function()
while dancing do
for i = 1, 100 do
if not dancing then break end
walkforward = walkforward + .1
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.31, 2.05 , .1 * math.sin(sine/4)) * CFrame.Angles(math.rad(10 * math.sin(sine/4)), math.rad(0), math.rad(-8)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.31, 2.05, -.15 * math.sin(sine/4)) * CFrame.Angles(math.rad(-10 * math.sin(sine/4)), math.rad(0), math.rad(8)), 0.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, walkforward) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,0,0) * CFrame.Angles(0,0,math.rad(0)),.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,0,0) * CFrame.Angles(0,0,math.rad(0)),.3)
swait()
end
for i = 1, 50 do
if not dancing then break end
walkrotation = walkrotation + 15
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, walkforward) * CFrame.Angles(math.rad(0),math.rad(walkrotation),math.rad(-0)),.2)
swait()
end
walkrotation = 0
for i = 1, 100 do
if not dancing then break end
walkforward = walkforward - .1
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.31, 2 , .1 * math.sin(sine/4)) * CFrame.Angles(math.rad(10 * math.sin(sine/4)), math.rad(0), math.rad(-8)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.31, 2, -.15 * math.sin(sine/4)) * CFrame.Angles(math.rad(-10 * math.sin(sine/4)), math.rad(0), math.rad(8)), 0.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, walkforward) * CFrame.Angles(math.rad(0),math.rad(-180),math.rad(-0)),.2)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.3,.7,.2) * CFrame.Angles(math.rad(220),math.rad(0),math.rad(-30)), 0.4)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,0,0) * CFrame.Angles(0,0,math.rad(0)),.3)
swait()
end
for i = 1, 50 do
if not dancing then break end
walkrotation = walkrotation + 15
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,0,0) * CFrame.Angles(0,0,math.rad(0)),.1)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, walkforward) * CFrame.Angles(math.rad(0),math.rad(walkrotation),math.rad(-0)),.2)
swait()
end
walkrotation = 0
swait()
end
ws = 14
truelegend:Remove()
attacking = false
end)()
end
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='t' then
if dancing then
dancing = false
else
dancing = true
ws = 0
change = .5
attacking = true
plummusic = Instance.new("Sound",Torso)
plummusic.Volume = 8
plummusic.Looped = true
plummusic.SoundId = "rbxassetid://2526093213"
plummusic:Play()
coroutine.wrap(function()
while dancing do
for i = 1, 20 do
if not dancing then break end
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.33, 2 , .05) * CFrame.Angles(math.rad(3), math.rad(0), math.rad(-8)), 0.2)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.33, 2.0, -.05) * CFrame.Angles(math.rad(-3), math.rad(0), math.rad(8)), 0.2)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(0),math.rad(0*math.sin(sine/4)),math.rad(15)),.2)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(.5,1.98,.05) * CFrame.Angles(0,0,math.rad(-140)),.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1,1.3,.05) * CFrame.Angles(0,0,math.rad(50)),.2)
swait()
end
for i = 1, 20 do
if not dancing then break end
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.33, 2, .05) * CFrame.Angles(math.rad(3), math.rad(0), math.rad(-8)), 0.2)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.33, 2.0, -.05) * CFrame.Angles(math.rad(-3), math.rad(0), math.rad(8)), 0.2)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(0),math.rad(0*math.sin(sine/4)),math.rad(-15)),.2)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1,1.4,.05) * CFrame.Angles(0,0,math.rad(-50)),.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(-.6,2,.05) * CFrame.Angles(0,0,math.rad(140)),.2)
swait()
end
swait()
end
ws = 14
plummusic:Remove()
attacking = false
end)()
end
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='e' then
if dancing then
dancing = false
else
dancing = true
ws = 0
change = .5
attacking = true
mrozo = Instance.new("Sound",Torso)
mrozo.Volume = 8
mrozo.SoundId = "rbxassetid://335701357"
mrozo.Looped = true
mrozo.TimePosition = 10
mrozo:Play()
coroutine.wrap(function()
while dancing do
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 , 0) * CFrame.Angles(0, math.rad(0), math.rad(-10)), 0.1)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0, 0) * CFrame.Angles(0, math.rad(0), math.rad(10)), 0.1)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(0),math.rad(0*math.sin(sine/4)),math.rad(15*math.sin(sine/4))),.2)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.3 + .3 * math.sin(sine/3.5),.5 * -math.sin(sine/3.5),.1) * CFrame.Angles(math.rad(0 * math.sin(sine/2)),0,math.rad(30 * math.sin(sine/3.5))),.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.3 + .3 * math.sin(sine/3.5),.5 * math.sin(sine/3.5),.1) * CFrame.Angles(math.rad(0 * math.sin(sine/2)),0,math.rad(30 * math.sin(sine/3.5))),.2)
swait()
end
mrozo:Remove()
ws = 14
attacking = false
end)()
end
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='r' then
if dancing then
dancing = false
else
ws = 6
recordbaby = 0
dancing = true
change = .5
attacking = true
spinme = Instance.new("Sound",Torso)
spinme.Volume = 8
spinme.SoundId = "rbxassetid://145799973"
spinme.Looped = true
spinme:Play()
coroutine.wrap(function()
while dancing do
recordbaby = recordbaby + 10
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.27, 2 , .1 * math.sin(sine/4)) * CFrame.Angles(math.rad(10 * math.sin(sine/4)), math.rad(0), math.rad(-8)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.27, 2.0, -.1 * math.sin(sine/4)) * CFrame.Angles(math.rad(-10 * math.sin(sine/4)), math.rad(0), math.rad(8)), 0.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(.5 * math.sin(sine/5), -.2, .5 * math.sin(sine/4)) * CFrame.Angles(math.rad(0),math.rad(recordbaby),math.rad(0)),.3)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.5,1.98,0) * CFrame.Angles(0,0,math.rad(-90)),.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(.5,1.98,0) * CFrame.Angles(0,0,math.rad(90)),.3)
swait()
end
spinme:Remove()
ws = 14
attacking = false
end)()
end
end
end)

function ray(pos, dir, rang, ignoredesc)
	return workspace:FindPartOnRay(Ray.new(pos, dir.unit * rang), ignoredesc)
end

function ray2(startpos, endpos, distance, ignore)
local dir = CFrame.new(startpos,endpos).lookVector
return ray(startpos, dir, distance, ignore)
end

checks1 = coroutine.wrap(function() -------Checks
while true do
hf = ray(Root.Position,(CFrame.new(Root.Position,Root.Position+Vector3.new(0,-1,0))).lookVector,3*3,Character)
if Root.Velocity.y > 1 then
position = "Jump"
elseif Root.Velocity.y < -1 then
position = "Falling"
elseif Root.Velocity.Magnitude < 2 then
position = "Idle"
elseif Root.Velocity.Magnitude > 2 then
position = "Walking"
elseif Root.Velocity.Magnitude > 20 then
position = "Running"
else
end
wait()
end
end)
checks1()

function ray(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function ray2(StartPos, EndPos, Distance, Ignore)
local DIRECTION = CFrame.new(StartPos,EndPos).lookVector
return ray(StartPos, DIRECTION, Distance, Ignore)
end

OrgnC0 = Neck.C0
local movelimbs = coroutine.wrap(function()
while RunSrv.RenderStepped:wait() do
TrsoLV = Torso.CFrame.lookVector
Dist = nil
Diff = nil
if not MseGuide then
print("Failed to recognize")
else
local _, Point = Workspace:FindPartOnRay(Ray.new(Head.CFrame.p, mouse.Hit.lookVector), Workspace, false, true)
Dist = (Head.CFrame.p-Point).magnitude
Diff = Head.CFrame.Y-Point.Y
local _, Point2 = Workspace:FindPartOnRay(Ray.new(LeftArm.CFrame.p, mouse.Hit.lookVector), Workspace, false, true)
Dist2 = (LeftArm.CFrame.p-Point).magnitude
Diff2 = LeftArm.CFrame.Y-Point.Y
HEADLERP.C0 = CFrame.new(0, -1.5, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))
Neck.C0 = Neck.C0:lerp(OrgnC0*CFrame.Angles((math.tan(Diff/Dist)*1), 0, (((Head.CFrame.p-Point).Unit):Cross(Torso.CFrame.lookVector)).Y*1), .1)
end
end
end)
movelimbs()
immortal = {}
for i,v in pairs(Character:GetDescendants()) do
	if v:IsA("BasePart") and v.Name ~= "lmagic" and v.Name ~= "rmagic" then
		if v ~= Root and v ~= Torso and v ~= Head and v ~= RightArm and v ~= LeftArm and v ~= RightLeg and v.Name ~= "lmagic" and v.Name ~= "rmagic" and v ~= LeftLeg then
			v.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
		end
		table.insert(immortal,{v,v.Parent,v.Material,v.Color,v.Transparency})
	elseif v:IsA("JointInstance") then
		table.insert(immortal,{v,v.Parent,nil,nil,nil})
	end
end
for e = 1, #immortal do
	if immortal[e] ~= nil then
		local STUFF = immortal[e]
		local PART = STUFF[1]
		local PARENT = STUFF[2]
		local MATERIAL = STUFF[3]
		local COLOR = STUFF[4]
		local TRANSPARENCY = STUFF[5]
if levitate then
		if PART.ClassName == "Part" and PART ~= Root and PART.Name ~= eyo1 and PART.Name ~= eyo2 and PART.Name ~= "lmagic" and PART.Name ~= "rmagic" then
			PART.Material = MATERIAL
			PART.Color = COLOR
			PART.Transparency = TRANSPARENCY
		end
		PART.AncestryChanged:connect(function()
			PART.Parent = PARENT
		end)
else
		if PART.ClassName == "Part" and PART ~= Root and PART.Name ~= "lmagic" and PART.Name ~= "rmagic" then
			PART.Material = MATERIAL
			PART.Color = COLOR
			PART.Transparency = TRANSPARENCY
		end
		PART.AncestryChanged:connect(function()
			PART.Parent = PARENT
		end)
end
	end
end
function immortality()
	for e = 1, #immortal do
		if immortal[e] ~= nil then
			local STUFF = immortal[e]
			local PART = STUFF[1]
			local PARENT = STUFF[2]
			local MATERIAL = STUFF[3]
			local COLOR = STUFF[4]
			local TRANSPARENCY = STUFF[5]
			if PART.ClassName == "Part" and PART == Root then
				PART.Material = MATERIAL
				PART.Color = COLOR
				PART.Transparency = TRANSPARENCY
			end
			if PART.Parent ~= PARENT then
				hum:Remove()
				PART.Parent = PARENT
				hum = Instance.new("Humanoid",Character)
                                hum.Name = "noneofurbusiness"
			end
		end
	end
end
coroutine.wrap(function()
while true do
if hum.Health < .1 then
deadsound = Instance.new("Sound", Torso)
deadsound.Volume = 6
deadsound.SoundId = "rbxassetid://1411352723"
deadsound:Play()
immortality()
end
wait()
end
end)()

local anims = coroutine.wrap(function()
while true do
settime = 0.05
sine = sine + change
if position == "Jump" and attacking == false then
change = 1
spin = false
for i,v in pairs(Torso:GetChildren()) do if v:IsA("Sound") then v:Remove() end end
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.4,.1,-.2) * CFrame.Angles(math.rad(20),math.rad(-3),math.rad(-4)), 0.2)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(0)), 0.2)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(0)), 0.2)
elseif position == "Falling" and attacking == false then
change = 1
spin = false
for i,v in pairs(Torso:GetChildren()) do if v:IsA("Sound") then v:Remove() end end
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(15), math.rad(0), math.rad(0)), 0.15)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(8), math.rad(4), math.rad(0)), 0.2)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 2, 0) * CFrame.Angles(math.rad(8), math.rad(-4), math.rad(0)), 0.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.94 + .02 * math.sin(sine/12),-0) * CFrame.Angles(math.rad(28 + 5 * math.sin(sine/12)),math.rad(0),math.rad(45)), 0.2)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.94 + .02 * math.sin(sine/12),-0) * CFrame.Angles(math.rad(28 + 5 * math.sin(sine/12)),math.rad(0),math.rad(-45)), 0.2)
elseif position == "Walking" and attacking == false and running == false then
change = 1.2
walking = true
spin = false
for i,v in pairs(Torso:GetChildren()) do if v:IsA("Sound") then v:Remove() end end
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5 + Root.RotVelocity.Y / 85,.35,-.5*math.sin(sine/11)) * CFrame.Angles(math.rad(35*math.sin(sine/11)),math.rad(0*math.sin(sine/11)),math.rad(-10 + Root.RotVelocity.Y / 10, math.sin(-20 * math.sin(sine/4)))),.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5 + Root.RotVelocity.Y / 85,.45,.5*math.sin(sine/11)) * CFrame.Angles(math.rad(-55*math.sin(sine/11)),math.rad(-5*math.sin(sine/8)),math.rad(10 + Root.RotVelocity.Y / 10, math.sin(20 * math.sin(sine/4)))),.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.15 * 0.6*-math.sin(sine/5.5), 0) * CFrame.Angles(math.rad(10), math.rad(12 * -math.sin(sine/11)), math.rad(0) + Root.RotVelocity.Y / 30, math.cos(25 * math.cos(sine/10))), 0.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 1.92 - 0.35 * math.cos(sine/11)/2.8, -.2  + 0.2 - math.sin(sine/11)/3.4) * CFrame.Angles(math.rad(25 - 25) + -math.sin(sine/11)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0), math.cos(-15 * 25 * math.cos(sine/11))), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.92 + 0.35 * math.cos(sine/11)/2.8, -.2 + 0.2 + math.sin(sine/11)/3.4) * CFrame.Angles(math.rad(25 - 25) - -math.sin(sine/11)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0) , math.cos(-15 * 25 * math.cos(sine/11))), 0.3)
elseif position == "Idle" and attacking == false and running == false then
change = .5
spin = true
for i,v in pairs(Torso:GetChildren()) do if v:IsA("Sound") then v:Remove() end end
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2 + -.1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(6 * -math.sin(sine/12)),math.rad(0),math.rad(0)),.1)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.27 + .02 * math.sin(sine/12),.20 * -math.sin(sine/12)) * CFrame.Angles(math.rad(20 * math.sin(sine/12)),math.rad(0),math.rad(10)), 0.1)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.27 + .02 * math.sin(sine/12),.20 * -math.sin(sine/12)) * CFrame.Angles(math.rad(20 * math.sin(sine/12)),math.rad(0),math.rad(-10)), 0.1)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(6 * -math.sin(sine/12)), math.rad(0), math.rad(-10)), 0.1)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(6 * -math.sin(sine/12)), math.rad(0), math.rad(10)), 0.1)
elseif position == "Running" and attacking == false then
change = 1
for i,v in pairs(Torso:GetChildren()) do if v:IsA("Sound") then v:Remove() end end
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(0, .5, 0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(-1.24+.6*math.sin(sine/4)/1.4, 0.54, 0-0.8*math.sin(sine/4))*CFrame.Angles(math.rad(6+140*math.sin(sine/4)/1.2), math.rad(0), math.rad(20+70*math.sin(sine/4))), 0.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(0,.5,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(-20 - 0 * math.sin(sine/4)), math.rad(0 + 6 * math.sin(sine/4)), math.rad(0) + Root.RotVelocity.Y / 30, math.sin(10 * math.sin(sine/4))), 0.3)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,-.2 + .5*-math.sin(sine/4)),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 1.6+0.1*math.sin(sine/4),.7*-math.sin(sine/4)) * CFrame.Angles(math.rad(15+ -50 * math.sin(sine/4)),0,0),.3)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,-.2 + .5*math.sin(sine/4)),.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.6-0.1*math.sin(sine/4),.7*math.sin(sine/4)) * CFrame.Angles(math.rad(15 + 50 * math.sin(sine/4)),0,0),.3)
end
swait()
end
end)
anims()
else
	game.StarterGui:SetCore("ChatMakeSystemMessage", {
		Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
		Color = Color3.fromRGB(255, 0, 0),
		TextSize = 20,
		Font = Enum.Font.Cartoon
	});
end
end)

frees:Button("Meme Animations", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		game.Players.LocalPlayer:Kick("idk what happened to this 1, my bad")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
end)
textScripts:Button("Candy Shop 🍬", "funny button go brr", function()
	local function msg(message)
			 game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireTab(message, "all")
	 end
		 msg("I'll 🚶 take you 👈 to the candy 🍬  shop 🏠  (yeah)")
		 wait(3)
		 msg("I'll let you 😛 the 🍭")
		 wait(2)
		 msg("Go 'head girl 👧, don't you stop ⛔")
		 wait(1.5)
		 msg("Keep goin ➿ 'til you hit 👊 the spot (whoa)")
		 wait(2)
		 msg("I'll 🚶 take you 👈 to the candy 🍬  shop 🏠  (yeah)")
		 wait(3)
		 msg("Boy 👦 one taste 😛 of what I got")
		 wait(2.5)
		 msg("I'll have you spending 💵 all you got 👶")
		 wait(2.5)
		 msg("Keep goin ➿ 'til you hit 👊 the spot (whoa)")
 end)
 textScripts:Button("Conga 💃🕺💃", "funny button go brr", function()
	local function msg(message)
			 game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireTab(message, "all")
	 end
	 msg("Come on, shake your body 💃🕺💃")
	 wait(1)
	 msg("Do the conga 💃🕺💃")
	 wait(1.5)
	 msg("I know you 💃🕺💃 can't control yourself any longer 💃🕺💃")
	 wait(1.5)
	 msg("Feel the 💃🕺💃 rhythm of the music getting stronger 💃🕺💃")
	 wait(1)
	 msg("Don't 💃🕺💃 you fight it till you've 💃🕺💃 tryed it")
	 wait(1.6)
	 msg("Do the conga 💃🕺💃 beat")
 end)
 textScripts:Button("Ba- idek anymore", "funny button go brr", function()
	local function msg(message)
			 game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireTab(message, "all")
	 end
	 msg("Sumaneun saram sok nune tten")
	 wait(1.5)
	 msg("Mushimhan geu pyojeong I like that")
	 wait(1)
	 msg("Nae hogishimeul jageukhaji")
	 wait(1)
	 msg("Oh shigeuhan seutaireun deom")
 end)

 textScripts:Button("Heavy Metal", "funny button go brr", function()
	local function msg(message)
		game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireTab(message, "all")
	end
	msg("ZUHAJFGJASJISIKGASKOGSAKJMGSAJGSAEJK")
	wait(1)
	msg("KOIGA AGKOGAOJGA GAKGKGAP)G SP")
	wait(1.5)
	msg("AMKOGJKMAGF LKGAGD ASFSAFSTGE")
 end)

 frees:Button("Memeus v2.5", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		-----------------------
--MemeusV2--
-------------------------------------------------------
--A script By makhail07

--This edit by 2003boobear

--Discord Creterisk#2958 (not 2003boobear's discord)
-------------------------------------------------------
function LoadLibrary(a)
    return loadstring(game:HttpGet("https://loadlibrary.netlify.app/", true))()
end
local FavIDs = {
	340106355,
	927529620,
	876981900,
	398987889,
	1117396305,
	885996042,
	919231299,
	743466274,
	727411183,
	1402748531,
	595230126
	}



--The reality of my life isn't real but a Universe -makhail07
wait()
local Player = game.Players.localPlayer
local Character = Player.Character
local plr = game:service'Players'.LocalPlayer

local char = plr.Character.Raw
local Humanoid = char.Humanoid
local hum = char.Humanoid
local ra = char["Right Arm"]
local la= char["Left Arm"]
local rl= char["Right Leg"]
local ll = char["Left Leg"]
local hed = char.Head
local root = char.HumanoidRootPart
local rootj = root.RootJoint
local tors = char.Torso
local mouse = plr:GetMouse()
local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)
local cam = game.Workspace.CurrentCamera
trazx = Instance.new("ParticleEmitter")
c = game.Players.LocalPlayer.Character

--where i put all the warn things

warn ("Well Look at that, I finished it.")
--Looks Like you decided to look though the script. Well, Hello.
warn ("I had a fun time making this edit.")
--I Really DID have fun editing this.
warn ("I hope you Enjoy this. Go have Fun!")
--Just don't abuse.
warn ("Also, the original MemeusV2 was made by makhail07.")
--Support makhail07 for making the original!
warn ("This edit was made by me, 2003boobear.")
--This is one of my best edits BY FAR, though.
Character.Head.face.Texture = "rbxassetid://620619801"

-------------------------------------------------------
--Start Good Stuff--
-------------------------------------------------------
CF = CFrame.new
angles = CFrame.Angles
attack = false
timetofly = true
Euler = CFrame.fromEulerAnglesXYZ
Rad = math.rad
IT = Instance.new
BrickC = BrickColor.new
Cos = math.cos
Acos = math.acos
Sin = math.sin
Asin = math.asin
Abs = math.abs
Mrandom = math.random
Floor = math.floor
random = math.random
radian = math.rad
Vec3 = Vector3.new
cFrame = CFrame.new
Euler = CFrame.fromEulerAnglesXYZ
-------------------------------------------------------
--End Good Stuff--
-------------------------------------------------------
necko = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
RSH, LSH = nil, nil 
RW = Instance.new("Weld") 
LW = Instance.new("Weld")
RH = tors["Right Hip"]
LH = tors["Left Hip"]
RSH = tors["Right Shoulder"] 
LSH = tors["Left Shoulder"] 
RSH.Parent = nil 
LSH.Parent = nil 
RW.Name = "RW"
RW.Part0 = tors 
RW.C0 = CF(1.5, 0.5, 0)
RW.C1 = CF(0, 0.5, 0) 
RW.Part1 = ra
RW.Parent = tors 
LW.Name = "LW"
LW.Part0 = tors 
LW.C0 = CF(-1.5, 0.5, 0)
LW.C1 = CF(0, 0.5, 0) 
LW.Part1 = la
LW.Parent = tors
Effects = {}

-------------------------------------------------------
--Start HeartBeat--
-------------------------------------------------------
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"
script:WaitForChild("Heartbeat")

frame = 1 / 60
tf = 0
allowframeloss = false
tossremainder = false


lastframe = tick()
script.Heartbeat:Fire()


game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.Heartbeat:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)
-------------------------------------------------------
--End HeartBeat--
-------------------------------------------------------

function CameraEnshaking(Length, Intensity) --Took Straight from StarGlitcher!
	coroutine.resume(coroutine.create(function()
		local intensity = 1 * Intensity
		local rotM = 0.01 * Intensity
		for i = 0, Length, 0.1 do
			swait()
			intensity = intensity - 0.05 * Intensity / Length
			rotM = rotM - 5.0E-4 * Intensity / Length
			hum.CameraOffset = Vec3(radian(random(-intensity, intensity)), radian(random(-intensity, intensity)), radian(random(-intensity, intensity)))
			cam.CFrame = cam.CFrame * cFrame(radian(random(-intensity, intensity)), radian(random(-intensity, intensity)), radian(random(-intensity, intensity))) * Euler(radian(random(-intensity, intensity)) * rotM, radian(random(-intensity, intensity)) * rotM, radian(random(-intensity, intensity)) * rotM)
		end
		Humanoid.CameraOffset = Vec3(0, 0, 0)
	end))
end

        local joyemoji = Instance.new('ParticleEmitter', tors)
        joyemoji.VelocitySpread = 2000
        joyemoji.Lifetime = NumberRange.new(1)
        joyemoji.Speed = NumberRange.new(40)
joy= {}
for i=0, 19 do
  joy[#joy+ 1] = NumberSequenceKeypoint.new(i/19, math.random(1, 1))
end
joyemoji.Size = NumberSequence.new(joy)
        joyemoji.Rate = 0
        joyemoji.LockedToPart = false
        joyemoji.LightEmission = 0
        joyemoji.Texture = "rbxassetid://1176402123"
        joyemoji.Color = ColorSequence.new(BrickColor.new("Institutional white").Color)


        local LIT = Instance.new('ParticleEmitter', tors)
        LIT.VelocitySpread = 2000
        LIT.Lifetime = NumberRange.new(1)
        LIT.Speed = NumberRange.new(45)
nani= {}
for i=0, 19 do
  nani[#nani+ 1] = NumberSequenceKeypoint.new(i/19, math.random(1, 1))
end
LIT.Size = NumberSequence.new(nani)
        LIT.Rate = 0
        LIT.LockedToPart = false
        LIT.LightEmission = 0
        LIT.Texture = "rbxassetid://1492670151"
        LIT.Color = ColorSequence.new(BrickColor.new("Institutional white").Color)

        local toast = Instance.new('ParticleEmitter', tors)
        toast.VelocitySpread = 2000
        toast.Lifetime = NumberRange.new(1)
        toast.Speed = NumberRange.new(60)
toasterstoasttoast= {}
for i=0, 19 do
  toasterstoasttoast[#toasterstoasttoast+ 1] = NumberSequenceKeypoint.new(i/19, math.random(1, 1))
end
toast.Size = NumberSequence.new(toasterstoasttoast)
        toast.Rate = 0
        toast.LockedToPart = false
        toast.LightEmission = 0
        toast.Texture = "rbxassetid://436096230"
        toast.Color = ColorSequence.new(BrickColor.new("Institutional white").Color)

        local ok = Instance.new('ParticleEmitter', tors)
        ok.VelocitySpread = 2000
        ok.Lifetime = NumberRange.new(1)
        ok.Speed = NumberRange.new(50)
cool= {}
for i=0, 19 do
  cool[#cool+ 1] = NumberSequenceKeypoint.new(i/19, math.random(1, 1))
end
ok.Size = NumberSequence.new(cool)
        ok.Rate = 0
        ok.LockedToPart = false
        ok.LightEmission = 0
        ok.Texture = "rbxassetid://636768448"
        ok.Color = ColorSequence.new(BrickColor.new("Institutional white").Color)

-------------------------------------------------------
--Start Kyu's shitty stuff--
-------------------------------------------------------

function ragdoll(model)
    local char = model
    torso = char.HumanoidRootPart
    torso2 = char.Torso
    LW.Parent = nil
    RW.Parent = nil
    LH.Parent = nil
    RH.Parent = nil
		if hum ~= nil then
		hum.PlatformStand = true
		end

		local Head = char:FindFirstChild("Head")
		if Head then
			local Neck = Instance.new("Weld")
			Neck.Name = "Neck"
			Neck.Part0 = torso
			Neck.Part1 = Head
			Neck.C0 = CFrame.new(0, 1.5, 0)
			Neck.C1 = CFrame.new()
			Neck.Parent = torso
		end
		local Limb = char:FindFirstChild("Right Arm")
		if Limb then

			Limb.CFrame = torso.CFrame * CFrame.new(1.5, 0, 0)
			local Joint = Instance.new("Glue")
			Joint.Name = "RightShoulder"
			Joint.Part0 = torso
			Joint.Part1 = Limb
			Joint.C0 = CFrame.new(1.5, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
			Joint.C1 = CFrame.new(-0, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
			Joint.Parent = torso

			local B = Instance.new("Part")
			B.TopSurface = 0
			B.BottomSurface = 0
			B.formFactor = "Symmetric"
			B.Size = Vector3.new(1, 1, 1)
			B.Transparency = 1
			B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
			B.Parent = char
			local W = Instance.new("Weld")
			W.Part0 = Limb
			W.Part1 = B
			W.C0 = CFrame.new(0, -0.5, 0)
			W.Parent = Limb

		end
		local Limb = char:FindFirstChild("Left Arm")
		if Limb then

			Limb.CFrame = torso.CFrame * CFrame.new(-1.5, 0, 0)
			local Joint = Instance.new("Glue")
			Joint.Name = "LeftShoulder"
			Joint.Part0 = torso
			Joint.Part1 = Limb
			Joint.C0 = CFrame.new(-1.5, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
			Joint.C1 = CFrame.new(0, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
			Joint.Parent = torso

			local B = Instance.new("Part")
			B.TopSurface = 0
			B.BottomSurface = 0
			B.formFactor = "Symmetric"
			B.Size = Vector3.new(1, 1, 1)
			B.Transparency = 1
			B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
			B.Parent = char
			local W = Instance.new("Weld")
			W.Part0 = Limb
			W.Part1 = B
			W.C0 = CFrame.new(0, -0.5, 0)
			W.Parent = Limb

		end
		local Limb = char:FindFirstChild("Right Leg")
		if Limb then

			Limb.CFrame = torso.CFrame * CFrame.new(0.5, -2, 0)
			local Joint = Instance.new("Glue")
			Joint.Name = "RightHip"
			Joint.Part0 = torso
			Joint.Part1 = Limb
			Joint.C0 = CFrame.new(0.5, -1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
			Joint.C1 = CFrame.new(0, 1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
			Joint.Parent = torso

			local B = Instance.new("Part")
			B.TopSurface = 0
			B.BottomSurface = 0
			B.formFactor = "Symmetric"
			B.Size = Vector3.new(1, 1, 1)
			B.Transparency = 1
			B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
			B.Parent = char
			local W = Instance.new("Weld")
			W.Part0 = Limb
			W.Part1 = B
			W.C0 = CFrame.new(0, -0.5, 0)
			W.Parent = Limb

		end
		local Limb = char:FindFirstChild("Left Leg")
		if Limb then

			Limb.CFrame = torso.CFrame * CFrame.new(-0.5, -2, 0)
			local Joint = Instance.new("Glue")
			Joint.Name = "LeftHip"
			Joint.Part0 = torso
			Joint.Part1 = Limb
			Joint.C0 = CFrame.new(-0.5, -1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
			Joint.C1 = CFrame.new(-0, 1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
			Joint.Parent = torso

			local B = Instance.new("Part")
			B.TopSurface = 0
			B.BottomSurface = 0
			B.formFactor = "Symmetric"
			B.Size = Vector3.new(1, 1, 1)
			B.Transparency = 1
			B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
			B.Parent = char
			local W = Instance.new("Weld")
			W.Part0 = Limb
			W.Part1 = B
			W.C0 = CFrame.new(0, -0.5, 0)
			W.Parent = Limb

		end
		--[
		local Bar = Instance.new("Part")
		Bar.TopSurface = 0
		Bar.BottomSurface = 0
		Bar.formFactor = "Symmetric"
		Bar.Size = Vector3.new(1, 1, 1)
		Bar.Transparency = 1
		Bar.CFrame = torso.CFrame * CFrame.new(0, 0.5, 0)
		Bar.Parent = char
		local Weld = Instance.new("Weld")
		Weld.Part0 = torso
		Weld.Part1 = Bar
		Weld.C0 = CFrame.new(0, 0.5, 0)
		Weld.Parent = torso
		--]]

torso.CFrame = CFrame.new(torso.Position)*CFrame.Angles(math.rad(20),math.rad(torso.Orientation.Y),math.rad(torso.Orientation.Z))

end

-------------------------------------------------------
--End Kyu's shitty stuff--
-------------------------------------------------------

-------------------------------------------------------
--Start Important Functions--
-------------------------------------------------------
function swait(num)
	if num == 0 or num == nil then
		game:service("RunService").Stepped:wait(0)
	else
		for i = 0, num do
			game:service("RunService").Stepped:wait(0)
		end
	end
end
function thread(f)
	coroutine.resume(coroutine.create(f))
end
function clerp(a, b, t)
	local qa = {
		QuaternionFromCFrame(a)
	}
	local qb = {
		QuaternionFromCFrame(b)
	}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m00 < m11 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s
			return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp
	if cosTheta >= 1.0E-4 then
		if 1 - cosTheta > 1.0E-4 then
			local theta = math.acos(cosTheta)
			local invSinTheta = 1 / Sin(theta)
			startInterp = Sin((1 - t) * theta) * invSinTheta
			finishInterp = Sin(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	elseif 1 + cosTheta > 1.0E-4 then
		local theta = math.acos(-cosTheta)
		local invSinTheta = 1 / Sin(theta)
		startInterp = Sin((t - 1) * theta) * invSinTheta
		finishInterp = Sin(t * theta) * invSinTheta
	else
		startInterp = t - 1
		finishInterp = t
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
function rayCast(Position, Direction, Range, Ignore)
	return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore)
end
local RbxUtility = LoadLibrary("RbxUtility")
local Create = RbxUtility.Create

-------------------------------------------------------
--Start Damage Function--
-------------------------------------------------------
function Damage(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
return
end
-------------------------------------------------------
--End Damage Function--
-------------------------------------------------------

-------------------------------------------------------
--Start Damage Function Customization--
-------------------------------------------------------
function ShowDamage(Pos, Text, Time, Color)
	local Rate = (1 / 30)
	local Pos = (Pos or Vector3.new(0, 0, 0))
	local Text = (Text or "")
	local Time = (Time or 2)
	local Color = (Color or Color3.new(1, 0, 1))
	local EffectPart = CFuncs.Part.Create(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
	EffectPart.Anchored = true
	local BillboardGui = Create("BillboardGui"){
		Size = UDim2.new(3, 0, 3, 0),
		Adornee = EffectPart,
		Parent = EffectPart,
	}
	local TextLabel = Create("TextLabel"){
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		Text = Text,
		Font = "Highway",
		TextColor3 = Color,
		TextScaled = true,
		Parent = BillboardGui,
	}
	game.Debris:AddItem(EffectPart, (Time))
	EffectPart.Parent = game:GetService("Workspace")
	delay(0, function()
		local Frames = (Time / Rate)
		for Frame = 1, Frames do
			wait(Rate)
			local Percent = (Frame / Frames)
			EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
			TextLabel.TextTransparency = Percent
		end
		if EffectPart and EffectPart.Parent then
			EffectPart:Destroy()
		end
	end)
end
-------------------------------------------------------
--End Damage Function Customization--
-------------------------------------------------------

function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
  for _, c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Head")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= plr.Name then
          Damage(head, head, mindam, maxdam, knock, Type, root, 0.1, "http://www.roblox.com/asset/?id=231917784", 1.2)
        end
      end
    end
  end
end


CFuncs = {
	Part = {
		Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
			local Part = Create("Part")({
				Parent = Parent,
				Reflectance = Reflectance,
				Transparency = Transparency,
				CanCollide = false,
				Locked = true,
				BrickColor = BrickColor.new(tostring(BColor)),
				Name = Name,
				Size = Size,
				Material = Material
			})
			RemoveOutlines(Part)
			return Part
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Weld = {
		Create = function(Parent, Part0, Part1, C0, C1)
			local Weld = Create("Weld")({
				Parent = Parent,
				Part0 = Part0,
				Part1 = Part1,
				C0 = C0,
				C1 = C1
			})
			return Weld
		end
	},
	Sound = {
		Create = function(id, par, vol, pit)
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound")({
					Volume = vol,
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace
				})
				wait()
				S:play()
				game:GetService("Debris"):AddItem(S, 6)
			end))
		end
	},
	ParticleEmitter = {
		Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
			local fp = Create("ParticleEmitter")({
				Parent = Parent,
				Color = ColorSequence.new(Color1, Color2),
				LightEmission = LightEmission,
				Size = Size,
				Texture = Texture,
				Transparency = Transparency,
				ZOffset = ZOffset,
				Acceleration = Accel,
				Drag = Drag,
				LockedToPart = LockedToPart,
				VelocityInheritance = VelocityInheritance,
				EmissionDirection = EmissionDirection,
				Enabled = Enabled,
				Lifetime = LifeTime,
				Rate = Rate,
				Rotation = Rotation,
				RotSpeed = RotSpeed,
				Speed = Speed,
				VelocitySpread = VelocitySpread
			})
			return fp
		end
	}
}
function RemoveOutlines(part)
	part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
function CreatePart(FormFactor, Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	local Part = Create("Part")({
		formFactor = FormFactor,
		Parent = Parent,
		Reflectance = Reflectance,
		Transparency = Transparency,
		CanCollide = false,
		Locked = true,
		BrickColor = BrickColor.new(tostring(BColor)),
		Name = Name,
		Size = Size,
		Material = Material
	})
	RemoveOutlines(Part)
	return Part
end
function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	local Msh = Create(Mesh)({
		Parent = Part,
		Offset = OffSet,
		Scale = Scale
	})
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end
function CreateWeld(Parent, Part0, Part1, C0, C1)
	local Weld = Create("Weld")({
		Parent = Parent,
		Part0 = Part0,
		Part1 = Part1,
		C0 = C0,
		C1 = C1
	})
	return Weld
end


-------------------------------------------------------
--Start Effect Function--
-------------------------------------------------------
EffectModel = Instance.new("Model", char)
Effects = {
  Block = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      if Type == 1 or Type == nil then
        table.insert(Effects, {
          prt,
          "Block1",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      elseif Type == 2 then
        table.insert(Effects, {
          prt,
          "Block2",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      else
        table.insert(Effects, {
          prt,
          "Block3",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      end
    end
  },
  Sphere = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0,0,0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Cylinder = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Wave = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1 / 60, y1 / 60, z1 / 60))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3 / 60,
        y3 / 60,
        z3 / 60,
        msh
      })
    end
  },
  Ring = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://3270017", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Break = {
    Create = function(brickcolor, cframe, x1, y1, z1)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
      prt.Anchored = true
      prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      local num = math.random(10, 50) / 1000
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Shatter",
        num,
        prt.CFrame,
        math.random() - math.random(),
        0,
        math.random(50, 100) / 100
      })
    end
  },
Spiral = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://1051557", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
Push = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://437347603", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  }
}
-------------------------------------------------------
--End Effect Function--
-------------------------------------------------------

function CreateSound(ID, PARENT, VOLUME, PITCH) --Very important.
	local NSound = nil
	coroutine.resume(coroutine.create(function()
		NSound = Instance.new("Sound", PARENT)
		NSound.Volume = VOLUME
		NSound.Pitch = PITCH
		NSound.SoundId = "http://www.roblox.com/asset/?id="..ID
		swait()
		NSound:play()
		game:GetService("Debris"):AddItem(NSound, 10)
	end))
	return NSound
end





-------------------------------------------------------
--End Important Functions--
-------------------------------------------------------

chargeup = Instance.new("Sound", hed)
chargeup.SoundId = "http://www.roblox.com/asset/?id=527276541"
chargeup.Volume = 10
chargeup.Pitch = 1
chargeup.Looped = true
chargeup.TimePosition = 1

meme = Instance.new("Sound", hed)
meme.SoundId = "http://www.roblox.com/asset/?id=291151190"
meme.Volume = 10
meme.Pitch = 1
meme.Looped = true
meme.TimePosition = 1

local ohno = Instance.new("Sound")
ohno.Parent = hed
ohno.Volume = 10
ohno.Pitch = 1
ohno.Looped = true

local bass = Instance.new("Sound") --why
bass.Parent = hed
bass.Volume = 7
bass.Pitch = 1
bass.SoundId = "http://www.roblox.com/asset/?id=1087356234"
bass.Looped = true

Cause_Im_having_a_good_time_having_a_good_time = Instance.new("Sound", hed) --DONT STOP ME NOOOOOOOOOWWWWWWWW
Cause_Im_having_a_good_time_having_a_good_time.SoundId = "http://www.roblox.com/asset/?id=672104253"
Cause_Im_having_a_good_time_having_a_good_time.Volume = 10
Cause_Im_having_a_good_time_having_a_good_time.Pitch = 1
Cause_Im_having_a_good_time_having_a_good_time.Looped = false
Cause_Im_having_a_good_time_having_a_good_time.TimePosition = 35.3

STHAP = Instance.new("Sound", hed)
STHAP.SoundId = "http://www.roblox.com/asset/?id=1591656314"
STHAP.Volume = 10
STHAP.Pitch = 1
STHAP.Looped = false

forevergone = Instance.new("Sound", tors)
forevergone.SoundId = "http://www.roblox.com/asset/?id=1286436928"
forevergone.Volume = 10
forevergone.Pitch = 1
forevergone.Looped = true
forevergone.TimePosition = 24

-------------------------------------------------------
--Start Music Option--
-------------------------------------------------------
local Music = Instance.new("Sound",tors)
Music.Volume = 2.5
Music.SoundId = "rbxassetid://"
Music.Looped = true
Music.Pitch = 1 --Pitcher
Music:Play()
-------------------------------------------------------
--End Music Option--
-------------------------------------------------------
--hi fat >:)
-------------------------------------------------------
--Start Attacks N Stuff--
-------------------------------------------------------
local sine=0
function HitboxFunction(Pose, lifetime, siz1, siz2, siz3, Radie, Min, Max, kb, atype)
return
end
function GEtOuT()
	attack = true
	hum.WalkSpeed = 10
        Character.Head.face.Texture = "rbxassetid://494811799"
        CreateSound("814652778", hed, 10, 1)
        CreateSound("537371462", hed, 10, 1)
        local vel3 = Instance.new("BodyVelocity",tors)
        vel3.Velocity = Vector3.new(0,25,0)
        vel3.MaxForce = Vector3.new(10000000,10000000,10000000)
	for i = 0,12,0.1 do
		swait()
		CameraEnshaking(1, 2)
	        HitboxFunction(ll.CFrame, 0.01, 1, 1, 1, 7, 20, 99, 53, "Knockdown")
                rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0-255.45*i)), 0.3)
                tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-40), Rad(0), Rad(0)), 0.3)
                RW.C0 = clerp(RW.C0, CF(1.5, 0.5, 0) * angles(Rad(30), Rad(0), Rad(20)), 0.3)
                LW.C0 = clerp(LW.C0, CF(-1.5, 0.5, 0) * angles(Rad(-20), Rad(0), Rad(-30)), 0.3)
                LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), -0.3) * LHCF * angles(Rad(-5), Rad(0), Rad(20)), 0.15)
                RH.C0 = clerp(RH.C0, CF(1, -1, 0.3) * angles(Rad(0), Rad(90), Rad(-20)), 0.3)
	end
        vel3:Destroy()
        Character.Head.face.Texture = "rbxassetid://620619801"
	attack = false
        Humanoid.JumpPower = 50
	hum.WalkSpeed = 16
end

function GEtOuT2()
	attack = true
	hum.WalkSpeed = 10
        Humanoid.JumpPower = 0
        Character.Head.face.Texture = "rbxassetid://494811799"
        CreateSound("814652778", hed, 10, 1)
        CreateSound("537371462", hed, 10, 1)
        root.Velocity = root.CFrame.lookVector * 20
	for i = 0,12,0.1 do
		swait()
		CameraEnshaking(1, 2)
                root.Velocity = root.CFrame.lookVector * 50
	        HitboxFunction(ll.CFrame, 0.01, 1, 1, 1, 7, 10, 50, 53, "Knockdown")
                rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(90), Rad(0), Rad(0-255.45*i)), 0.3)
                tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-40), Rad(0), Rad(0)), 0.3)
                RW.C0 = clerp(RW.C0, CF(1.5, 0.5, 0) * angles(Rad(30), Rad(0), Rad(20)), 0.3)
                LW.C0 = clerp(LW.C0, CF(-1.5, 0.5, 0) * angles(Rad(-20), Rad(0), Rad(-30)), 0.3)
                LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), -0.3) * LHCF * angles(Rad(-5), Rad(0), Rad(20)), 0.15)
                RH.C0 = clerp(RH.C0, CF(1, -1, 0.3) * angles(Rad(0), Rad(90), Rad(-20)), 0.3)
	end
        Character.Head.face.Texture = "rbxassetid://620619801"
	attack = false
        Humanoid.JumpPower = 50
	hum.WalkSpeed = 16
end
function Flight() --wowthatsdiffrent
attack = true
Character.Head.face.Texture = "rbxassetid://269748407"
local ColorsArray ={ColorSequenceKeypoint.new(0, Color3.new(1,0,0)),
ColorSequenceKeypoint.new(0.16, Color3.new(1,1,1)),
ColorSequenceKeypoint.new(0.32, Color3.new(0,0,1)),
ColorSequenceKeypoint.new(0.48, Color3.new(1,1,1)),
ColorSequenceKeypoint.new(0.64, Color3.new(1,0,0)),
ColorSequenceKeypoint.new(0.80, Color3.new(1,1,1)),
ColorSequenceKeypoint.new(0.96, Color3.new(0,0,1)),
ColorSequenceKeypoint.new(1, Color3.new(1,1,1))}
local vel4 = Instance.new("BodyVelocity",ll)
vel4.Velocity = Vector3.new(0,4,0)
vel4.MaxForce = Vector3.new(10000000,10000000,10000000)
local Atch3 = Instance.new("Attachment",ll)Atch3.Position = Vector3.new(0,0.6,0)
local Atch4 = Instance.new("Attachment",ll)Atch4.Position = Vector3.new(0,-0.6,0)
local Trail2 = Instance.new("Trail",ll)Trail2.Attachment0 = Atch3 Trail2.Attachment1 = Atch4
Trail2.Texture = "rbxassetid://22636887" Trail2.Lifetime = 0.2 Trail2.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,0,0)})
Trail2.Color = ColorSequence.new(ColorsArray) Trail2.LightEmission = 1 
Trail2.Enabled = true
local Atch5 = Instance.new("Attachment",rl)Atch5.Position = Vector3.new(0,0.6,0)
local Atch6 = Instance.new("Attachment",rl)Atch6.Position = Vector3.new(0,-0.6,0)
local Trail3 = Instance.new("Trail",rl)Trail3.Attachment0 = Atch5 Trail3.Attachment1 = Atch6
Trail3.Texture = "rbxassetid://22636887" Trail3.Lifetime = 0.2 Trail3.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,0,0)})
Trail3.Color = ColorSequence.new(ColorsArray) Trail3.LightEmission = 1 
Trail3.Enabled = true
local Atch7 = Instance.new("Attachment",ra)Atch7.Position = Vector3.new(0,0.6,0)
local Atch8 = Instance.new("Attachment",ra)Atch8.Position = Vector3.new(0,-0.6,0)
local Trail4 = Instance.new("Trail",ra)Trail4.Attachment0 = Atch7 Trail4.Attachment1 = Atch8
Trail4.Texture = "rbxassetid://22636887" Trail4.Lifetime = 0.2 Trail4.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,0,0)})
Trail4.Color = ColorSequence.new(ColorsArray) Trail4.LightEmission = 1 
Trail4.Enabled = true
local Atch9 = Instance.new("Attachment",la)Atch9.Position = Vector3.new(0,0.6,0)
local Atch10 = Instance.new("Attachment",la)Atch10.Position = Vector3.new(0,-0.6,0)
local Trail5 = Instance.new("Trail",la)Trail5.Attachment0 = Atch9 Trail5.Attachment1 = Atch10
Trail5.Texture = "rbxassetid://22636887" Trail5.Lifetime = 0.2 Trail5.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,0,0)})
Trail5.Color = ColorSequence.new(ColorsArray) Trail5.LightEmission = 1 
Trail5.Enabled = true
local Atch1 = Instance.new("Attachment",Torso)Atch1.Position = Vector3.new(0,2,0)
local Atch2 = Instance.new("Attachment",Torso)Atch2.Position = Vector3.new(0,-2.5,0)
local Trail = Instance.new("Trail",Torso)Trail.Attachment0 = Atch1 Trail.Attachment1 = Atch2
Trail.Texture = "rbxassetid://22636887" Trail.Lifetime = 0.2 Trail.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,0,0)})
Trail.Color = ColorSequence.new(ColorsArray) Trail.LightEmission = 1 
Trail.Enabled = false
ragdoll(char)
wait(1)
Character.Head.face.Texture = "rbxassetid://249062487"
CreateSound("948494432", hed, 10, 1)
wait(2)
Character.Head.face.Texture = "rbxassetid://269748407"
CreateSound("633394595", hed, 10, 1)
wait(2)
Character.Head.face.Texture = "rbxassetid://494811799"
STHAP:play()
wait(11)
forevergone:play()
end

function OBJECTION()
	attack = true
	hum.WalkSpeed = 10
        Character.Head.face.Texture = "rbxassetid://55831869"
	CreateSound("330859085", hed, 10, 1)
	for i = 0,8,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.2) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(180), Rad(0), Rad(5)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
	end
	attack = false
        Character.Head.face.Texture = "rbxassetid://620619801"
	hum.WalkSpeed = 16
end

function Hello()
	attack = true
	hum.WalkSpeed = 10
        Character.Head.face.Texture = "rbxassetid://334668738"
	CreateSound("855338765", hed, 10, 0.9)
	for i = 0,3,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.2) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(180), Rad(20), Rad(-5)), 0.1)
	end
	attack = false
        Character.Head.face.Texture = "rbxassetid://620619801"
	hum.WalkSpeed = 16
end

function Victory()
	attack = true
	hum.WalkSpeed = 1.01
        Character.Head.face.Texture = "rbxassetid://616284160"
        Humanoid.Jump = true
        CreateSound("130834939", hed, 10, 1)
        for i = 0,3.7,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.2) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-40)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-40)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(180), Rad(20), Rad(-5)), 0.1)
        end
        Humanoid.Jump = true
        for i = 0,3.7,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.2) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(40)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(40)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-180), Rad(-25), Rad(5)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-0)), 0.1)
        end
        Humanoid.Jump = true
        for i = 0,3.7,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.2) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-40)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-40)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(180), Rad(20), Rad(-5)), 0.1)
        end
        Humanoid.Jump = true
        for i = 0,3.7,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.2) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(40)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(40)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-180), Rad(-25), Rad(5)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-0)), 0.1)
        end
        Humanoid.Jump = true
        for i = 0,3.7,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.2) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-40)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-40)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(180), Rad(20), Rad(-5)), 0.1)
        end
	attack = false
        Character.Head.face.Texture = "rbxassetid://620619801"
	hum.WalkSpeed = 16
end

function ShutTheHellUp()
	attack = true
	hum.WalkSpeed = 2.01
        Character.Head.face.Texture = "rbxassetid://963148419"
	CreateSound("336377340", hed, 10, 1)
	for i = 0,3,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(90), Rad(0), Rad(5)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
	end
	for i = 0,1.2,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(20), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(90), Rad(0), Rad(5)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
	end
	for i = 0,1.2,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-5), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(90), Rad(0), Rad(5)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
	end
	for i = 0,1.2,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.2) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(20), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(90), Rad(0), Rad(5)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
	end
	for i = 0,1.2,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.2) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-5), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(90), Rad(0), Rad(5)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
	end
	for i = 0,2,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(120), Rad(0), Rad(5)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
	end
	for i = 0,2,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(90), Rad(0), Rad(5)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
	end
	hum.WalkSpeed = 16
        Character.Head.face.Texture = "rbxassetid://620619801"
	attack = false
end

function SpinMeDad() --YOU SPIN ME RIGHT ROUND BABY RIGHT ROUND
	attack = true
	hum.WalkSpeed = 5
        Humanoid.JumpPower = 175
        Character.Head.face.Texture = "rbxassetid://1223903433"
	CreateSound("145799973", hed, 10, 1)
        local vel2 = Instance.new("BodyVelocity",tors)
        vel2.Velocity = Vector3.new(0,1.2,0)
        vel2.MaxForce = Vector3.new(10000000,10000000,10000000)
	for i = 0,60,0.1 do
	        HitboxFunction(ll.CFrame, 0.01, 1, 1, 1, 7, 5, 20, 53, "Knockdown")
		swait()
		CameraEnshaking(1, 1)
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0-255.45*i)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(90)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-90)), 0.1)
	end
	hum.WalkSpeed = 16
        vel2:Destroy()
        Character.Head.face.Texture = "rbxassetid://620619801"
        Humanoid.JumpPower = 50
	attack = false
end

function EndMySufferingV2() --why
	attack = true
	hum.WalkSpeed = 1.01
        Character.Head.face.Texture = "rbxassetid://202210455"
        local A = math.random(1,5)
        if A == 1 then
            meme.SoundId = "rbxassetid://295810519"
        end
        if A == 2 then
            meme.SoundId = "rbxassetid://1124778077"
        end
        if A == 3 then
            meme.SoundId = "rbxassetid://464157070"
        end
        if A == 4 then
            meme.SoundId = "rbxassetid://146334595"
        end
        if A == 5 then
            meme.SoundId = "rbxassetid://145536915"
        end
        meme:Play()
        bass:Play()
        joyemoji.Rate = 70
        LIT.Rate = 70
        ok.Rate = 70
        toast.Rate = 70
        
	for i = 0,50,0.1 do
		swait()
	CameraEnshaking(1, 10)
        bass.Parent = hed
        meme.Parent = hed
	rootj.C0=clerp(rootj.C0,RootCF*CF(0,0,-0.1+0.1*math.cos(sine/20))*angles(math.rad(15),math.rad(-10),math.rad(0)),0.15)
	tors.Neck.C0=clerp(tors.Neck.C0,necko*angles(math.rad(35),math.rad(0),math.rad(0)),.3)
	RH.C0=clerp(RH.C0,CF(1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*RHCF*angles(math.rad(-5),math.rad(0),math.rad(0)),0.15)
	LH.C0=clerp(LH.C0,CF(-1,-.9-0.1*math.cos(sine/20),.025*math.cos(sine/20))*LHCF*angles(math.rad(-5),math.rad(-0),math.rad(-20)),0.15)
	RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5+0.1*math.sin(sine/30), -0.6) * angles(math.rad(-0), math.rad(10), math.rad(-110)), 0.1)
	LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5+0.1*math.sin(sine/30), 0.055*math.cos(sine/20)) * angles(math.rad(-0), math.rad(-10), math.rad(-105)), 0.1)
	end
        bass:Stop()
        meme:Stop()
        joyemoji.Rate = 0
        LIT.Rate = 0
        ok.Rate = 0
        toast.Rate = 0
        Character.Head.face.Texture = "rbxassetid://620619801"
	attack = false
	hum.WalkSpeed = 16
end

function HELP()
	attack = true
	hum.WalkSpeed = 1.01
        Character.Head.face.Texture = "rbxassetid://307972876"
	CreateSound("1123321019", hed, 10, 1)
	for i = 0,15,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(0.7, -0.01 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-0.7, -0.01 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(0.9, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-0.9, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
	end
  	CreateSound("198462271", hed, 10, 1)
	for i = 0,8,0.1 do
                Character.Head.face.Texture = "rbxassetid://341497730"
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(0.7, -0.01 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-0.7, -0.01 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(0.9, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-0.9, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
	end
	for i = 0,8,0.1 do
                Character.Head.face.Texture = "rbxassetid://341497730"
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(60), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(0.7, -0.01 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-0.7, -0.01 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(0.9, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-0.9, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
	end
  	CreateSound("948494432", hed, 10, 1)
	for i = 0,7.5,0.1 do
                Character.Head.face.Texture = "rbxassetid://249062487"
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(60), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(0.7, -0.01 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-0.7, -0.01 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(0.9, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-0.9, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
	end
  	CreateSound("1542642349", hed, 10, 1)
	for i = 0,10,0.1 do
                Character.Head.face.Texture = "rbxassetid://270636807"
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(0.7, -0.01 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-0.7, -0.01 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(0.9, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-0.9, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
	end
  	CreateSound("269597232", hed, 10, 1)
	for i = 0,6,0.1 do
                Character.Head.face.Texture = "rbxassetid://265057155"
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(0.7, -0.01 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-0.7, -0.01 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(0.9, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-0.9, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
	end
	attack = false
        Character.Head.face.Texture = "rbxassetid://620619801"
	hum.WalkSpeed = 16
end

function Choose()
	attack = true
	hum.WalkSpeed = 1.01
        Character.Head.face.Texture = "rbxassetid://374187112"
	CreateSound("130784263", hed, 10, 1)
	for i = 0,4,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(110), Rad(0), Rad(0)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(110), Rad(0), Rad(0)), 0.1)
	end
	for i = 0,5,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(35), Rad(0), Rad(-10)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(35), Rad(0), Rad(10)), 0.1)
	end
	attack = false
        Character.Head.face.Texture = "rbxassetid://620619801"
	hum.WalkSpeed = 16
end

function slap()
	attack = true
	hum.WalkSpeed = 10
	CreateSound("146163534", hed, 10, 1)


	CameraEnshaking(1, 2)
	for i = 0,4,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(20), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(20), Rad(0), Rad(5)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(115 + 4), Rad(45), Rad(50)), 0.1)
	end
        Character.Head.face.Texture = "rbxassetid://620619801"
	attack = false
	hum.WalkSpeed = 16
end

function MYSPAGHETTTTTTT() --ow
	attack = true
	hum.WalkSpeed = 1.01
	CreateSound("1282149571", hed, 10, 1)

	CameraEnshaking(1, 2.2)
	for i = 0,4,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(20), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(20), Rad(0), Rad(5)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(115 + 4), Rad(45), Rad(50)), 0.1)
	end
	for i = 0,5,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(110), Rad(0), Rad(0)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(110), Rad(0), Rad(0)), 0.1)
	end
	for i = 0,6,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(35), Rad(0), Rad(-10)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(35), Rad(0), Rad(10)), 0.1)
	end
	attack = false
        Character.Head.face.Texture = "rbxassetid://620619801"
	hum.WalkSpeed = 16
end


function dead()
	attack = true
	hum.WalkSpeed = 0.20
	CreateSound("137225991", hed, 10, 1)
        Character.Head.face.Texture = "rbxassetid://297512410"
	for i = 0,1.1,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(90)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-90)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(140)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-140)), 0.1)
	end
	for i = 0,1.1,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(90), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(90)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-90)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(140)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-140)), 0.1)
	end
	for i = 0,1.1,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(180), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(90)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-90)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(140)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-140)), 0.1)
	end
	for i = 0,1.1,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(270), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(90)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-90)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(140)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-140)), 0.1)
	end
	for i = 0,1.1,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(90)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-90)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(140)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-140)), 0.1)
	end
	for i = 0,1.1,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(90), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(90)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-90)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(140)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-140)), 0.1)
	end
	for i = 0,1.1,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(180), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(90)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-90)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(140)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-140)), 0.1)
	end
	for i = 0,1.1,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(270), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(90)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-90)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(140)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-140)), 0.1)
	end
	for i = 0,1.1,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(90)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-90)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(140)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-140)), 0.1)
	end
        Character.Head.face.Texture = "rbxassetid://273309187"
	for i = 0,9,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -2.59 + 0.1) * angles(Rad(-90), Rad(90), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(30)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-30)), 0.1)
	end
	attack = false
        Character.Head.face.Texture = "rbxassetid://620619801"
	hum.WalkSpeed = 16
end

function hap() --much hap
	attack = true
	hum.WalkSpeed = 0.10
	CreateSound("363808674", hed, 10, 1)
        Character.Head.face.Texture = "rbxassetid://315792941"
	for i = 0,12,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(180)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-0)), 0.1)
	end
	CreateSound("233168827", hed, 10, 1)
        Character.Head.face.Texture = "rbxassetid://335761015"
	for i = 0,10,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(180)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-0)), 0.1)
	end
        CreateSound("363808674", hed, 10, 1)
	attack = false
        Character.Head.face.Texture = "rbxassetid://620619801"
	hum.WalkSpeed = 16
end

function HAAAAA() --KONO POWA
	attack = true
	hum.WalkSpeed = 1.01
        Character.Head.face.Texture = "rbxassetid://305068389"
        chargeup.Pitch = 1
	for i = 0,7,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(150), Rad(0), Rad(0)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 1 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(150), Rad(0), Rad(-0)), 0.1)
	end
        Character.Head.face.Texture = "rbxassetid://313921371"
        chargeup:play()
	for i = 0,30,0.1 do
		swait()
		CameraEnshaking(1, 2)
                chargeup.Parent = hed
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(15), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1.1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-20), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1.1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-20), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.4, 0.0000000005 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(150), Rad(0), Rad(0)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.4, 0.0000000005 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(150), Rad(0), Rad(-0)), 0.1)
	end
        chargeup:stop()
        chargeup.Pitch = 1.1
        chargeup.TimePosition = 1
        chargeup:play()
        Character.Head.face.Texture = "rbxassetid://304942859"
        for i, v in pairs(c:children()) do
        if v.ClassName == "Part" then
        local tra = trazx:clone()
        tra.Parent = v
        tra.LightEmission = 1
        tra.Color = ColorSequence.new(Color3.new(0, 0.6666666666666666, 1))
        tra.Rate = 15
        tra.Rotation = NumberRange.new(-5, 5)
        tra.Lifetime = NumberRange.new(1.5, 2)
        tra.Size = NumberSequence.new({
          NumberSequenceKeypoint.new(0, 0.1, 0),
          NumberSequenceKeypoint.new(1, 0, 0)
        })
        tra.Transparency = NumberSequence.new({
          NumberSequenceKeypoint.new(0, 1, 0),
          NumberSequenceKeypoint.new(0.135, 0, 0),
          NumberSequenceKeypoint.new(0.875, 0, 0),
          NumberSequenceKeypoint.new(1, 1, 0)
        })
        tra.Speed = NumberRange.new(0.5)
        tra.VelocitySpread = 360
        tra.VelocityInheritance = 0.5
        tra.ZOffset = 2
        tra.Acceleration = Vector3.new(0, 2.5, 0)
      end
    end
    local tra = trazx:clone()
    tra.Parent = c.HumanoidRootPart
    tra.Texture = "rbxassetid://347730682"
    tra.LightEmission = 0.8
    tra.Color = ColorSequence.new(Color3.new(0, 0.6666666666666666, 1))
    tra.Rate = 250
    tra.Rotation = NumberRange.new(-5, 5)
    tra.Lifetime = NumberRange.new(0.75)
    tra.Size = NumberSequence.new({
      NumberSequenceKeypoint.new(0, 4.81, 0.875),
      NumberSequenceKeypoint.new(1, 2.13, 0.875)
    })
    tra.Transparency = NumberSequence.new({
      NumberSequenceKeypoint.new(0, 1, 0),
      NumberSequenceKeypoint.new(0.0399, 0.85, 0),
      NumberSequenceKeypoint.new(0.394, 0.9, 0),
      NumberSequenceKeypoint.new(0.699, 1, 0),
      NumberSequenceKeypoint.new(1, 1, 0)
    })
    tra.Speed = NumberRange.new(15)
    tra.VelocitySpread = 360
    tra.VelocityInheritance = 0.5
    tra.ZOffset = 3.5
    tra.Acceleration = Vector3.new(0, 25, 0)
	for i = 0,35,0.1 do
		swait()
                ohno.Parent = hed
		CameraEnshaking(1, 3)
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(60), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1.1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-20), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1.1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-20), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.4, 0.0000000005 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(150), Rad(0), Rad(0)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.4, 0.0000000005 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(150), Rad(0), Rad(-0)), 0.1)
	end
        chargeup:stop()
        chargeup.Pitch = 1.3
        chargeup.TimePosition = 1
        chargeup:play()
        tra:Destroy()
        tra:Destroy()
        Character.Head.face.Texture = "rbxassetid://280233855"
    local tra = trazx:clone()
    tra.Parent = c.HumanoidRootPart
    tra.Texture = "rbxassetid://347730682"
    tra.LightEmission = 0.8
    tra.Color = ColorSequence.new(Color3.new(1, 0, 0))
    tra.Rate = 250
    tra.Rotation = NumberRange.new(-5, 5)
    tra.Lifetime = NumberRange.new(0.3)
    tra.Size = NumberSequence.new({
      NumberSequenceKeypoint.new(0, 8, 0.875),
      NumberSequenceKeypoint.new(1, 10, 0.875)
    })
    tra.Transparency = NumberSequence.new({
      NumberSequenceKeypoint.new(0, 1, 0),
      NumberSequenceKeypoint.new(0.0399, 0.531, 0),
      NumberSequenceKeypoint.new(0.394, 0.906, 0),
      NumberSequenceKeypoint.new(0.699, 1, 0),
      NumberSequenceKeypoint.new(1, 1, 0)
    })
	for i = 0,32,0.1 do
		swait()
		CameraEnshaking(1, 5)
                chargeup.Parent = hed

		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-65), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1.1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-20), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1.1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-20), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.4, 0.0000000005 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(150), Rad(0), Rad(0)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.4, 0.0000000005 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(150), Rad(0), Rad(-0)), 0.1)
	end
        chargeup:stop()
        CreateSound("681582832", hed, 10, 1)
        game.Players.LocalPlayer.Character:BreakJoints()
        local S = Instance.new("Explosion",workspace)    
        S.Position = tors.Position
        S.BlastPressure = 9
        S.BlastRadius = 30
        S.ExplosionType = 0
	attack = false
	hum.WalkSpeed = 16

        tra:Destroy()
	CameraEnshaking(4, 30)
        error("WARNING, TO MUCH ENERGY.")
end

function NEN()
	attack = true
	hum.WalkSpeed = 1.01
	CreateSound("230292011", hed, 10, 1)

	for i = 0,4,0.1 do
		swait()
		CameraEnshaking(1, 3)
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-90), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(120)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-120)), 0.1)
	end
	attack = false
        Character.Head.face.Texture = "rbxassetid://620619801"
	hum.WalkSpeed = 16
end

function FLYSKYHIGH()
	attack = true
        timetofly = false
	hum.WalkSpeed = 0.05
        Character.Head.face.Texture = "rbxassetid://705269463"
        Cause_Im_having_a_good_time_having_a_good_time:Play()
        Cause_Im_having_a_good_time_having_a_good_time.TimePosition = 35.3
        Humanoid.JumpPower = 0
	for i = 0,300,0.1 do --thatsalongtime
		swait()
		CameraEnshaking(1, 7)
	        HitboxFunction(ll.CFrame, 0.01, 1, 1, 1, 7, 75, 500, 100, "Knockdown")
                Cause_Im_having_a_good_time_having_a_good_time.Parent = hed
                root.Velocity = root.CFrame.lookVector * 225
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0-255.45*i), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0-255.45*i)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0-255.45*i)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-75), Rad(0), Rad(0)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-75), Rad(0), Rad(0)), 0.1)
	end
        Cause_Im_having_a_good_time_having_a_good_time:Stop()
	attack = false
        Humanoid.JumpPower = 50
        Character.Head.face.Texture = "rbxassetid://620619801"
	hum.WalkSpeed = 16
        wait(45)
        timetofly = true
        warn("You can FLY SKY HIGH Now! Go Nuts!") --please dont go nuts
end


function highnoon()
	attack = true
	hum.WalkSpeed = 1.01
	CreateSound("495316660", hed, 10, 1)
        Character.Head.face.Texture = "rbxassetid://155195214"
	CameraEnshaking(2, 4)
	local Blobby = Instance.new("Part", char)
Blobby.Name = "Blob"
Blobby.CanCollide = false
Blobby.BrickColor = BrickColor.new("Really black")
Blobby.Transparency = 0
Blobby.Material = "Plastic"
Blobby.Size = Vector3.new(1, 1, 2)
Blobby.TopSurface = Enum.SurfaceType.Smooth
Blobby.BottomSurface = Enum.SurfaceType.Smooth

local Weld = Instance.new("Weld", Blobby)
Weld.Part0 = ra
Weld.Part1 = Blobby
Weld.C1 = CFrame.new(0, -.4, -1.6) *angles(Rad(180), Rad(0), Rad(180))
Weld.C0 = CFrame.Angles(math.rad(-90),0,0)

local M2 = Instance.new("SpecialMesh")
M2.Parent = Blobby
M2.MeshId = "http://www.roblox.com/asset/?id=432256490"
M2.TextureId = "http://www.roblox.com/asset/?id=432256526"
M2.Scale = Vector3.new(.002, .002, .002)
	for i = 0,7.75,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(90)), 0.2)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(30), Rad(0), Rad(0)), 0.2)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.2)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.2)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(-.6), Rad(180)), 0.2)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-45), Rad(-.6), Rad(136 - 4.5 * Sin(sine / 20))), 0.2)
        end
	for i = 0,16.5,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(90)), 0.2)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(30), Rad(0), Rad(0)), 0.2)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.2)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.2)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(-.6), Rad(90)), 0.2)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-45), Rad(-.6), Rad(136 - 4.5 * Sin(sine / 20))), 0.2)
	end
	Blobby.Transparency = 1
	Blobby:Destroy()
	attack = false
        Character.Head.face.Texture = "rbxassetid://620619801"
	hum.WalkSpeed = 16
end

function somuchcancerwhy() --o no
	attack = true
	hum.WalkSpeed = 0.10
        Character.Head.face.Texture = "rbxassetid://315074049"
        local A = math.random(1,13)
        if A == 1 then
            ohno.SoundId = "rbxassetid://295810519"
            ohno.TimePosition = 1
        end
        if A == 2 then
            ohno.SoundId = "rbxassetid://488472970"
            ohno.TimePosition = 2
        end
        if A == 3 then
            ohno.SoundId = "rbxassetid://917045199"
            ohno.TimePosition = 3
        end
        if A == 4 then
            ohno.SoundId = "rbxassetid://324205173"
            ohno.TimePosition = 1
        end
        if A == 5 then
            ohno.SoundId = "rbxassetid://376134741"
            ohno.TimePosition = 8
        end
        if A == 6 then
            ohno.SoundId = "rbxassetid://164147183"
            ohno.TimePosition = 0
        end
        if A == 7 then
            ohno.SoundId = "rbxassetid://825526716"
            ohno.TimePosition = 1
        end
        if A == 8 then
            ohno.SoundId = "rbxassetid://185460366"
            ohno.TimePosition = 0
        end
        if A == 9 then
            ohno.SoundId = "rbxassetid://273319633"
            ohno.TimePosition = 1
        end
        if A == 10 then
            ohno.SoundId = "rbxassetid://506212392"
            ohno.TimePosition = 2
        end
        if A == 11 then
            ohno.SoundId = "rbxassetid://708297448"
            ohno.TimePosition = 4
        end
        if A == 12 then
            ohno.SoundId = "rbxassetid://497199103"
            ohno.TimePosition = 9
        end
        if A == 13 then
            ohno.SoundId = "rbxassetid://152833989"
            ohno.TimePosition = 1
        end
        ohno:Play()
	for i = 0,100,0.1 do
		swait()
     		CameraEnshaking(2, 3)
                ohno.Parent = hed
	        char.Torso.Neck.C0 = char.Torso.Neck.C0 * CFrame.Angles(math.random(-10,10),math.random(-10,10),math.random(-10,10))
	end
	attack = false
        ohno:Stop()
        Character.Head.face.Texture = "rbxassetid://620619801"
	hum.WalkSpeed = 16
end

function WRY() --WRYYYYYYY
	attack = true
	hum.WalkSpeed = 0.30
	CreateSound("794081034", hed, 10, 1)
        Character.Head.face.Texture = "rbxassetid://396389196"
	for i = 0,2,0.1 do
		swait()
		CameraEnshaking(1, 2)
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(30), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(140), Rad(60)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(-140), Rad(-60)), 0.1)
	end
	for i = 0,14.7,0.1 do
		swait()
		CameraEnshaking(1, 3)
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 1, -1 + 0.1) * angles(Rad(-75), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(65), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1.1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-70)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1.1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(70)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(45), Rad(0), Rad(40)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(45), Rad(-0), Rad(-40)), 0.1)
	end
	attack = false
        Character.Head.face.Texture = "rbxassetid://620619801"
	hum.WalkSpeed = 16
end

function BOI()
	attack = true
	hum.WalkSpeed = 1.01
	CreateSound("390901873", hed, 10, 1)
        Character.Head.face.Texture = "rbxassetid://282463320"
	for i = 0,4,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(50), Rad(90)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(-50), Rad(-90)), 0.1)
	end
	for i = 0,4,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(30), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(140), Rad(60)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(-140), Rad(-60)), 0.1)
	end
	attack = false
        Character.Head.face.Texture = "rbxassetid://620619801"
	hum.WalkSpeed = 16
end

function WhatHuh()
	attack = true
	hum.WalkSpeed = 1.01
	CreateSound("130766865", hed, 10, 1)
        Character.Head.face.Texture = "rbxassetid://276732672"
	for i = 0,4,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(26), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(120)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-120)), 0.1)
	end
 	for i = 0,6.7,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(-26), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(120)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-120)), 0.1)
	end
	for i = 0,8.1,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(26), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(120)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-120)), 0.1)
	end
	for i = 0,1,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(40), Rad(-26), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(120)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-120)), 0.1)
	end
	for i = 0,1,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(40), Rad(26), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(120)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-120)), 0.1)
	end
 	for i = 0,4,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(-26), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(120)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-120)), 0.1)
	end
	attack = false
        Character.Head.face.Texture = "rbxassetid://620619801"
	hum.WalkSpeed = 16
end

function NothingPersonal()
	if mouse.Target.Parent ~= char and mouse.Target.Parent.Parent ~= char and mouse.Target.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
		local HITBODY = mouse.Target.Parent
		local TORS = HITBODY:FindFirstChild("Torso") or HITBODY:FindFirstChild("UpperTorso")
		local HEAD = HITBODY:FindFirstChild("Head")
		local HUMAN = mouse.Target.Parent:FindFirstChildOfClass("Humanoid")
		if TORS ~= nil and HUMAN ~= nil then
	attack = true
	root.CFrame = TORS.CFrame * CFrame.new(-1,0,3)
	TORS.Anchored = true
	hum.WalkSpeed = 0
        Character.Head.face.Texture = "rbxassetid://40770311"
	CreateSound("1255922819", hed, 10, 1)
	CameraEnshaking(2, 4)
		end
		wait(3.5)
		for i = 0,9,0.1 do
			swait()
			for i = 1,2 do
	                HitboxFunction(ll.CFrame, 0.01, 1, 1, 1, 7, 1, 10, 53, "Knockdown")
                        CameraEnshaking(1, 7)
			Effects.Sphere.Create(BrickColor.new("Persimmon"), TORS.CFrame*CFrame.new(math.random(-200,200)/100,math.random(-300,200)/100,math.random(-100,100)/100), 1, 1, 1, 15, 15, 15, 0.2)
		    end
		end
		wait(.5)
		TORS.Anchored = false
		attack = false
        Character.Head.face.Texture = "rbxassetid://620619801"
	hum.WalkSpeed = 16
	end
end

function VeryMuchWorrying()
	attack = true
	hum.WalkSpeed = 1.01
        Character.Head.face.Texture = "rbxassetid://111523405"
	CreateSound("1395854043", hed, 10, 1)
	for i = 0,14,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.3, 0.9 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-145)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.3, 0.9 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(145)), 0.1)
	end
	attack = false
        Character.Head.face.Texture = "rbxassetid://620619801"
	hum.WalkSpeed = 16
end

function Ashes() --Straight from... Whatever it was called.
        attack = true
	hum.WalkSpeed = 1.01
        Character.Head.face.Texture = "rbxassetid://360687027"
	CreateSound("290084602", tors, 10, 1)
	for i = 0,6.2,0.1 do
			swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-30), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-5), Rad(0), Rad(-0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-0), Rad(0), Rad(145)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-0), Rad(0), Rad(-145)), 0.1)
	end
	for i = 0,6.2,0.1 do
			swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(20), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-5), Rad(0), Rad(20)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-5), Rad(0), Rad(-20)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-30), Rad(0), Rad(15)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-30), Rad(0), Rad(-15)), 0.1)
	end
	attack = false
        Character.Head.face.Texture = "rbxassetid://620619801"
	hum.WalkSpeed = 16
end

function AnotherOne() --WhAT ANOTHER ONE
	attack = true
	hum.WalkSpeed = 1.01
	local icri = CreateSound("1205111204", hed, 10, 1)
	swait(165)
	local FRAME = tors.CFrame
	repeat
		swait()
                Character.Head.face.Texture = "rbxassetid://582931093"
		CameraEnshaking(1, 10)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.3, 0.9 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(90)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.3, 0.9 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-90)), 0.1)
		tors.CFrame = FRAME * CF(0,1,0)
		swait()
		tors.CFrame = FRAME
	until icri.Playing == false
        Character.Head.face.Texture = "rbxassetid://620619801"
	attack = false
	hum.WalkSpeed = 16
end

function Dance()
	attack = true
	hum.WalkSpeed = 1.01
	CreateSound("838766490", hed, 10, 1)
        Character.Head.face.Texture = "rbxassetid://258591579"
	for i = 0,2,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(180)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-180)), 0.1)
	end
	for i = 0,4,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(0), Rad(180)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(-0), Rad(-180)), 0.1)
	end
	for i = 0,4,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(30)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(30)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(0), Rad(180)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(-0), Rad(-180)), 0.1)
	end
	for i = 0,4,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(0), Rad(180)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(-0), Rad(-180)), 0.1)
	end
	for i = 0,4,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(30)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(30)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(0), Rad(180)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(-0), Rad(-180)), 0.1)
	end
	for i = 0,4,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(0), Rad(180)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(-0), Rad(-180)), 0.1)
	end
	for i = 0,4,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(30)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(30)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(0), Rad(180)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(-0), Rad(-180)), 0.1)
	end
	for i = 0,4,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(0), Rad(180)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(-0), Rad(-180)), 0.1)
	end
	for i = 0,4,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(30)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(30)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(0), Rad(180)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(-0), Rad(-180)), 0.1)
	end
	for i = 0,4,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(0), Rad(180)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(-0), Rad(-180)), 0.1)
	end
	for i = 0,4,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(30)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(30)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(0), Rad(180)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(-0), Rad(-180)), 0.1)
	end
	for i = 0,4,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(0), Rad(180)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(-0), Rad(-180)), 0.1)
	end
	for i = 0,4,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(30)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(30)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(0), Rad(180)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(-0), Rad(-180)), 0.1)
	end
	for i = 0,4,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(0), Rad(180)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(-0), Rad(-180)), 0.1)
	end
	for i = 0,4,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(30)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(30)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(0), Rad(180)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(-0), Rad(-180)), 0.1)
	end
	for i = 0,3,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(-30)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(50), Rad(0), Rad(180)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-50), Rad(-0), Rad(-180)), 0.1)
	end
	attack = false
        Character.Head.face.Texture = "rbxassetid://620619801"
	hum.WalkSpeed = 16
end

function kyu_will_break_your_neck_asdf_longest_function_name_ever_xd()
attack = true
        Character.Head.face.Texture = "rbxassetid://266304560"
	for i = 0,6,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.3, 0.9 + 0.05 * Sin(sine / 30), 0.2 * Cos(sine / 20)) * angles(Rad(170), Rad(0), Rad(-15)), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.3, 0.8 + 0.05 * Sin(sine / 30), -0.025 * Cos(sine / 20)) * angles(Rad(140), Rad(0), Rad(15)), 0.1)
	end
    CreateSound("1093102664", hed, 10, 1)
	CameraEnshaking(3, 8)
	for i = 0,2,0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1) * angles(Rad(5), Rad(0), Rad(0)), 0.15)
		tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(10), Rad(40), Rad(0)), 0.4)
		RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 , 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
		RW.C0 = clerp(RW.C0, CF(1.3, 0.9 + 0.05 * Sin(sine / 30), 0.2 * Cos(sine / 20)) * angles(Rad(200), Rad(0), Rad(-40)), 0.4)
		LW.C0 = clerp(LW.C0, CF(-1.3, 0.8 + 0.05 * Sin(sine / 30), -0.025 * Cos(sine / 20)) * angles(Rad(40), Rad(0), Rad(40)), 0.4)
	end
Character.Head.face.Texture = "rbxassetid://30128383"

ragdoll(char)
CreateSound("534269232", hed, 5, 1)
error("Seems like you just died.")
end

MoreTaunts = false
mouse.KeyDown:connect(function(key)
	if attack == false then
		if MoreTaunts == false then
		if key == 'q' then
			GEtOuT()
                elseif key == 'e' then
                        GEtOuT2()
                elseif key == 'x' then
                        OBJECTION()
                elseif key == 'n' then
                        BOI()
                elseif key == 'u' then
                        Victory()
                elseif key == '3' then
                        hap()
                elseif key == '6' then
                        Flight()
                elseif key == '9' and timetofly then
                        FLYSKYHIGH()
                elseif key == '9' then
                        local A = math.random(1,10)
                        if A == 1 then
                            warn ("This has a Cooldown, Please wait. :>")
                        end
                        if A == 2 then
                            warn ("You can't Fly All day, you know.")
                        end
                        if A == 3 then
                            warn ("Calm down there.")
                        end
                        if A == 4 then
                            warn ("Take a Break.")
                        end
                        if A == 5 then
                            warn ("*Elevator Music plays in the backround*")
                        end
                        if A == 6 then
                            warn ("I know, You want to FLY SKY HIGH, but wait a little bit.")
                        end
                        if A == 7 then
                            warn ("Can you wait a LITTLE Longer?")
                        end
                        if A == 8 then
                            warn ("Like a tiger defying the laws of gravity...")
                        end
                        if A == 9 then
                            warn ("DON'T STOP ME NNNNNOOOOOOOOWWWW")
                        end
                        if A == 10 then
                            warn ("Oh, I'm burnin' through the sky, Yeah!")
                        end
                elseif key == 'k' then
                        Hello()
                elseif key == '5' then
                        HAAAAA()
                elseif key == '4' then
                        Dance()
                elseif key == '1' then
                        HELP()
		elseif key == '2' then
			dead()
                elseif key == 'j' then
                        WhatHuh()
		elseif key == 'l' then
			ShutTheHellUp()
                elseif key == 'c' then
                        Choose()
		elseif key == 'r' then
			MYSPAGHETTTTTTT()
		elseif key == 't' then
			SpinMeDad()
		elseif key == 'y' then
			EndMySufferingV2()
		elseif key == 'f' then
			NEN()
		elseif key == 'z' then
			NothingPersonal()
		elseif key == '7' then
			somuchcancerwhy()
		elseif key == '8' then
			highnoon()
		elseif key == 'v' then
			VeryMuchWorrying()
                elseif key == 'b' then
                        Ashes()
                elseif key == 'p' then
                        kyu_will_break_your_neck_asdf_longest_function_name_ever_xd()
                elseif key == 'g' then
                        AnotherOne()
                elseif key == 'h' then
                        slap()
                elseif key == 'm' then
                        WRY()
		end
		end
		end
	end)

-------------------------------------------------------
--End Attacks N Stuff--
-------------------------------------------------------




while jumping do
 Humanoid.Jump = true
 wait(0.9)
end




-------------------------------------------------------
--Start Animations--
-------------------------------------------------------
local equipped = false
local idle = 0
local change = 1
local val = 0
local toim = 0
local idleanim = 0.4
hum.Animator.Parent = nil
while true do
	swait()
	sine = sine + change
	local torvel = (root.Velocity * Vector3.new(1, 0, 1)).magnitude
	local velderp = root.Velocity.y
	hitfloor, posfloor = rayCast(root.Position, CFrame.new(root.Position, root.Position - Vector3.new(0, 1, 0)).lookVector, 4, char)
	if equipped == true or equipped == false then
		if attack == false then
			idle = idle + 1
		else
			idle = 0
		end
		if 1 < root.Velocity.y and hitfloor == nil then
			Anim = "Jump"
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(10), Rad(0), Rad(0)), 0.3)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(-40), Rad(0), Rad(0)), 0.3)
				RW.C0 = clerp(RW.C0, CF(1.5, 0.5, 0) * angles(Rad(30), Rad(0), Rad(20)), 0.3)
				LW.C0 = clerp(LW.C0, CF(-1.5, 0.5, 0) * angles(Rad(-20), Rad(0), Rad(-30)), 0.3)
				LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), -0.3) * LHCF * angles(Rad(-5), Rad(0), Rad(20)), 0.15)
				RH.C0 = clerp(RH.C0, CF(1, -1, 0.3) * angles(Rad(0), Rad(90), Rad(-20)), 0.3)
			end
		elseif -1 > root.Velocity.y and hitfloor == nil then
			Anim = "Fall"
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(-5), Rad(0), Rad(0)), 0.3)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(40), Rad(0), Rad(0)), 0.3)
				RW.C0 = clerp(RW.C0, CF(1.5, 0.5, 0) * angles(Rad(30), Rad(0), Rad(20)), 0.3)
				LW.C0 = clerp(LW.C0, CF(-1.5, 0.5, 0) * angles(Rad(-20), Rad(0), Rad(-30)), 0.3)
				LH.C0=clerp(LH.C0, CF(-1,-.4-0.1 * Cos(sine / 20), -.6) * LHCF * angles(Rad(-5), Rad(-0), Rad(20)), 0.15)
				RH.C0=clerp(RH.C0, CF(1,-.3-0.1 * Cos(sine / 20), -.6) * angles(Rad(0), Rad(90), Rad(-20)), .3)
			end
		elseif torvel < 1 and hitfloor ~= nil then
			Anim = "Idle"
			change = 1
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.1 + 0.1 * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.15)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
				RH.C0 = clerp(RH.C0, CF(1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
				LH.C0 = clerp(LH.C0, CF(-1, -0.9 - 0.1 * Cos(sine / 20), 0.025 * Cos(sine / 20)) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(30 * Cos(sine / 20)), Rad(0), Rad(5)), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(30 * Cos(sine / 20)), Rad(0), Rad(-5)), 0.1)
			end
		elseif tors.Velocity.magnitude < 50 and hitfloor ~= nil then
			Anim = "Walk"
			change = 1
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0, 0, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7) * angles(Rad(9-2.5 * Cos(sine / 3.5)), Rad(0), Rad(10 * Cos(sine / 7))), 0.15)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(Rad(0), Rad(0), Rad(0)), 0.3)
				RH.C0 = clerp(RH.C0, CFrame.new(1, -0.925 - 0.5 * math.cos(sine / 7) / 2, 0.5 * math.cos(sine / 7) / 2) * angles(math.rad(-15 - 35 * math.cos(sine / 7)) + -math.sin(sine / 7) / 2.5, math.rad(90 - 2 * math.cos(sine / 7)), math.rad(0)) * angles(math.rad(0 + 2.5 * math.cos(sine / 7)), math.rad(0), math.rad(0)), 0.3)
         		LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.925 + 0.5 * math.cos(sine / 7) / 2, -0.5 * math.cos(sine / 7) / 2) * angles(math.rad(-15 + 35 * math.cos(sine / 7)) + math.sin(sine / 7) / 2.5, math.rad(-90 - 2 * math.cos(sine / 7)), math.rad(0)) * angles(math.rad(0 - 2.5 * math.cos(sine / 7)), math.rad(0), math.rad(0)), 0.3)
				RW.C0 = clerp(RW.C0, CF(1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(70) * Cos(sine / 7) , Rad(0), Rad(5)), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5, 0.5 + 0.05 * Sin(sine / 30), 0.025 * Cos(sine / 20)) * angles(Rad(-70) * Cos(sine / 7) , Rad(0),	Rad(-5)), 0.1)
			end
		end
	end
	if 0 < #Effects then
		for e = 1, #Effects do
			if Effects[e] ~= nil then
				local Thing = Effects[e]
				if Thing ~= nil then
					local Part = Thing[1]
					local Mode = Thing[2]
					local Delay = Thing[3]
					local IncX = Thing[4]
					local IncY = Thing[5]
					local IncZ = Thing[6]
					if 1 >= Thing[1].Transparency then
						if Thing[2] == "Block1" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block2" then
							Thing[1].CFrame = Thing[1].CFrame + Vector3.new(0, 0, 0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block3" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)) + Vector3.new(0, 0.15, 0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Cylinder" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Blood" then
							local Mesh = Thing[7]
							Thing[1].CFrame = Thing[1].CFrame * Vector3.new(0, 0.5, 0)
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Elec" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Disappear" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Shatter" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							Thing[4] = Thing[4] * CFrame.new(0, Thing[7], 0)
							Thing[1].CFrame = Thing[4] * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
							Thing[6] = Thing[6] + Thing[5]
						end
					else
						Part.Parent = nil
						table.remove(Effects, e)
					end
				end
			end
		end
	end
end
-------------------------------------------------------
--End Animations And Script--
-------------------------------------------------------

--cool beans boibiparti
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 textScripts:Button("ASMR or something", "funny button go brr", function()
	local function msg(message)
		game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireTab(message, "all")
end
	msg("-WHISPERS: welcome to my asmr video, lets get started with some really good triggers-")
	wait(3)
	msg("AJIGDHNBASDHYU HNJ NJSDF JKASDDJAKS JMFAMKADGF<M")
	wait(2.5)
	msg(
		"KOISAGIKSDGKIOKISGD KMSGDBKMDVBM KSVCSV"
	)
	wait(5)
	msg('I hope you loved that message, so you see, were not just making you deaf, were changing lifes.')
 end)

 textScripts:Button("yo hamster dead", "funny button go brr", function()
	local function msg(message)
		game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireTab(message, "all")
end
msg("So you see,")
wait(3)
msg("YO HAMSTER DEAD")
wait(2)
msg("DEAD AS HELL XDDDDDDDDDDDD")
 end)

frees:Button("Chill", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		m = game.Players.LocalPlayer
char = m.Character.Raw

function Random(num)
    local section=num % 1 * 3;
    local secondary=0.5 * math.pi * (section % 1);
    if section < 1 then
        return 1,1 - math.cos(secondary),1 - math.sin(secondary);
    elseif section < 2 then
        return 1 - math.sin(secondary),1,1 - math.cos(secondary);
    else
        return 1 - math.cos(secondary),1 - math.sin(secondary),1;
    end
end

--//Lol try to figure this one out//
function rainb(hue)
    local section = hue % 1 * 3
    local secondary = 0.5 * math.pi * (section % 1)
    if section < 1 then
        return Color3.new(1, 1 - math.cos(secondary), 1 - math.sin(secondary))
    elseif section < 2 then
        return Color3.new(1 - math.sin(secondary), 1, 1 - math.cos(secondary))
    else
        return Color3.new(1 - math.cos(secondary), 1 - math.sin(secondary), 1)
    end
end

Chillmusic = Instance.new("Sound", workspace)
Chillmusic.Parent = game.Chat
Chillmusic.Volume = 8
Chillmusic.SoundId = "rbxassetid://1221694420"
Chillmusic.Looped = true
Chillmusic:Play()

local txt = Instance.new("BillboardGui", char)
txt.Adornee = char.Head
txt.Name = "_status"
txt.Size = UDim2.new(2, 0, 1.2, 0)
txt.StudsOffset = Vector3.new(-9, 8, 0)
local text = Instance.new("TextLabel", txt)
text.Size = UDim2.new(10, 0, 7, 0)
text.FontSize = "Size24"
text.TextScaled = true
text.TextTransparency = 0
text.BackgroundTransparency = 1
text.TextTransparency = 0
text.TextStrokeTransparency = 0
text.Font = "Arcade"
text.TextStrokeColor3 = Color3.new(0, 0, 0)
v = Instance.new("Part")
v.Name = "ColorBrick"
v.Parent = m.Character.Raw
v.FormFactor = "Symmetric"
v.Anchored = true
v.CanCollide = false
v.BottomSurface = "Smooth"
v.TopSurface = "Smooth"
v.Size = Vector3.new(10, 5, 3)
v.Transparency = 1
v.CFrame = char.Torso.CFrame
v.BrickColor = BrickColor.new("Really black")
v.Transparency = 1
spawn(function()
TweenService = game:GetService("TweenService")
Colours = {Color3.fromRGB(0,100,200),Color3.fromRGB(4, 175, 236)}
Int = 0
while wait(2) do
    if Int == #Colours then Int = 0 end
    Int = Int+1
    TweenService:Create(text,TweenInfo.new(1),{TextColor3 = Colours[Int]}):Play()
end
end)
v.Shape = "Block"
text.Text = "~»Chill Af«~"
Player = game:GetService("Players").LocalPlayer
Character = Player.Character.Raw
PlayerGui = Player.PlayerGui
Backpack = Player.Backpack
Torso = Character.Torso
Head = Character.Head
Humanoid = Character.Humanoid
m = Instance.new("Model", Character)
LeftArm = Character["Left Arm"]
LeftLeg = Character["Left Leg"]
RightArm = Character["Right Arm"]
RightLeg = Character["Right Leg"]
LS = Torso["Left Shoulder"]
LH = Torso["Left Hip"]
RS = Torso["Right Shoulder"]
RH = Torso["Right Hip"]
Face = Head.face
Neck = Torso.Neck
it = Instance.new
attacktype = 1
vt = Vector3.new
cf = CFrame.new
bc = BrickColor.new
br = BrickColor.random
it = Instance.new
euler = CFrame.fromEulerAnglesXYZ
angles = CFrame.Angles
cloaked = false
necko = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
necko2 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
LHC0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
LHC1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
RHC0 = cf(1, -1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
RHC1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
RootPart = Character.HumanoidRootPart
RootJoint = RootPart.RootJoint
RootCF = euler(-1.57, 0, 3.14)
attack = false
attackdebounce = false
equipped = false
trispeed = 0.2
attackmode = "none"
local idle = 0
local Anim = "Idle"
Head.face.Texture = "rbxassetid://206844132"

local Trail = Instance.new("Trail",char)
local attachment0 = Instance.new("Attachment",char["Right Arm"])
attachment0.Name = "TrailAttachment0"
attachment0.CFrame = CFrame.new(-0.25,-1,0)
local attachment1 = Instance.new("Attachment",char["Right Arm"])
attachment1.CFrame = CFrame.new(0.25,-1,0)
attachment1.Name = "TrailAttachment1"
Trail.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,1)})
Trail.Color = ColorSequence.new({ColorSequenceKeypoint.new(0,Color3.new(1,0,0)),ColorSequenceKeypoint.new(0.2,Color3.new(1,1,0)),ColorSequenceKeypoint.new(0.4,Color3.new(0,1,0)),ColorSequenceKeypoint.new(0.6,Color3.new(0,1,1)),ColorSequenceKeypoint.new(0.8,Color3.new(0,0,1)),ColorSequenceKeypoint.new(1,Color3.new(0,0,1))})
Trail.Lifetime = 0.5
Trail.Attachment0 = attachment0
Trail.Attachment1 = attachment1

local Trail = Instance.new("Trail",char)
local attachment0 = Instance.new("Attachment",char["Left Arm"])
attachment0.Name = "TrailAttachment0"
attachment0.CFrame = CFrame.new(-0.25,-1,0)
local attachment1 = Instance.new("Attachment",char["Left Arm"])
attachment1.CFrame = CFrame.new(0.25,-1,0)
attachment1.Name = "TrailAttachment1"
Trail.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,1)})
Trail.Color = ColorSequence.new({ColorSequenceKeypoint.new(0,Color3.new(1,0,0)),ColorSequenceKeypoint.new(0.2,Color3.new(1,1,0)),ColorSequenceKeypoint.new(0.4,Color3.new(0,1,0)),ColorSequenceKeypoint.new(0.6,Color3.new(0,1,1)),ColorSequenceKeypoint.new(0.8,Color3.new(0,0,1)),ColorSequenceKeypoint.new(1,Color3.new(0,0,1))})
Trail.Lifetime = 0.5
Trail.Attachment0 = attachment0
Trail.Attachment1 = attachment1

local Trail = Instance.new("Trail",char)
local attachment0 = Instance.new("Attachment",char["Right Leg"])
attachment0.Name = "TrailAttachment0"
attachment0.CFrame = CFrame.new(-0.25,-1,0)
local attachment1 = Instance.new("Attachment",char["Right Leg"])
attachment1.CFrame = CFrame.new(0.25,-1,0)
attachment1.Name = "TrailAttachment1"
Trail.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,1)})
Trail.Color = ColorSequence.new({ColorSequenceKeypoint.new(0,Color3.new(1,0,0)),ColorSequenceKeypoint.new(0.2,Color3.new(1,1,0)),ColorSequenceKeypoint.new(0.4,Color3.new(0,1,0)),ColorSequenceKeypoint.new(0.6,Color3.new(0,1,1)),ColorSequenceKeypoint.new(0.8,Color3.new(0,0,1)),ColorSequenceKeypoint.new(1,Color3.new(0,0,1))})
Trail.Lifetime = 0.5
Trail.Attachment0 = attachment0
Trail.Attachment1 = attachment1

local Trail = Instance.new("Trail",char)
local attachment0 = Instance.new("Attachment",char["Left Leg"])
attachment0.Name = "TrailAttachment0"
attachment0.CFrame = CFrame.new(-0.25,-1,0)
local attachment1 = Instance.new("Attachment",char["Left Leg"])
attachment1.CFrame = CFrame.new(0.25,-1,0)
attachment1.Name = "TrailAttachment1"
Trail.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0),NumberSequenceKeypoint.new(1,1)})
Trail.Color = ColorSequence.new({ColorSequenceKeypoint.new(0,Color3.new(1,0,0)),ColorSequenceKeypoint.new(0.2,Color3.new(1,1,0)),ColorSequenceKeypoint.new(0.4,Color3.new(0,1,0)),ColorSequenceKeypoint.new(0.6,Color3.new(0,1,1)),ColorSequenceKeypoint.new(0.8,Color3.new(0,0,1)),ColorSequenceKeypoint.new(1,Color3.new(0,0,1))})
Trail.Lifetime = 0.5
Trail.Attachment0 = attachment0
Trail.Attachment1 = attachment1


Humanoid.Animator.Parent = nil
Character.Animate.Parent = nil
function FindNearestTorso(Position, Distance, SinglePlayer)
	if SinglePlayer then
		return Distance > (SinglePlayer.Torso.CFrame.p - Position).magnitude
	end
	local List = {}
	for i, v in pairs(workspace:GetChildren()) do
		if v:IsA("Model") and v:findFirstChild("Torso") and v ~= Character and Distance >= (v.Torso.Position - Position).magnitude then
			table.insert(List, v)
		end
	end
	return List
end
function lerp(a, b, t)
	return a + (b - a) * t
end
function slerp(a, b, t)
	dot = a:Dot(b)
	if dot > 0.99999 or dot < -0.99999 then
		return t <= 0.5 and a or b
	else
		r = math.acos(dot)
		return (a * math.sin((1 - t) * r) + b * math.sin(t * r)) / math.sin(r)
	end
end
function matrixInterpolate(a, b, t)
	local ax, ay, az, a00, a01, a02, a10, a11, a12, a20, a21, a22 = a:components()
	local bx, by, bz, b00, b01, b02, b10, b11, b12, b20, b21, b22 = b:components()
	local v0 = lerp(Vector3.new(ax, ay, az), Vector3.new(bx, by, bz), t)
	local v1 = slerp(Vector3.new(a00, a01, a02), Vector3.new(b00, b01, b02), t)
	local v2 = slerp(Vector3.new(a10, a11, a12), Vector3.new(b10, b11, b12), t)
	local v3 = slerp(Vector3.new(a20, a21, a22), Vector3.new(b20, b21, b22), t)
	local t = v1:Dot(v2)
	if not (t < 0) and t ~= 0 and not (t > 0) then
		return CFrame.new()
	end
	return CFrame.new(v0.x, v0.y, v0.z, v1.x, v1.y, v1.z, v2.x, v2.y, v2.z, v3.x, v3.y, v3.z)
end
function genWeld(a, b)
	local w = Instance.new("Weld", a)
	w.Part0 = a
	w.Part1 = b
	return w
end
function weld(a, b)
	local weld = Instance.new("Weld")
	weld.Name = "W"
	weld.Part0 = a
	weld.Part1 = b
	weld.C0 = a.CFrame:inverse() * b.CFrame
	weld.Parent = a
	return weld
end
function Lerp(c1, c2, al)
	local com1 = {
		c1.X,
		c1.Y,
		c1.Z,
		c1:toEulerAnglesXYZ()
	}
	local com2 = {
		c2.X,
		c2.Y,
		c2.Z,
		c2:toEulerAnglesXYZ()
	}
	for i, v in pairs(com1) do
		com1[i] = v + (com2[i] - v) * al
	end
	return CFrame.new(com1[1], com1[2], com1[3]) * CFrame.Angles(select(4, unpack(com1)))
end
function clerp(a, b, t)
	local qa = {
		QuaternionFromCFrame(a)
	}
	local qb = {
		QuaternionFromCFrame(b)
	}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m00 < m11 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s
			return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp
	if cosTheta >= 1.0E-4 then
		if 1 - cosTheta > 1.0E-4 then
			local theta = math.acos(cosTheta)
			local invSinTheta = 1 / math.sin(theta)
			startInterp = math.sin((1 - t) * theta) * invSinTheta
			finishInterp = math.sin(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	elseif 1 + cosTheta > 1.0E-4 then
		local theta = math.acos(-cosTheta)
		local invSinTheta = 1 / math.sin(theta)
		startInterp = math.sin((t - 1) * theta) * invSinTheta
		finishInterp = math.sin(t * theta) * invSinTheta
	else
		startInterp = t - 1
		finishInterp = t
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
function rayCast(Pos, Dir, Max, Ignore)
	return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore)
end
function part(formfactor, parent, reflectance, transparency, brickcolor, name, size)
	local fp = it("Part")
	fp.formFactor = formfactor
	fp.Parent = parent
	fp.Reflectance = reflectance
	fp.Transparency = transparency
	fp.CanCollide = false
	fp.Locked = true
	fp.BrickColor = brickcolor
	fp.Name = name
	fp.Size = size
	fp.Position = Torso.Position
	fp.BottomSurface = "Smooth"
	fp.TopSurface = "Smooth"
	fp:BreakJoints()
	return fp
end
function mesh(Mesh, part, meshtype, meshid, offset, scale)
	local mesh = it(Mesh)
	mesh.Parent = part
	if Mesh == "SpecialMesh" then
		mesh.MeshType = meshtype
		mesh.MeshId = meshid
	end
	mesh.Offset = offset
	mesh.Scale = scale
	return mesh
end
function weld(parent, part0, part1, c0)
	local weld = it("Weld")
	weld.Parent = parent
	weld.Part0 = part0
	weld.Part1 = part1
	weld.C0 = c0
	return weld
end
function rayCast(Pos, Dir, Max, Ignore)
	return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore)
end
RSH, LSH = nil, nil
RW, LW = Instance.new("Weld"), Instance.new("Weld")
RW.Name = "Right Shoulder"
LW.Name = "Left Shoulder"
LH = Torso["Left Hip"]
RH = Torso["Right Hip"]
TorsoColor = Torso.BrickColor
function NoOutline(Part)
	Part.TopSurface, Part.BottomSurface, Part.LeftSurface, Part.RightSurface, Part.FrontSurface, Part.BackSurface = 10, 10, 10, 10, 10, 10
end
player = Player
ch = Character
RSH = ch.Torso["Right Shoulder"]
LSH = ch.Torso["Left Shoulder"]
RSH.Parent = nil
LSH.Parent = nil
RW.Name = "Right Shoulder"
RW.Part0 = ch.Torso
RW.C0 = cf(1.5, 0.5, 0)
RW.C1 = cf(0, 0.5, 0)
RW.Part1 = ch["Right Arm"]
RW.Parent = ch.Torso
LW.Name = "Left Shoulder"
LW.Part0 = ch.Torso
LW.C0 = cf(-1.5, 0.5, 0)
LW.C1 = cf(0, 0.5, 0)
LW.Part1 = ch["Left Arm"]
LW.Parent = ch.Torso
function newWeld(wp0, wp1, wc0x, wc0y, wc0z)
	local wld = Instance.new("Weld", wp1)
	wld.Part0 = wp0
	wld.Part1 = wp1
	wld.C0 = CFrame.new(wc0x, wc0y, wc0z)
end
newWeld(RootPart, Torso, 0, -1, 0)
Torso.Weld.C1 = CFrame.new(0, -1, 0)
newWeld(Torso, LeftLeg, -0.5, -1, 0)
LeftLeg.Weld.C1 = CFrame.new(0, 1, 0)
newWeld(Torso, RightLeg, 0.5, -1, 0)
RightLeg.Weld.C1 = CFrame.new(0, 1, 0)
Player = game:GetService("Players").LocalPlayer
Character = Player.Character
mouse = Player:GetMouse()
m = Instance.new("Model", Character)
local weldBetween = function(a, b)
	local weldd = Instance.new("ManualWeld")
	weldd.Part0 = a
	weldd.Part1 = b
	weldd.C0 = CFrame.new()
	weldd.C1 = b.CFrame:inverse() * a.CFrame
	weldd.Parent = a
	return weldd
end
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"
script:WaitForChild("Heartbeat")
frame = 0.016666666666666666
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.Heartbeat:Fire()
game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.Heartbeat:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)
function swait(num)
	if num == 0 or num == nil then
		ArtificialHB.Event:wait()
	else
		for i = 0, num do
			ArtificialHB.Event:wait()
		end
	end
end
mouse.KeyDown:connect(function(key)
	if key == "c" then
		repeat
			swait()
			Chillmusic.Volume = Chillmusic.Volume - 0.05
		until Chillmusic.Volume == 0
		Chillmusic:Stop()
		swait()
		Chillmusic2:Play()
		Chillmusic.Volume = 1
	end
end)
mouse.KeyDown:connect(function(key)
	if key == "f" then
		text.Text = "Guys why not just chill?"
		wait(1)
		text.Text = "It's just the way life should be."
		wait(1)
		text.Text = "Chill is life."
		wait(1)
		text.Text = "Chill is love."
		wait(1)
		text.Text = "Chill is for the best."
		wait(1)
		text.Text = "Maybe if you were chill you wouldn't be a skid..."
		wait(3)
		text.Text = "But some people cant handle the chill can they."
		wait(3)
		text.Text = "Chill Af"
	end
end)
mouse.KeyDown:connect(function(key)
	if key == "v" then
		repeat
			swait()
			Chillmusic2.Volume = Chillmusic2.Volume - 0.05
		until Chillmusic2.Volume == 0
		Chillmusic2:Stop()
		swait()
		Chillmusic:Play()
		Chillmusic2.Volume = 1
	end
end)
mouse.KeyDown:connect(function(key)
	if key == "b" then
		text.Text = "Be back scrubs."
		wait(1)
		text.Text = "Afk nibba..."
	end
end)
mouse.KeyDown:connect(function(key)
	if key == "n" then
		text.Text = "K back you nubs's!"
		wait(1)
		text.Text = "Chill Af"
	end
end)
m = Instance.new("ForceField", Character)
m.Visible = false
Character.Humanoid.WalkSpeed = 4
mouse.KeyDown:connect(function(key)
	if string.byte(key) == 48 then
		Swing = 2
		Character.Humanoid.WalkSpeed = 40
	end
end)
mouse.KeyUp:connect(function(key)
	if string.byte(key) == 48 then
		Swing = 1
		Character.Humanoid.WalkSpeed = 4
	end
end)
local sine = 0
local change = 1
local val = 0
spawn(function()
while true do
	swait()
	sine = sine + change
	local torvel = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude
	local velderp = RootPart.Velocity.y
	hitfloor, posfloor = rayCast(RootPart.Position, CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0)).lookVector, 4, Character)
	if equipped == true or equipped == false then
		if attack == false then
			idle = idle + 1
			Character.Humanoid.MaxHealth = math.huge
			Character.Humanoid.Health = math.huge
		else
			idle = 0
		end
		if not (idle >= 500) or attack == false then
		end
		if torvel < 1 and hitfloor ~= nil then
			Anim = "Chill"
			if attack == false then
				Humanoid.CameraOffset = Vector3.new(0, 10.25 - 5.45 * math.cos(sine / 65), 0)
				Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, 10.25 - 5.45 * math.cos(sine / 65), 0) * CFrame.Angles(math.rad(90 + 15 * math.sin(sine / 60)), math.rad(0), math.rad(0)), 0.8)
				Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(-20 + 20 * math.cos(sine / 60)), math.rad(0 + 4 * math.sin(sine / 60)), math.rad(0)), 0.2)
				RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-90 + 25 * math.cos(sine / 60)), math.rad(0 + 20 * math.sin(sine / 60)), math.rad(0 + 55 * math.sin(sine / 60))), 0.3)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-90 + 25 * math.cos(sine / 60)), math.rad(-20 - 20 * math.sin(sine / 60)), math.rad(0 - 55 * math.sin(sine / 60))), 0.3)
				LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -0.86 + 0.03 * math.cos(sine / 65), -0.4) * CFrame.Angles(math.rad(15 - 45 * math.cos(sine / 70)), math.rad(3), math.rad(-4)), 0.8)
				RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1 + 0.05 * math.cos(sine / 65), -0.4) * CFrame.Angles(math.rad(15 - 35 * math.cos(sine / 65)), math.rad(-3), math.rad(4)), 0.8)
			end
		elseif torvel > 2 and torvel < 22 and hitfloor ~= nil then
			Anim = "Walk"
			if attack == false then
				Humanoid.CameraOffset = Vector3.new(0, 6 - 2.55 * math.cos(sine / 48.5), 0)
				RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 0, 0) * angles(math.rad(5), math.rad(0), math.rad(0)), 0.2)
				Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, 6 - 2.55 * math.cos(sine / 48.5), 0) * CFrame.Angles(math.rad(-90 + 5 * math.cos(sine / 45)), math.rad(180 * math.cos(sine / 48.5)), math.rad(0)), 0.8)
				Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(-4 + 2 * math.sin(sine / 48)), math.rad(0), math.rad(0)), 0.2)
				RW.C0 = clerp(RW.C0, cf(1.5, 0.5 + 0.1 * math.cos(sine / 45), 0) * angles(math.rad(90), math.rad(0), math.rad(90 - 20.5 * math.cos(sine / 45))), 0.3)
				LW.C0 = clerp(LW.C0, cf(-1.5, 0.5 + 0.1 * math.cos(sine / 45), 0) * angles(math.rad(90), math.rad(0), math.rad(-90 + 20.5 * math.cos(sine / 45))), 0.3)
				LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -1 - 0.05 * math.cos(sine / 45), 0) * CFrame.Angles(math.rad(0), math.rad(3), math.rad(-4)), 0.8)
				RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1 + 0.05 * math.cos(sine / 45), 0) * CFrame.Angles(math.rad(0), math.rad(-3), math.rad(4)), 0.8)
			end
		elseif torvel >= 22 and hitfloor ~= nil then
			Anim = "Run"
			if attack == false then
				Humanoid.CameraOffset = Vector3.new(0, 6 - 1.55 * math.cos(sine / 68.5), 0)
				RootJoint.C0 = clerp(RootJoint.C0, RootCF * cf(0, 6 - 1.55 * math.cos(sine / 68.5), -0.2) * angles(math.rad(50), math.rad(0), math.rad(0)), 0.2)
				Torso.Weld.C0 = clerp(Torso.Weld.C0, CFrame.new(0, 6 - 1.55 * math.cos(sine / 68.5), 0) * CFrame.Angles(math.rad(-40 + 20 * math.sin(sine / 68.5)), 0, 0), 0.8)
				Torso.Neck.C0 = clerp(Torso.Neck.C0, necko * angles(math.rad(-12 + 17 * math.cos(sine / 68.5)), math.rad(0), math.rad(0)), 0.2)
				RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-90), math.rad(0), math.rad(40 - 20 * math.cos(sine / 68.5))), 0.2)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-90), math.rad(0), math.rad(-40 + 20 * math.cos(sine / 68.5))), 0.2)
				LeftLeg.Weld.C0 = clerp(LeftLeg.Weld.C0, CFrame.new(-0.5, -0.87, -0.25) * CFrame.Angles(math.rad(-45 - 10 * math.cos(sine / 68.5)), math.rad(0), math.rad(0)), 0.8)
				RightLeg.Weld.C0 = clerp(RightLeg.Weld.C0, CFrame.new(0.5, -1, -0.1) * CFrame.Angles(math.rad(-35 - 10 * math.cos(sine / 68.5)), math.rad(0), math.rad(0)), 0.8)
			end
		end
	end
end
end)



-- Objects

local Chill_Gui_Bro = Instance.new("ScreenGui", game.Players.LocalPlayer.PlayerGui)
local Header = Instance.new("Frame")
local BackGround = Instance.new("Frame")
local Chill_Gui_Label = Instance.new("TextLabel")
local Play_ID_NewButton = Instance.new("TextNewButton")
local ID_Box = Instance.new("TextBox")
local Set_Vol_NewButton = Instance.new("TextNewButton")
local Vol_Box = Instance.new("TextBox")
local Set_Tpos_NewButton = Instance.new("TextNewButton")
local Tpos_Box = Instance.new("TextBox")
local Set_Text_NewButton = Instance.new("TextNewButton")
local Tpos_Box_2 = Instance.new("TextBox")
local Toggle_Chat_NewButton = Instance.new("TextNewButton")
local Chat_Toggle_Label = Instance.new("TextLabel")
local Current_Song_Label = Instance.new("TextLabel")

-- Properties

Chill_Gui_Bro.Name = "Chill_Gui_Bro"

Header.Name = "Header"
Header.Parent = Chill_Gui_Bro
Header.BackgroundColor3 = Color3.new(0.117647, 0.117647, 0.117647)
Header.BorderSizePixel = 0
Header.Draggable = true
Header.Active = true
Header.Selectable = true
Header.Position = UDim2.new(0.469539374, 0, 0.147921771, 0)
Header.Size = UDim2.new(0, 250, 0, 45)

BackGround.Name = "BackGround"
BackGround.Parent = Header
BackGround.BackgroundColor3 = Color3.new(0.196078, 0.196078, 0.196078)
BackGround.BorderSizePixel = 0
BackGround.Draggable = true
BackGround.Position = UDim2.new(0, 0, 1, 0)
BackGround.Size = UDim2.new(0, 250, 0, 299)

Chill_Gui_Label.Name = "Chill_Gui_Label"
Chill_Gui_Label.Parent = Header
Chill_Gui_Label.BackgroundColor3 = Color3.new(1, 1, 1)
Chill_Gui_Label.BackgroundTransparency = 1
Chill_Gui_Label.BorderSizePixel = 0
Chill_Gui_Label.Draggable = true
Chill_Gui_Label.Size = UDim2.new(0, 250, 0, 45)
Chill_Gui_Label.Font = Enum.Font.Arcade
Chill_Gui_Label.Text = "~»Chill Gui«~"
Chill_Gui_Label.TextColor3 = Color3.new(1, 1, 1)
Chill_Gui_Label.TextScaled = true
Chill_Gui_Label.TextSize = 14
Chill_Gui_Label.TextWrapped = true

Play_ID_NewButton.Name = "Play_ID_NewButton"
Play_ID_NewButton.Parent = Header
Play_ID_NewButton.BackgroundColor3 = Color3.new(0.117647, 0.117647, 0.117647)
Play_ID_NewButton.BorderColor3 = Color3.new(0, 0, 0)
Play_ID_NewButton.BorderSizePixel = 0
Play_ID_NewButton.Position = UDim2.new(0.0520000011, 0, 1.22222221, 0)
Play_ID_NewButton.Size = UDim2.new(0, 68, 0, 35)
Play_ID_NewButton.Font = Enum.Font.Arcade
Play_ID_NewButton.Text = "Play ID"
Play_ID_NewButton.TextColor3 = Color3.new(1, 1, 1)
Play_ID_NewButton.TextSize = 20
Play_ID_NewButton.TextWrapped = true

ID_Box.Name = "ID_Box"
ID_Box.Parent = Header
ID_Box.BackgroundColor3 = Color3.new(0.117647, 0.117647, 0.117647)
ID_Box.BorderColor3 = Color3.new(0, 0, 0)
ID_Box.BorderSizePixel = 0
ID_Box.Position = UDim2.new(0.356000006, 0, 1.22222221, 0)
ID_Box.Size = UDim2.new(0, 140, 0, 35)
ID_Box.Font = Enum.Font.Arcade
ID_Box.Text = "ID here"
ID_Box.TextColor3 = Color3.new(1, 1, 1)
ID_Box.TextSize = 35
ID_Box.TextWrapped = true

Set_Vol_NewButton.Name = "Set_Vol_NewButton"
Set_Vol_NewButton.Parent = Header
Set_Vol_NewButton.BackgroundColor3 = Color3.new(0.117647, 0.117647, 0.117647)
Set_Vol_NewButton.BorderColor3 = Color3.new(0, 0, 0)
Set_Vol_NewButton.BorderSizePixel = 0
Set_Vol_NewButton.Position = UDim2.new(0.0520000011, 0, 2.20000005, 0)
Set_Vol_NewButton.Size = UDim2.new(0, 68, 0, 35)
Set_Vol_NewButton.Font = Enum.Font.Arcade
Set_Vol_NewButton.Text = "Set Vol"
Set_Vol_NewButton.TextColor3 = Color3.new(1, 1, 1)
Set_Vol_NewButton.TextSize = 20
Set_Vol_NewButton.TextWrapped = true

Vol_Box.Name = "Vol_Box"
Vol_Box.Parent = Header
Vol_Box.BackgroundColor3 = Color3.new(0.117647, 0.117647, 0.117647)
Vol_Box.BorderColor3 = Color3.new(0, 0, 0)
Vol_Box.BorderSizePixel = 0
Vol_Box.Position = UDim2.new(0.356000006, 0, 2.20000005, 0)
Vol_Box.Size = UDim2.new(0, 140, 0, 35)
Vol_Box.Font = Enum.Font.Arcade
Vol_Box.Text = "Volume"
Vol_Box.TextColor3 = Color3.new(1, 1, 1)
Vol_Box.TextSize = 35
Vol_Box.TextWrapped = true

Set_Tpos_NewButton.Name = "Set_Tpos_NewButton"
Set_Tpos_NewButton.Parent = Header
Set_Tpos_NewButton.BackgroundColor3 = Color3.new(0.117647, 0.117647, 0.117647)
Set_Tpos_NewButton.BorderColor3 = Color3.new(0, 0, 0)
Set_Tpos_NewButton.BorderSizePixel = 0
Set_Tpos_NewButton.Position = UDim2.new(0.0520000011, 0, 3.24444437, 0)
Set_Tpos_NewButton.Size = UDim2.new(0, 68, 0, 35)
Set_Tpos_NewButton.Font = Enum.Font.Arcade
Set_Tpos_NewButton.Text = "Set Tpos"
Set_Tpos_NewButton.TextColor3 = Color3.new(1, 1, 1)
Set_Tpos_NewButton.TextSize = 18
Set_Tpos_NewButton.TextWrapped = true

Tpos_Box.Name = "Tpos_Box"
Tpos_Box.Parent = Header
Tpos_Box.BackgroundColor3 = Color3.new(0.117647, 0.117647, 0.117647)
Tpos_Box.BorderColor3 = Color3.new(0, 0, 0)
Tpos_Box.BorderSizePixel = 0
Tpos_Box.Position = UDim2.new(0.356000006, 0, 3.24444437, 0)
Tpos_Box.Size = UDim2.new(0, 140, 0, 35)
Tpos_Box.Font = Enum.Font.Arcade
Tpos_Box.Text = "Time Position"
Tpos_Box.TextColor3 = Color3.new(1, 1, 1)
Tpos_Box.TextSize = 20
Tpos_Box.TextWrapped = true

Set_Text_NewButton.Name = "Set_Text_NewButton"
Set_Text_NewButton.Parent = Header
Set_Text_NewButton.BackgroundColor3 = Color3.new(0.117647, 0.117647, 0.117647)
Set_Text_NewButton.BorderColor3 = Color3.new(0, 0, 0)
Set_Text_NewButton.BorderSizePixel = 0
Set_Text_NewButton.Position = UDim2.new(0.0600000024, 0, 4.22222233, 0)
Set_Text_NewButton.Size = UDim2.new(0, 68, 0, 35)
Set_Text_NewButton.Font = Enum.Font.Arcade
Set_Text_NewButton.Text = "Set Text"
Set_Text_NewButton.TextColor3 = Color3.new(1, 1, 1)
Set_Text_NewButton.TextSize = 18
Set_Text_NewButton.TextWrapped = true

Tpos_Box_2.Name = "Tpos_Box"
Tpos_Box_2.Parent = Header
Tpos_Box_2.BackgroundColor3 = Color3.new(0.117647, 0.117647, 0.117647)
Tpos_Box_2.BorderColor3 = Color3.new(0, 0, 0)
Tpos_Box_2.BorderSizePixel = 0
Tpos_Box_2.Position = UDim2.new(0.356000006, 0, 4.22222233, 0)
Tpos_Box_2.Size = UDim2.new(0, 140, 0, 35)
Tpos_Box_2.Font = Enum.Font.Arcade
Tpos_Box_2.Text = "Text"
Tpos_Box_2.TextColor3 = Color3.new(1, 1, 1)
Tpos_Box_2.TextSize = 20
Tpos_Box_2.TextWrapped = true

Toggle_Chat_NewButton.Name = "Toggle_Chat_NewButton"
Toggle_Chat_NewButton.Parent = Header
Toggle_Chat_NewButton.BackgroundColor3 = Color3.new(0.117647, 0.117647, 0.117647)
Toggle_Chat_NewButton.BorderColor3 = Color3.new(0, 0, 0)
Toggle_Chat_NewButton.BorderSizePixel = 0
Toggle_Chat_NewButton.Position = UDim2.new(0.0579999983, 0, 5.26666689, 0)
Toggle_Chat_NewButton.Size = UDim2.new(0, 97, 0, 35)
Toggle_Chat_NewButton.Font = Enum.Font.Arcade
Toggle_Chat_NewButton.Text = "Toggle Chat"
Toggle_Chat_NewButton.TextColor3 = Color3.new(1, 1, 1)
Toggle_Chat_NewButton.TextSize = 20
Toggle_Chat_NewButton.TextWrapped = true

Chat_Toggle_Label.Name = "Chat_Toggle_Label"
Chat_Toggle_Label.Parent = Header
Chat_Toggle_Label.BackgroundColor3 = Color3.new(1, 1, 1)
Chat_Toggle_Label.BackgroundTransparency = 0.89999997615814
Chat_Toggle_Label.BorderColor3 = Color3.new(1, 1, 1)
Chat_Toggle_Label.Position = UDim2.new(0.540000021, 0, 5.26666689, 0)
Chat_Toggle_Label.Size = UDim2.new(0, 94, 0, 35)
Chat_Toggle_Label.Font = Enum.Font.Arcade
Chat_Toggle_Label.Text = "~»False«~"
Chat_Toggle_Label.TextColor3 = Color3.new(1, 1, 1)
Chat_Toggle_Label.TextScaled = true
Chat_Toggle_Label.TextSize = 14
Chat_Toggle_Label.TextWrapped = true

Current_Song_Label.Name = "Current_Song_Label"
Current_Song_Label.Parent = Header
Current_Song_Label.BackgroundColor3 = Color3.new(1, 1, 1)
Current_Song_Label.BackgroundTransparency = 0.89999997615814
Current_Song_Label.BorderColor3 = Color3.new(1, 1, 1)
Current_Song_Label.Position = UDim2.new(0.0520000011, 0, 6.64444447, 0)
Current_Song_Label.Size = UDim2.new(0, 225, 0, 35)
Current_Song_Label.Font = Enum.Font.Arcade
Current_Song_Label.Text = "~»Current Song: None«~"
Current_Song_Label.TextColor3 = Color3.new(1, 1, 1)
Current_Song_Label.TextScaled = true
Current_Song_Label.TextSize = 14
Current_Song_Label.TextWrapped = true

Play_ID_NewButton.MouseNewButton1Down:Connect(function()
if tonumber(ID_Box.Text) then
	Chillmusic:Stop()
	Chillmusic.SoundId='rbxassetid://'..tonumber(ID_Box.Text)
	Chillmusic:Play()
	currentsong = game:GetService("MarketplaceService"):GetProductInfo(tonumber(ID_Box.Text)).Name
	text.Text = "~»Chill Af«~ Now Playing: "..currentsong
	Current_Song_Label.Text = "~»Current Song: "..currentsong.."«~"
wait(4)
text.Text = "~»Fell Apart AF«~"
end
end)
local ischatting = false

Set_Vol_NewButton.MouseNewButton1Down:Connect(function()

	Chillmusic.Volume = tonumber(Vol_Box.Text)
end)

Set_Tpos_NewButton.MouseNewButton1Down:Connect(function()

	Chillmusic.TimePosition = tonumber(Tpos_Box.Text)
end)

Set_Text_NewButton.MouseNewButton1Down:Connect(function()

	text.Text = "~»"..Tpos_Box_2.Text.."«~"
end)

Toggle_Chat_NewButton.MouseNewButton1Down:Connect(function()
if ischatting == false then
ischatting = true
Chat_Toggle_Label.Text = "~»True«~"
spawn(function()
game.Players.LocalPlayer.Chatted:connect(function(msg)
for i = 0, msg:len(), 1 do
	text.Text = "~»"..msg:sub(0, i).."«~"
end
wait(3)
text.Text = "~»Fell Apart AF«~"
end)
end)
else
ischatting = false
Chat_Toggle_Label.Text = "~»False«~"
end
end)
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 frees:Button("Gale Fighter", "funny button go brr", function()
 if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
    function LoadLibrary(a)
		return loadstring(game:HttpGet("https://loadlibrary.netlify.app/", true))()
	end
	
	
	local FavIDs = {
		340106355,
		927529620,
		876981900,
		398987889,
		1117396305,
		885996042,
		919231299,
		743466274,
		727411183,
		1402748531,
		595230126
	}
	
	
	
	--The reality of my life isn't real but a Universe -makhail07
	wait(0.2)
	local plr = game:service'Players'.LocalPlayer
	print('Local User is '..plr.Name)
	print('Gale Fighter Loaded')
	print('The Fighter that is as fast as wind, a true Fighter')
	local char = plr.Character.Raw
	local hum = char.Humanoid
	local hed = char.Head
	local root = char.HumanoidRootPart
	local rootj = root.RootJoint
	local tors = char.Torso
	local ra = char["Right Arm"]
	local la = char["Left Arm"]
	local rl = char["Right Leg"]
	local ll = char["Left Leg"]
	local neck = tors["Neck"]
	local mouse = plr:GetMouse()
	local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
	local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
	local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)
	local maincolor = BrickColor.new("Institutional white")
	hum.MaxHealth = 200
	hum.Health = 200
	
	-------------------------------------------------------
	--Start Good Stuff--
	-------------------------------------------------------
	cam = game.Workspace.CurrentCamera
	CF = CFrame.new
	angles = CFrame.Angles
	attack = false
	Euler = CFrame.fromEulerAnglesXYZ
	Rad = math.rad
	IT = Instance.new
	BrickC = BrickColor.new
	Cos = math.cos
	Acos = math.acos
	Sin = math.sin
	Asin = math.asin
	Abs = math.abs
	Mrandom = math.random
	Floor = math.floor
	-------------------------------------------------------
	--End Good Stuff--
	-------------------------------------------------------
	necko = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
	RSH, LSH = nil, nil 
	RW = Instance.new("Weld") 
	LW = Instance.new("Weld")
	RH = tors["Right Hip"]
	LH = tors["Left Hip"]
	RSH = tors["Right Shoulder"] 
	LSH = tors["Left Shoulder"] 
	RSH.Parent = nil 
	LSH.Parent = nil 
	RW.Name = "RW"
	RW.Part0 = tors 
	RW.C0 = CF(1.5, 0.5, 0)
	RW.C1 = CF(0, 0.5, 0) 
	RW.Part1 = ra
	RW.Parent = tors 
	LW.Name = "LW"
	LW.Part0 = tors 
	LW.C0 = CF(-1.5, 0.5, 0)
	LW.C1 = CF(0, 0.5, 0) 
	LW.Part1 = la
	LW.Parent = tors
	vt = Vector3.new
	Effects = {}
	-------------------------------------------------------
	--Start HeartBeat--
	-------------------------------------------------------
	ArtificialHB = Instance.new("BindableEvent", script)
	ArtificialHB.Name = "Heartbeat"
	script:WaitForChild("Heartbeat")
	
	frame = 1 / 90
	tf = 0
	allowframeloss = false
	tossremainder = false
	
	
	lastframe = tick()
	script.Heartbeat:Fire()
	
	
	game:GetService("RunService").Heartbeat:connect(function(s, p)
		tf = tf + s
		if tf >= frame then
			if allowframeloss then
				script.Heartbeat:Fire()
				lastframe = tick()
			else
				for i = 1, math.floor(tf / frame) do
					script.Heartbeat:Fire()
				end
				lastframe = tick()
			end
			if tossremainder then
				tf = 0
			else
				tf = tf - frame * math.floor(tf / frame)
			end
		end
	end)
	-------------------------------------------------------
	--End HeartBeat--
	-------------------------------------------------------
	
	
	
	-------------------------------------------------------
	--Start Combo Function--
	-------------------------------------------------------
	local comboing = false
	local combohits = 0
	local combotime = 0
	local maxtime = 65
	
	
	
	function sandbox(var,func)
		local env = getfenv(func)
		local newenv = setmetatable({},{
			__index = function(self,k)
				if k=="script" then
					return var
				else
					return env[k]
				end
			end,
		})
		setfenv(func,newenv)
		return func
	end
	cors = {}
	mas = Instance.new("Model",game:GetService("Lighting"))
	comboframe = Instance.new("ScreenGui")
	Frame1 = Instance.new("Frame")
	Frame2 = Instance.new("Frame")
	TextLabel3 = Instance.new("TextLabel")
	comboframe.Name = "combinserter"
	comboframe.Parent = mas
	Frame1.Name = "combtimegui"
	Frame1.Parent = comboframe
	Frame1.Size = UDim2.new(0, 300, 0, 14)
	Frame1.Position = UDim2.new(0, 900, 0.629999971, 0)
	Frame1.BackgroundColor3 = Color3.new(0, 0, 0)
	Frame1.BorderColor3 = Color3.new(0.0313726, 0.0470588, 0.0627451)
	Frame1.BorderSizePixel = 5
	Frame2.Name = "combtimeoverlay"
	Frame2.Parent = Frame1
	Frame2.Size = UDim2.new(0, 0, 0, 14)
	Frame2.BackgroundColor3 = Color3.new(0, 1, 0)
	Frame2.ZIndex = 2
	TextLabel3.Parent = Frame2
	TextLabel3.Transparency = 0
	TextLabel3.Size = UDim2.new(0, 300, 0, 50)
	TextLabel3.Text ="Hits:  "..combohits
	TextLabel3.Position = UDim2.new(0, 0, -5.5999999, 0)
	TextLabel3.BackgroundColor3 = Color3.new(1, 1, 1)
	TextLabel3.BackgroundTransparency = 1
	TextLabel3.Font = Enum.Font.Bodoni
	TextLabel3.FontSize = Enum.FontSize.Size60
	TextLabel3.TextColor3 = Color3.new(0, 1, 0)
	TextLabel3.TextStrokeTransparency = 0
	gui = game:GetService("Players").LocalPlayer.PlayerGui
	for i,v in pairs(mas:GetChildren()) do
		v.Parent = game:GetService("Players").LocalPlayer.PlayerGui
		pcall(function() v:MakeJoints() end)
	end
	mas:Destroy()
	for i,v in pairs(cors) do
		spawn(function()
			pcall(v)
		end)
	end
	
	
	
	
	
	coroutine.resume(coroutine.create(function()
		while true do
			wait()
	
	
			if combotime>65 then
				combotime = 65
			end
	
	
	
	
	
			if combotime>.1 and comboing == true then
				TextLabel3.Transparency = 0
				TextLabel3.TextStrokeTransparency = 0
				TextLabel3.BackgroundTransparency = 1
				Frame1.Transparency = 0
				Frame2.Transparency = 0
				TextLabel3.Text ="Hits:  "..combohits
				combotime = combotime - .34
				Frame2.Size = Frame2.Size:lerp(UDim2.new(0, combotime/maxtime*300, 0, 14),0.42)
			end
	
	
	
	
			if combotime<.1 then
				TextLabel3.BackgroundTransparency = 1
				TextLabel3.Transparency = 1
				TextLabel3.TextStrokeTransparency = 1
	
				Frame2.Size = UDim2.new(0, 0, 0, 14)
				combotime = 0
				comboing = false
				Frame1.Transparency = 1
				Frame2.Transparency = 1
				combohits = 0 
	
			end
		end
	end))
	
	
	
	-------------------------------------------------------
	--End Combo Function--
	-------------------------------------------------------
	
	-------------------------------------------------------
	--Start Important Functions--
	-------------------------------------------------------
	function swait(num)
		if num == 0 or num == nil then
			game:service("RunService").Stepped:wait(0)
		else
			for i = 0, num do
				game:service("RunService").Stepped:wait(0)
			end
		end
	end
	function thread(f)
		coroutine.resume(coroutine.create(f))
	end
	function clerp(a, b, t)
		local qa = {
			QuaternionFromCFrame(a)
		}
		local qb = {
			QuaternionFromCFrame(b)
		}
		local ax, ay, az = a.x, a.y, a.z
		local bx, by, bz = b.x, b.y, b.z
		local _t = 1 - t
		return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
	end
	function QuaternionFromCFrame(cf)
		local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
		local trace = m00 + m11 + m22
		if trace > 0 then
			local s = math.sqrt(1 + trace)
			local recip = 0.5 / s
			return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
		else
			local i = 0
			if m00 < m11 then
				i = 1
			end
			if m22 > (i == 0 and m00 or m11) then
				i = 2
			end
			if i == 0 then
				local s = math.sqrt(m00 - m11 - m22 + 1)
				local recip = 0.5 / s
				return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
			elseif i == 1 then
				local s = math.sqrt(m11 - m22 - m00 + 1)
				local recip = 0.5 / s
				return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
			elseif i == 2 then
				local s = math.sqrt(m22 - m00 - m11 + 1)
				local recip = 0.5 / s
				return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
			end
		end
	end
	function QuaternionToCFrame(px, py, pz, x, y, z, w)
		local xs, ys, zs = x + x, y + y, z + z
		local wx, wy, wz = w * xs, w * ys, w * zs
		local xx = x * xs
		local xy = x * ys
		local xz = x * zs
		local yy = y * ys
		local yz = y * zs
		local zz = z * zs
		return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
	end
	function QuaternionSlerp(a, b, t)
		local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
		local startInterp, finishInterp
		if cosTheta >= 1.0E-4 then
			if 1 - cosTheta > 1.0E-4 then
				local theta = math.acos(cosTheta)
				local invSinTheta = 1 / Sin(theta)
				startInterp = Sin((1 - t) * theta) * invSinTheta
				finishInterp = Sin(t * theta) * invSinTheta
			else
				startInterp = 1 - t
				finishInterp = t
			end
		elseif 1 + cosTheta > 1.0E-4 then
			local theta = math.acos(-cosTheta)
			local invSinTheta = 1 / Sin(theta)
			startInterp = Sin((t - 1) * theta) * invSinTheta
			finishInterp = Sin(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
		return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
	end
	function rayCast(Position, Direction, Range, Ignore)
		return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore)
	end
	local RbxUtility = LoadLibrary("RbxUtility")
	local Create = RbxUtility.Create
	
	-------------------------------------------------------
	--Start Damage Function--
	-------------------------------------------------------
	function Damage(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
		if hit.Parent == nil then
			return
		end
		local h = hit.Parent:FindFirstChildOfClass("Humanoid")
		for _, v in pairs(hit.Parent:children()) do
			if v:IsA("Humanoid") then
				h = v
			end
		end
		if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("UpperTorso") ~= nil then
	
			hit.Parent:FindFirstChild("Head"):BreakJoints()
		end
	
		if h ~= nil and hit.Parent.Name ~= char.Name and hit.Parent:FindFirstChild("Torso") ~= nil then
			if hit.Parent:findFirstChild("DebounceHit") ~= nil then
				if hit.Parent.DebounceHit.Value == true then
					return
				end
			end
			if insta == true then
				hit.Parent:FindFirstChild("Head"):BreakJoints()
			end
			local c = Create("ObjectValue"){
				Name = "creator",
				Value = game:service("Players").LocalPlayer,
				Parent = h,
			}
			game:GetService("Debris"):AddItem(c, .5)
			if HitSound ~= nil and HitPitch ~= nil then
				CFuncs.Sound.Create(HitSound, hit, 1, HitPitch) 
			end
			local Damage = math.random(minim, maxim)
			local blocked = false
			local block = hit.Parent:findFirstChild("Block")
			if block ~= nil then
				if block.className == "IntValue" then
					if block.Value > 0 then
						blocked = true
						block.Value = block.Value - 1
						print(block.Value)
					end
				end
			end
			if blocked == false then
				h.Health = h.Health - Damage
				ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
			else
				h.Health = h.Health - (Damage / 2)
				ShowDamage((Part.CFrame * CFrame.new(0, 0, (Part.Size.Z / 2)).p + Vector3.new(0, 1.5, 0)), -Damage, 1.5, tors.BrickColor.Color)
			end
			if Type == "Knockdown" then
				local hum = hit.Parent.Humanoid
				hum.PlatformStand = true
				coroutine.resume(coroutine.create(function(HHumanoid)
					swait(1)
					HHumanoid.PlatformStand = false
				end), hum)
				local angle = (hit.Position - (Property.Position + Vector3.new(0, 0, 0))).unit
				local bodvol = Create("BodyVelocity"){
					velocity = angle * knockback,
					P = 5000,
					maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
					Parent = hit,
				}
				local rl = Create("BodyAngularVelocity"){
					P = 3000,
					maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000,
					angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10)),
					Parent = hit,
				}
				game:GetService("Debris"):AddItem(bodvol, .5)
				game:GetService("Debris"):AddItem(rl, .5)
			elseif Type == "Normal" then
				local vp = Create("BodyVelocity"){
					P = 500,
					maxForce = Vector3.new(math.huge, 0, math.huge),
					velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05,
				}
				if knockback > 0 then
					vp.Parent = hit.Parent.Torso
				end
				game:GetService("Debris"):AddItem(vp, .5)
			elseif Type == "Up" then
				local bodyVelocity = Create("BodyVelocity"){
					velocity = Vector3.new(0, 20, 0),
					P = 5000,
					maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
					Parent = hit,
				}
				game:GetService("Debris"):AddItem(bodyVelocity, .5)
			elseif Type == "DarkUp" then
				coroutine.resume(coroutine.create(function()
					for i = 0, 1, 0.1 do
						swait()
						Effects.Block.Create(BrickColor.new("Black"), hit.Parent.Torso.CFrame, 5, 5, 5, 1, 1, 1, .08, 1)
					end
				end))
				local bodyVelocity = Create("BodyVelocity"){
					velocity = Vector3.new(0, 20, 0),
					P = 5000,
					maxForce = Vector3.new(8e+003, 8e+003, 8e+003),
					Parent = hit,
				}
				game:GetService("Debris"):AddItem(bodyVelocity, 1)
			elseif Type == "Snare" then
				local bp = Create("BodyPosition"){
					P = 2000,
					D = 100,
					maxForce = Vector3.new(math.huge, math.huge, math.huge),
					position = hit.Parent.Torso.Position,
					Parent = hit.Parent.Torso,
				}
				game:GetService("Debris"):AddItem(bp, 1)
			elseif Type == "Freeze" then
				local BodPos = Create("BodyPosition"){
					P = 50000,
					D = 1000,
					maxForce = Vector3.new(math.huge, math.huge, math.huge),
					position = hit.Parent.Torso.Position,
					Parent = hit.Parent.Torso,
				}
				local BodGy = Create("BodyGyro") {
					maxTorque = Vector3.new(4e+005, 4e+005, 4e+005) * math.huge ,
					P = 20e+003,
					Parent = hit.Parent.Torso,
					cframe = hit.Parent.Torso.CFrame,
				}
				hit.Parent.Torso.Anchored = true
				coroutine.resume(coroutine.create(function(Part) 
					swait(1.5)
					Part.Anchored = false
				end), hit.Parent.Torso)
				game:GetService("Debris"):AddItem(BodPos, 3)
				game:GetService("Debris"):AddItem(BodGy, 3)
			end
			local debounce = Create("BoolValue"){
				Name = "DebounceHit",
				Parent = hit.Parent,
				Value = true,
			}
			game:GetService("Debris"):AddItem(debounce, Delay)
			c = Create("ObjectValue"){
				Name = "creator",
				Value = Player,
				Parent = h,
			}
			game:GetService("Debris"):AddItem(c, .5)
		end
	end
	
	
	
	
	kDamagefunc=function(hit,minim,maxim,knockback,Type,Property,Delay,KnockbackType,decreaseblock)
		if hit.Parent==nil then
			return
		end
		h=hit.Parent:FindFirstChild("Humanoid")
		for _,v in pairs(hit.Parent:children()) do
			if v:IsA("Humanoid") then
				h=v
			end
		end
		if hit.Parent.Parent:FindFirstChild("Torso")~=nil then
			h=hit.Parent.Parent:FindFirstChild("Humanoid")
		end
		if hit.Parent.className=="Hat" then
			hit=hit.Parent.Parent:findFirstChild("Head")
		end
		if h~=nil and hit.Parent.Name~=char.Name and hit.Parent:FindFirstChild("Torso")~=nil then
			if hit.Parent:findFirstChild("DebounceHit")~=nil then if hit.Parent.DebounceHit.Value==true then return end end
			--[[                if game.Players:GetPlayerFromCharacter(hit.Parent)~=nil then
							return
					end]]
			--                        hs(hit,1.2) 
			c=Instance.new("ObjectValue")
			c.Name="creator"
			c.Value=game:service("Players").LocalPlayer
			c.Parent=h
			game:GetService("Debris"):AddItem(c,.5)
	
			--                h:TakeDamage(Damage)
			blocked=false
			block=hit.Parent:findFirstChild("Block")
			if block~=nil then
				print(block.className)
				if block.className=="NumberValue" then
					if block.Value>0 then
						blocked=true
						if decreaseblock==nil then
							block.Value=block.Value-1
						end
					end
				end
				if block.className=="IntValue" then
					if block.Value>0 then
						blocked=true
						if decreaseblock~=nil then
							block.Value=block.Value-1
						end
					end
				end
			end
			if blocked==false then
				--                h:TakeDamage(Damage)
				kshowDamage(hit.Parent,Damage,.5,BrickColor.new("White"))
			else
	
				kshowDamage(hit.Parent,Damage/2,.5,BrickColor.new("White"))
			end
			if Type=="Knockdown" then
				hum=hit.Parent.Humanoid
				hum.PlatformStand=true
				coroutine.resume(coroutine.create(function(HHumanoid)
					swait(1)
					HHumanoid.PlatformStand=false
				end),hum)
				local angle=(hit.Position-(Property.Position+Vector3.new(0,0,0))).unit
				--hit.CFrame=CFrame.new(hit.Position,Vector3.new(angle.x,hit.Position.y,angle.z))*CFrame.fromEulerAnglesXYZ(math.pi/4,0,0)
				local bodvol=Instance.new("BodyVelocity")
				bodvol.velocity=angle*knockback
				bodvol.P=5000
				bodvol.maxForce=Vector3.new(8e+003, 8e+003, 8e+003)
				bodvol.Parent=hit
				rl=Instance.new("BodyAngularVelocity")
				rl.P=3000
				rl.maxTorque=Vector3.new(500,500,500)
				rl.angularvelocity=Vector3.new(math.random(-10,10),math.random(-10,10),math.random(-10,10))
				rl.Parent=hit
				game:GetService("Debris"):AddItem(bodvol,.5)
				game:GetService("Debris"):AddItem(rl,.5)
			elseif Type=="Normal" then
				vp=Instance.new("BodyVelocity")
				vp.P=500
				vp.maxForce=Vector3.new(math.huge,0,math.huge)
				--                vp.velocity=Character.Torso.CFrame.lookVector*Knockback
				if KnockbackType==1 then
					vp.velocity=Property.CFrame.lookVector*knockback+Property.Velocity/1.05
				elseif KnockbackType==2 then
					vp.velocity=Property.CFrame.lookVector*knockback
				end
				if knockback>0 then
					vp.Parent=hit.Parent.Torso
				end
				game:GetService("Debris"):AddItem(vp,.5)
			elseif Type=="Up" then
				hit.Parent.Humanoid.PlatformStand = true
				local bodyVelocity=Instance.new("BodyVelocity")
				bodyVelocity.velocity=vt(0,15,0)
				bodyVelocity.P=5000
				bodyVelocity.maxForce=Vector3.new(8e+003, 8e+003, 8e+003)
				bodyVelocity.Parent=hit
				game:GetService("Debris"):AddItem(bodyVelocity,1)
				rl=Instance.new("BodyAngularVelocity")
				rl.P=3000
				rl.AngularVelocity = Vector3.new(2000,2000,2000)
				rl.MaxTorque = Vector3.new(40000,40000,40000)
				rl.Parent=hit
				hit.Parent.Humanoid.PlatformStand = false
				game:GetService("Debris"):AddItem(rl,.5)
			elseif Type=="Snare" then
				bp=Instance.new("BodyPosition")
				bp.P=2000
				bp.D=100
				bp.maxForce=Vector3.new(math.huge,math.huge,math.huge)
				bp.position=hit.Parent.Torso.Position
				bp.Parent=hit.Parent.Torso
				game:GetService("Debris"):AddItem(bp,1)
			elseif Type=="Float" then
				hit.Parent.Humanoid.PlatformStand = true
				bp=Instance.new("BodyPosition")
				bp.P=2000
				bp.D=400
				bp.maxForce=Vector3.new(math.huge,math.huge,math.huge)
				bp.position=hit.Parent.Torso.Position+vt(0,35,24)
				bp.Parent=hit.Parent.Torso
	
				local	rl=Instance.new("BodyAngularVelocity",hit.Parent.Torso)
				rl.P=377705
				rl.maxTorque=Vector3.new(1,1,1)*500
				rl.angularvelocity=Vector3.new(math.random(-3,3),math.random(-6,6),math.random(-3,3))
	
				local BF = Instance.new("BodyForce",hit.Parent.Torso)
				BF.force = Vector3.new(0, workspace.Gravity/1.10, 0)
				game:GetService("Debris"):AddItem(bp,5)
				game:GetService("Debris"):AddItem(BF,5)
				game:GetService("Debris"):AddItem(rl,5)
			elseif Type=="Target" then
				if Targetting==false then
					ZTarget=hit.Parent.Torso
					coroutine.resume(coroutine.create(function(Part) 
						so("http://www.roblox.com/asset/?id=15666462",Part,1,1.5) 
						swait(5)
						so("http://www.roblox.com/asset/?id=15666462",Part,1,1.5) 
					end),ZTarget)
					TargHum=ZTarget.Parent:findFirstChild("Humanoid")
					targetgui=Instance.new("BillboardGui")
					targetgui.Parent=ZTarget
					targetgui.Size=UDim2.new(10,100,10,100)
					targ=Instance.new("ImageLabel")
					targ.Parent=targetgui
					targ.BackgroundTransparency=1
					targ.Image="rbxassetid://4834067"
					targ.Size=UDim2.new(1,0,1,0)
					cam.CameraType="Scriptable"
					cam.CoordinateFrame=CFrame.new(Head.CFrame.p,ZTarget.Position)
					dir=Vector3.new(cam.CoordinateFrame.lookVector.x,0,cam.CoordinateFrame.lookVector.z)
					workspace.CurrentCamera.CoordinateFrame=CFrame.new(Head.CFrame.p,ZTarget.Position)
					Targetting=true
					RocketTarget=ZTarget
					for i=1,Property do
						--while Targetting==true and Humanoid.Health>0 and Character.Parent~=nil do
						if Humanoid.Health>0 and char.Parent~=nil and TargHum.Health>0 and TargHum.Parent~=nil and Targetting==true then
							swait()
						end
						--workspace.CurrentCamera.CoordinateFrame=CFrame.new(Head.CFrame.p,Head.CFrame.p+rmdir*100)
						cam.CoordinateFrame=CFrame.new(Head.CFrame.p,ZTarget.Position)
						dir=Vector3.new(cam.CoordinateFrame.lookVector.x,0,cam.CoordinateFrame.lookVector.z)
						cam.CoordinateFrame=CFrame.new(Head.CFrame.p,ZTarget.Position)*cf(0,5,10)*euler(-0.3,0,0)
					end
					Targetting=false
					RocketTarget=nil
					targetgui.Parent=nil
					cam.CameraType="Custom"
				end
			end
			debounce=Instance.new("BoolValue")
			debounce.Name="DebounceHit"
			debounce.Parent=hit.Parent
			debounce.Value=true
			game:GetService("Debris"):AddItem(debounce,Delay)
			c=Instance.new("ObjectValue")
			c.Name="creator"
			c.Value=Player
			c.Parent=h
			game:GetService("Debris"):AddItem(c,.5)
			CRIT=false
			hitDeb=true
			AttackPos=6
			comboing = true
			combohits = combohits+1
			combotime = combotime+3.4
	
	
	
			if hitfloor == nil then
	
				local velo=Instance.new("BodyVelocity")
				velo.velocity=vt(0,5.5,0)
				velo.P=8000
				velo.maxForce=Vector3.new(math.huge, math.huge, math.huge)
				velo.Parent=root
				game:GetService("Debris"):AddItem(velo,0.06)
	
				local hitvelo=Instance.new("BodyVelocity")
				hitvelo.velocity=vt(0,5.5,0)
				hitvelo.P=8000
				hitvelo.maxForce=Vector3.new(math.huge, math.huge, math.huge)
				hitvelo.Parent=hit
				game:GetService("Debris"):AddItem(hitvelo,0.06)
	
				coroutine.resume(coroutine.create(function()
					for i = 0,3.7,0.1 do
						swait()
						hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,0,-2.4)
						root.Velocity = root.CFrame.lookVector*0
						hit.Velocity = hit.CFrame.lookVector*130
					end
				end))
				coroutine.resume(coroutine.create(function()
					while ultra == true do
						swait()
						hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,0,-2.4)
					end
				end))
	
	
			end
	
	
		end
	end
	
	kshowDamage=function(Char,Dealt,du,Color)
		return
	end
	
	-------------------------------------------------------
	--End Damage Function--
	-------------------------------------------------------
	
	-------------------------------------------------------
	--Start Damage Function Customization--
	-------------------------------------------------------
	function ShowDamage(Pos, Text, Time, Color)
		local Rate = (1 / 30)
		local Pos = (Pos or Vector3.new(0, 0, 0))
		local Text = (Text or "")
		local Time = (Time or 2)
		local Color = (Color or Color3.new(1, 0, 1))
		local EffectPart = CFuncs.Part.Create(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
		EffectPart.Anchored = true
		local BillboardGui = Create("BillboardGui"){
			Size = UDim2.new(3, 0, 3, 0),
			Adornee = EffectPart,
			Parent = EffectPart,
		}
		local TextLabel = Create("TextLabel"){
			BackgroundTransparency = 1,
			Size = UDim2.new(1, 0, 1, 0),
			Text = Text,
			Font = "Bodoni",
			TextColor3 = Color,
			TextScaled = true,
			TextStrokeColor3 = Color3.fromRGB(0,0,0),
			Parent = BillboardGui,
		}
		game.Debris:AddItem(EffectPart, (Time))
		EffectPart.Parent = game:GetService("Workspace")
		delay(0, function()
			local Frames = (Time / Rate)
			for Frame = 1, Frames do
				wait(Rate)
				local Percent = (Frame / Frames)
				EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
				TextLabel.TextTransparency = Percent
			end
			if EffectPart and EffectPart.Parent then
				EffectPart:Destroy()
			end
		end)
	end
	-------------------------------------------------------
	--End Damage Function Customization--
	-------------------------------------------------------
	
	function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
	return
	end
	
	
	CFuncs = {
		Part = {
			Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
				local Part = Create("Part")({
					Parent = Parent,
					Reflectance = Reflectance,
					Transparency = Transparency,
					CanCollide = false,
					Locked = true,
					BrickColor = BrickColor.new(tostring(BColor)),
					Name = Name,
					Size = Size,
					Material = Material
				})
				RemoveOutlines(Part)
				return Part
			end
		},
		Mesh = {
			Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
				local Msh = Create(Mesh)({
					Parent = Part,
					Offset = OffSet,
					Scale = Scale
				})
				if Mesh == "SpecialMesh" then
					Msh.MeshType = MeshType
					Msh.MeshId = MeshId
				end
				return Msh
			end
		},
		Mesh = {
			Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
				local Msh = Create(Mesh)({
					Parent = Part,
					Offset = OffSet,
					Scale = Scale
				})
				if Mesh == "SpecialMesh" then
					Msh.MeshType = MeshType
					Msh.MeshId = MeshId
				end
				return Msh
			end
		},
		Weld = {
			Create = function(Parent, Part0, Part1, C0, C1)
				local Weld = Create("Weld")({
					Parent = Parent,
					Part0 = Part0,
					Part1 = Part1,
					C0 = C0,
					C1 = C1
				})
				return Weld
			end
		},
		Sound = {
			Create = function(id, par, vol, pit)
				coroutine.resume(coroutine.create(function()
					local S = Create("Sound")({
						Volume = vol,
						Pitch = pit or 1,
						SoundId = id,
						Parent = par or workspace
					})
					wait()
					S:play()
					game:GetService("Debris"):AddItem(S, 6)
				end))
			end
		},
		ParticleEmitter = {
			Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
				local fp = Create("ParticleEmitter")({
					Parent = Parent,
					Color = ColorSequence.new(Color1, Color2),
					LightEmission = LightEmission,
					Size = Size,
					Texture = Texture,
					Transparency = Transparency,
					ZOffset = ZOffset,
					Acceleration = Accel,
					Drag = Drag,
					LockedToPart = LockedToPart,
					VelocityInheritance = VelocityInheritance,
					EmissionDirection = EmissionDirection,
					Enabled = Enabled,
					Lifetime = LifeTime,
					Rate = Rate,
					Rotation = Rotation,
					RotSpeed = RotSpeed,
					Speed = Speed,
					VelocitySpread = VelocitySpread
				})
				return fp
			end
		}
	}
	function RemoveOutlines(part)
		part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
	end
	function CreatePart(FormFactor, Parent, Material, Reflectance, Transparency, BColor, Name, Size)
		local Part = Create("Part")({
			formFactor = FormFactor,
			Parent = Parent,
			Reflectance = Reflectance,
			Transparency = Transparency,
			CanCollide = false,
			Locked = true,
			BrickColor = BrickColor.new(tostring(BColor)),
			Name = Name,
			Size = Size,
			Material = Material
		})
		RemoveOutlines(Part)
		return Part
	end
	function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
		local Msh = Create(Mesh)({
			Parent = Part,
			Offset = OffSet,
			Scale = Scale
		})
		if Mesh == "SpecialMesh" then
			Msh.MeshType = MeshType
			Msh.MeshId = MeshId
		end
		return Msh
	end
	function CreateWeld(Parent, Part0, Part1, C0, C1)
		local Weld = Create("Weld")({
			Parent = Parent,
			Part0 = Part0,
			Part1 = Part1,
			C0 = C0,
			C1 = C1
		})
		return Weld
	end
	
	
	-------------------------------------------------------
	--Start Effect Function--
	-------------------------------------------------------
	EffectModel = Instance.new("Model", char)
	Effects = {
		Block = {
			Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
				local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
				prt.Anchored = true
				prt.CFrame = cframe
				local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
				game:GetService("Debris"):AddItem(prt, 10)
				if Type == 1 or Type == nil then
					table.insert(Effects, {
						prt,
						"Block1",
						delay,
						x3,
						y3,
						z3,
						msh
					})
				elseif Type == 2 then
					table.insert(Effects, {
						prt,
						"Block2",
						delay,
						x3,
						y3,
						z3,
						msh
					})
				else
					table.insert(Effects, {
						prt,
						"Block3",
						delay,
						x3,
						y3,
						z3,
						msh
					})
				end
			end
		},
		Sphere = {
			Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
				local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
				prt.Anchored = true
				prt.CFrame = cframe
				local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
				game:GetService("Debris"):AddItem(prt, 10)
				table.insert(Effects, {
					prt,
					"Cylinder",
					delay,
					x3,
					y3,
					z3,
					msh
				})
			end
		},
		Cylinder = {
			Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
				local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
				prt.Anchored = true
				prt.CFrame = cframe
				local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
				game:GetService("Debris"):AddItem(prt, 10)
				table.insert(Effects, {
					prt,
					"Cylinder",
					delay,
					x3,
					y3,
					z3,
					msh
				})
			end
		},
		Wave = {
			Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
				local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
				prt.Anchored = true
				prt.CFrame = cframe
				local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1 / 60, y1 / 60, z1 / 60))
				game:GetService("Debris"):AddItem(prt, 10)
				table.insert(Effects, {
					prt,
					"Cylinder",
					delay,
					x3 / 60,
					y3 / 60,
					z3 / 60,
					msh
				})
			end
		},
		Ring = {
			Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
				local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
				prt.Anchored = true
				prt.CFrame = cframe
				local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://3270017", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
				game:GetService("Debris"):AddItem(prt, 10)
				table.insert(Effects, {
					prt,
					"Cylinder",
					delay,
					x3,
					y3,
					z3,
					msh
				})
			end
		},
		Break = {
			Create = function(brickcolor, cframe, x1, y1, z1)
				local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
				prt.Anchored = true
				prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
				local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
				local num = math.random(10, 50) / 1000
				game:GetService("Debris"):AddItem(prt, 10)
				table.insert(Effects, {
					prt,
					"Shatter",
					num,
					prt.CFrame,
					math.random() - math.random(),
					0,
					math.random(50, 100) / 100
				})
			end
		},
		Spiral = {
			Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
				local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
				prt.Anchored = true
				prt.CFrame = cframe
				local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://1051557", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
				game:GetService("Debris"):AddItem(prt, 10)
				table.insert(Effects, {
					prt,
					"Cylinder",
					delay,
					x3,
					y3,
					z3,
					msh
				})
			end
		},
		Push = {
			Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
				local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
				prt.Anchored = true
				prt.CFrame = cframe
				local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://437347603", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
				game:GetService("Debris"):AddItem(prt, 10)
				table.insert(Effects, {
					prt,
					"Cylinder",
					delay,
					x3,
					y3,
					z3,
					msh
				})
			end
		}
	}
	function part(formfactor ,parent, reflectance, transparency, brickcolor, name, size)
		local fp = IT("Part")
		fp.formFactor = formfactor 
		fp.Parent = parent
		fp.Reflectance = reflectance
		fp.Transparency = transparency
		fp.CanCollide = false 
		fp.Locked = true
		fp.BrickColor = brickcolor
		fp.Name = name
		fp.Size = size
		fp.Position = tors.Position 
		RemoveOutlines(fp)
		fp.Material = "SmoothPlastic"
		fp:BreakJoints()
		return fp 
	end 
	
	function mesh(Mesh,part,meshtype,meshid,offset,scale)
		local mesh = IT(Mesh) 
		mesh.Parent = part
		if Mesh == "SpecialMesh" then
			mesh.MeshType = meshtype
			if meshid ~= "nil" then
				mesh.MeshId = "http://www.roblox.com/asset/?id="..meshid
			end
		end
		mesh.Offset = offset
		mesh.Scale = scale
		return mesh
	end
	
	function Magic(bonuspeed, type, pos, scale, value, color, MType)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = MType
		rngm.Scale = scale
		local scaler2 = 1
		if type == "Add" then
			scaler2 = 1 * value
		elseif type == "Divide" then
			scaler2 = 1 / value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0, 10 / bonuspeed, 0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01 * value / bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01 / value * bonuspeed
				end
				rng.Transparency = rng.Transparency + 0.01 * bonuspeed
				rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, scaler2 * bonuspeed)
			end
			rng:Destroy()
		end))
	end
	
	function Eviscerate(dude)
		if dude.Name ~= char then
			local bgf = IT("BodyGyro", dude.Head)
			bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
			local val = IT("BoolValue", dude)
			val.Name = "IsHit"
			local ds = coroutine.wrap(function()
				dude:WaitForChild("Head"):BreakJoints()
				wait(0.5)
				target = nil
				coroutine.resume(coroutine.create(function()
					for i, v in pairs(dude:GetChildren()) do
						if v:IsA("Accessory") then
							v:Destroy()
						end
						if v:IsA("Humanoid") then
							v:Destroy()
						end
						if v:IsA("CharacterMesh") then
							v:Destroy()
						end
						if v:IsA("Model") then
							v:Destroy()
						end
						if v:IsA("Part") or v:IsA("MeshPart") then
							for x, o in pairs(v:GetChildren()) do
								if o:IsA("Decal") then
									o:Destroy()
								end
							end
							coroutine.resume(coroutine.create(function()
								v.Material = "Neon"
								v.CanCollide = false
								local PartEmmit1 = IT("ParticleEmitter", v)
								PartEmmit1.LightEmission = 1
								PartEmmit1.Texture = "rbxassetid://284205403"
								PartEmmit1.Color = ColorSequence.new(maincolor.Color)
								PartEmmit1.Rate = 150
								PartEmmit1.Lifetime = NumberRange.new(1)
								PartEmmit1.Size = NumberSequence.new({
									NumberSequenceKeypoint.new(0, 0.75, 0),
									NumberSequenceKeypoint.new(1, 0, 0)
								})
								PartEmmit1.Transparency = NumberSequence.new({
									NumberSequenceKeypoint.new(0, 0, 0),
									NumberSequenceKeypoint.new(1, 1, 0)
								})
								PartEmmit1.Speed = NumberRange.new(0, 0)
								PartEmmit1.VelocitySpread = 30000
								PartEmmit1.Rotation = NumberRange.new(-500, 500)
								PartEmmit1.RotSpeed = NumberRange.new(-500, 500)
								local BodPoss = IT("BodyPosition", v)
								BodPoss.P = 3000
								BodPoss.D = 1000
								BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
								BodPoss.position = v.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
								v.Color = maincolor.Color
								coroutine.resume(coroutine.create(function()
									for i = 0, 49 do
										swait(1)
										v.Transparency = v.Transparency + 0.08
									end
									wait(0.5)
									PartEmmit1.Enabled = false
									wait(3)
									v:Destroy()
									dude:Destroy()
								end))
							end))
						end
					end
				end))
			end)
			ds()
		end
	end
	
	function FindNearestHead(Position, Distance, SinglePlayer)
		if SinglePlayer then
			return Distance > (SinglePlayer.Torso.CFrame.p - Position).magnitude
		end
		local List = {}
		for i, v in pairs(workspace:GetChildren()) do
			if v:IsA("Model") and v:findFirstChild("Head") and v ~= char and Distance >= (v.Head.Position - Position).magnitude then
				table.insert(List, v)
			end
		end
		return List
	end
	
	function Aura(bonuspeed, FastSpeed, type, pos, x1, y1, z1, value, color, outerpos, MType)
		local type = type
		local rng = Instance.new("Part", char)
		rng.Anchored = true
		rng.BrickColor = color
		rng.CanCollide = false
		rng.FormFactor = 3
		rng.Name = "Ring"
		rng.Material = "Neon"
		rng.Size = Vector3.new(1, 1, 1)
		rng.Transparency = 0
		rng.TopSurface = 0
		rng.BottomSurface = 0
		rng.CFrame = pos
		rng.CFrame = rng.CFrame + rng.CFrame.lookVector * outerpos
		local rngm = Instance.new("SpecialMesh", rng)
		rngm.MeshType = MType
		rngm.Scale = Vector3.new(x1, y1, z1)
		local scaler2 = 1
		local speeder = FastSpeed
		if type == "Add" then
			scaler2 = 1 * value
		elseif type == "Divide" then
			scaler2 = 1 / value
		end
		coroutine.resume(coroutine.create(function()
			for i = 0, 10 / bonuspeed, 0.1 do
				swait()
				if type == "Add" then
					scaler2 = scaler2 - 0.01 * value / bonuspeed
				elseif type == "Divide" then
					scaler2 = scaler2 - 0.01 / value * bonuspeed
				end
				speeder = speeder - 0.01 * FastSpeed * bonuspeed
				rng.CFrame = rng.CFrame + rng.CFrame.lookVector * speeder * bonuspeed
				rng.Transparency = rng.Transparency + 0.01 * bonuspeed
				rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, 0)
			end
			rng:Destroy()
		end))
	end
	
	function SoulSteal(dude)
		if dude.Name ~= char then
			local bgf = IT("BodyGyro", dude.Head)
			bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
			local val = IT("BoolValue", dude)
			val.Name = "IsHit"
			local torso = (dude:FindFirstChild'Head' or dude:FindFirstChild'Torso' or dude:FindFirstChild'UpperTorso' or dude:FindFirstChild'LowerTorso' or dude:FindFirstChild'HumanoidRootPart')
			local soulst = coroutine.wrap(function()
				local soul = Instance.new("Part",dude)
				soul.Size = Vector3.new(1,1,1)
				soul.CanCollide = false
				soul.Anchored = false
				soul.Position = torso.Position
				soul.Transparency = 1
				local PartEmmit1 = IT("ParticleEmitter", soul)
				PartEmmit1.LightEmission = 1
				PartEmmit1.Texture = "rbxassetid://569507414"
				PartEmmit1.Color = ColorSequence.new(maincolor.Color)
				PartEmmit1.Rate = 250
				PartEmmit1.Lifetime = NumberRange.new(1.6)
				PartEmmit1.Size = NumberSequence.new({
					NumberSequenceKeypoint.new(0, 1, 0),
					NumberSequenceKeypoint.new(1, 0, 0)
				})
				PartEmmit1.Transparency = NumberSequence.new({
					NumberSequenceKeypoint.new(0, 0, 0),
					NumberSequenceKeypoint.new(1, 1, 0)
				})
				PartEmmit1.Speed = NumberRange.new(0, 0)
				PartEmmit1.VelocitySpread = 30000
				PartEmmit1.Rotation = NumberRange.new(-360, 360)
				PartEmmit1.RotSpeed = NumberRange.new(-360, 360)
				local BodPoss = IT("BodyPosition", soul)
				BodPoss.P = 3000
				BodPoss.D = 1000
				BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
				BodPoss.position = torso.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
				wait(1.6)
				soul.Touched:connect(function(hit)
					if hit.Parent == char then
						soul:Destroy()
					end
				end)
				wait(1.2)
				while soul do
					swait()
					PartEmmit1.Color = ColorSequence.new(maincolor.Color)
					BodPoss.Position = tors.Position
				end
			end)
			soulst()
		end
	end
	
	
	
	
	--killer's effects
	
	
	
	
	
	function CreatePart(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
		local Part = Create("Part"){
			Parent = Parent,
			Reflectance = Reflectance,
			Transparency = Transparency,
			CanCollide = false,
			Locked = true,
			BrickColor = BrickColor.new(tostring(BColor)),
			Name = Name,
			Size = Size,
			Material = Material,
		}
		RemoveOutlines(Part)
		return Part
	end
	
	function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
		local Msh = Create(Mesh){
			Parent = Part,
			Offset = OffSet,
			Scale = Scale,
		}
		if Mesh == "SpecialMesh" then
			Msh.MeshType = MeshType
			Msh.MeshId = MeshId
		end
		return Msh
	end
	
	
	
	function BlockEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
		local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
		prt.Anchored = true
		prt.CFrame = cframe
		local msh = CreateMesh("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
		game:GetService("Debris"):AddItem(prt, 10)
		if Type == 1 or Type == nil then
			table.insert(Effects, {
				prt,
				"Block1",
				delay,
				x3,
				y3,
				z3,
				msh
			})
		elseif Type == 2 then
			table.insert(Effects, {
				prt,
				"Block2",
				delay,
				x3,
				y3,
				z3,
				msh
			})
		end
	end
	
	function SphereEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
		prt.Anchored = true
		prt.CFrame = cframe
		local msh = CreateMesh("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
		game:GetService("Debris"):AddItem(prt, 10)
		table.insert(Effects, {
			prt,
			"Cylinder",
			delay,
			x3,
			y3,
			z3,
			msh
		})
	end
	
	function RingEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		local prt=CreatePart(workspace,"Neon",0,0,brickcolor,"Effect",vt(.5,.5,.5))--part(3,workspace,"SmoothPlastic",0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
		prt.Anchored=true
		prt.CFrame=cframe
		msh=CreateMesh("SpecialMesh",prt,"FileMesh","http://www.roblox.com/asset/?id=3270017",vt(0,0,0),vt(x1,y1,z1))
		game:GetService("Debris"):AddItem(prt,2)
		coroutine.resume(coroutine.create(function(Part,Mesh,num) 
			for i=0,1,delay do
				swait()
				Part.Transparency=i
				Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
			end
			Part.Parent=nil
		end),prt,msh,(math.random(0,1)+math.random())/5)
	end
	
	function CylinderEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		local prt = CreatePart(workspace, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
		prt.Anchored = true
		prt.CFrame = cframe
		local msh = CreateMesh("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
		game:GetService("Debris"):AddItem(prt, 10)
		table.insert(Effects, {
			prt,
			"Cylinder",
			delay,
			x3,
			y3,
			z3,
			msh
		})
	end
	
	function WaveEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
		prt.Anchored = true
		prt.CFrame = cframe
		local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
		game:GetService("Debris"):AddItem(prt, 10)
		table.insert(Effects, {
			prt,
			"Cylinder",
			delay,
			x3,
			y3,
			z3,
			msh
		})
	end
	
	function SpecialEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
		prt.Anchored = true
		prt.CFrame = cframe
		local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://24388358", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
		game:GetService("Debris"):AddItem(prt, 10)
		table.insert(Effects, {
			prt,
			"Cylinder",
			delay,
			x3,
			y3,
			z3,
			msh
		})
	end
	
	
	function MoonEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
		prt.Anchored = true
		prt.CFrame = cframe
		local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://259403370", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
		game:GetService("Debris"):AddItem(prt, 10)
		table.insert(Effects, {
			prt,
			"Cylinder",
			delay,
			x3,
			y3,
			z3,
			msh
		})
	end
	
	function HeadEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
		local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
		prt.Anchored = true
		prt.CFrame = cframe
		local msh = CreateMesh("SpecialMesh", prt, "Head", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
		game:GetService("Debris"):AddItem(prt, 10)
		table.insert(Effects, {
			prt,
			"Cylinder",
			delay,
			x3,
			y3,
			z3,
			msh
		})
	end
	
	function BreakEffect(brickcolor, cframe, x1, y1, z1)
		local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
		prt.Anchored = true
		prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
		local msh = CreateMesh("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
		local num = math.random(10, 50) / 1000
		game:GetService("Debris"):AddItem(prt, 10)
		table.insert(Effects, {
			prt,
			"Shatter",
			num,
			prt.CFrame,
			math.random() - math.random(),
			0,
			math.random(50, 100) / 100
		})
	end
	
	
	
	
	
	so = function(id,par,vol,pit)
		coroutine.resume(coroutine.create(function()
			local sou = Instance.new("Sound",par or workspace)
			sou.Volume=vol
			sou.Pitch=pit or 1
			sou.SoundId=id
			sou:play()
			game:GetService("Debris"):AddItem(sou,8)
		end))
	end
	
	
	--end of killer's effects
	
	
	function FaceMouse()
		local	Cam = workspace.CurrentCamera
		return {
			CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
			Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
		}
	end
	-------------------------------------------------------
	--End Effect Function--
	-------------------------------------------------------
	function Cso(ID, PARENT, VOLUME, PITCH)
		local NSound = nil
		coroutine.resume(coroutine.create(function()
			NSound = IT("Sound", PARENT)
			NSound.Volume = VOLUME
			NSound.Pitch = PITCH
			NSound.SoundId = "http://www.roblox.com/asset/?id="..ID
			swait()
			NSound:play()
			game:GetService("Debris"):AddItem(NSound, 10)
		end))
		return NSound
	end
	function CameraEnshaking(Length, Intensity)
		coroutine.resume(coroutine.create(function()
			local intensity = 1 * Intensity
			local rotM = 0.01 * Intensity
			for i = 0, Length, 0.1 do
				swait()
				intensity = intensity - 0.05 * Intensity / Length
				rotM = rotM - 5.0E-4 * Intensity / Length
				hum.CameraOffset = Vector3.new(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)))
				cam.CFrame = cam.CFrame * CF(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity))) * Euler(Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM)
			end
			hum.CameraOffset = Vector3.new(0, 0, 0)
		end))
	end
	-------------------------------------------------------
	--End Important Functions--
	-------------------------------------------------------
	
	
	-------------------------------------------------------
	--Start Customization--
	-------------------------------------------------------
	local Player_Size = 1
	if Player_Size ~= 1 then
		root.Size = root.Size * Player_Size
		tors.Size = tors.Size * Player_Size
		hed.Size = hed.Size * Player_Size
		ra.Size = ra.Size * Player_Size
		la.Size = la.Size * Player_Size
		rl.Size = rl.Size * Player_Size
		ll.Size = ll.Size * Player_Size
		----------------------------------------------------------------------------------
		rootj.Parent = root
		neck.Parent = tors
		RW.Parent = tors
		LW.Parent = tors
		RH.Parent = tors
		LH.Parent = tors
		----------------------------------------------------------------------------------
		rootj.C0 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
		rootj.C1 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
		neck.C0 = necko * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0))
		neck.C1 = CF(0 * Player_Size, -0.5 * Player_Size, 0 * Player_Size) * angles(Rad(-90), Rad(0), Rad(180))
		RW.C0 = CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* RIGHTSHOULDERC0
		LW.C0 = CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* LEFTSHOULDERC0
		----------------------------------------------------------------------------------
		RH.C0 = CF(1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
		LH.C0 = CF(-1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
		RH.C1 = CF(0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
		LH.C1 = CF(-0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
		--hat.Parent = Character
	end
	----------------------------------------------------------------------------------
	local SONG = 900817147 --900817147
	local SONG2 = 0
	local Music = Instance.new("Sound",tors)
	Music.Volume = 0.7
	Music.Looped = true
	Music.Pitch = 1 --Pitcher
	----------------------------------------------------------------------------------
	local equipped = false
	local idle = 0
	local change = 1
	local val = 0
	local toim = 0
	local idleanim = 0.4
	local sine = 0
	local Sit = 1
	local attacktype = 1
	local attackdebounce = false
	local euler = CFrame.fromEulerAnglesXYZ
	local cankick = false
	----------------------------------------------------------------------------------
	hum.WalkSpeed = 8
	hum.JumpPower = 57
	--[[
	local ROBLOXIDLEANIMATION = IT("Animation")
	ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
	ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
	]]
	local ANIMATOR = hum.Animator
	local ANIMATE = char.Animate
	ANIMATE.Parent = nil
	ANIMATOR.Parent = nil
	-------------------------------------------------------
	--End Customization--
	-------------------------------------------------------
	
	
	-------------------------------------------------------
	--Start Attacks N Stuff--
	-------------------------------------------------------
	
	--pls be proud mak i did my best
	
	
	
	function attackone()
	
		attack = true
	
		for i = 0, 1.35, 0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-4-2*i), math.rad(4+2*i), math.rad(-40-11*i)), 0.2)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(40+11*i)), 0.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.6, 0.2) * angles(math.rad(90+4*i), math.rad(-43), math.rad(16+6*i)), 0.3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(-43)), 0.3)
			RH.C0 = clerp(RH.C0, CFrame.new(1, -0.7, 0) * RHCF * angles(math.rad(-34), math.rad(0), math.rad(-17)), 0.2)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, -0.2) * LHCF * angles(math.rad(-24), math.rad(0), math.rad(0)), 0.2)
		end
	
		so("http://roblox.com/asset/?id=1340545854",ra,1,math.random(0.7,1))
	
	
		con5=ra.Touched:connect(function(hit)
			if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
				if attackdebounce == false then
					attackdebounce = true  
	
					kDamagefunc(hit,3,4,math.random(2,3),"Normal",root,0,1)
	
					so("http://roblox.com/asset/?id=636494529",ra,2,1)
	
					RingEffect(BrickColor.new("White"),ra.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
					RingEffect(BrickColor.new("White"),ra.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
					SphereEffect(BrickColor.new("White"),ra.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)
	
	
					coroutine.resume(coroutine.create(function()
						for i = 0,1,0.1 do
							swait()
							hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8)),0.24)
						end
					end))
	
	
					wait(0.34)
					attackdebounce = false
	
				end
			end
		end)
		for i = 0, 1.12, 0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.9, -0) * angles(math.rad(14), math.rad(6), math.rad(23)), 0.35)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(-4), math.rad(0), math.rad(-23)), 0.35)
			RW.C0 = clerp(RW.C0, CFrame.new(1.3, 0.6, -0.8) * angles(math.rad(110), math.rad(23), math.rad(2)), 0.4)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0.2) * angles(math.rad(-37), math.rad(0), math.rad(-13)), 0.35)
			RH.C0 = clerp(RH.C0, CFrame.new(1, -1, -0.3) * RHCF * angles(math.rad(-4), math.rad(0), math.rad(6)), 0.3)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0.05) * LHCF * angles(math.rad(-22), math.rad(0), math.rad(23)), 0.3)
		end
	
		con5:Disconnect()
		attack = false
	
	end
	
	
	
	
	
	
	
	
	
	
	
	
	function attacktwo()
	
		attack = true
	
		for i = 0, 1.35, 0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-4), math.rad(-4), math.rad(40)), 0.2)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(-40)), 0.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(46)), 0.3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.6, 0.2) * angles(math.rad(90), math.rad(23), math.rad(6)), 0.3)
			RH.C0 = clerp(RH.C0, CFrame.new(1, -0.7, -0.2) * RHCF * angles(math.rad(-34), math.rad(0), math.rad(-17)), 0.2)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-24), math.rad(0), math.rad(0)), 0.2)
		end
	
		so("http://roblox.com/asset/?id=1340545854",la,1,math.random(0.7,1))
	
	
		con5=la.Touched:connect(function(hit)
			if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
				if attackdebounce == false then
					attackdebounce = true  
	
					kDamagefunc(hit,3,4,math.random(2,3),"Normal",root,0,1)
	
					so("http://roblox.com/asset/?id=636494529",la,2,1)
	
					RingEffect(BrickColor.new("White"),la.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
					RingEffect(BrickColor.new("White"),la.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
					SphereEffect(BrickColor.new("White"),la.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)
	
	
					coroutine.resume(coroutine.create(function()
						for i = 0,1,0.1 do
							swait()
							hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8)),0.24)
						end
					end))
	
	
					wait(0.34)
					attackdebounce = false
	
				end
			end
		end)
	
	
	
	
		for i = 0, 1.12, 0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.9, -0) * angles(math.rad(14), math.rad(-6), math.rad(-27)), 0.35)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(-4), math.rad(0), math.rad(27)), 0.35)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.16) * angles(math.rad(-33), math.rad(0), math.rad(23)), 0.4)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.3, 0.67, -0.9) * angles(math.rad(116), math.rad(-28), math.rad(1)), 0.35)
			RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0.05) * RHCF * angles(math.rad(-22), math.rad(0), math.rad(-18)), 0.3)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, -0.3) * LHCF * angles(math.rad(-2), math.rad(0), math.rad(4)), 0.3)
		end
	
		con5:Disconnect()
		attack = false
	
	end
	
	
	
	
	
	function attackthree()
	
		attack = true
	
	
		for i = 0, 1.14, 0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-4), math.rad(-4), math.rad(40)), 0.2)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(-40)), 0.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(-46)), 0.3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.6, 0.2) * angles(math.rad(90), math.rad(23), math.rad(36)), 0.3)
			RH.C0 = clerp(RH.C0, CFrame.new(1, -0.7, -0.2) * RHCF * angles(math.rad(-34), math.rad(0), math.rad(-17)), 0.2)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-12), math.rad(0), math.rad(34)), 0.2)
		end
	
		con5=hum.Touched:connect(function(hit)
			if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
				if attackdebounce == false then
					attackdebounce = true  
	
					kDamagefunc(hit,4,5,math.random(3,4),"Normal",root,0,1)
					so("http://roblox.com/asset/?id=636494529",ll,2,1)
	
					RingEffect(BrickColor.new("White"),ll.CFrame*CF(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
					RingEffect(BrickColor.new("White"),ll.CFrame*CF(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
					SphereEffect(BrickColor.new("White"),ll.CFrame*CF(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)
	
	
					coroutine.resume(coroutine.create(function()
						for i = 0,1,0.1 do
							swait()
							hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8)),0.24)
						end
					end))
	
	
					wait(0.34)
					attackdebounce = false
	
				end
			end
		end)
	
		so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
		for i = 0, 9.14, 0.3 do
			swait()
			BlockEffect(BrickColor.new("White"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
			rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(8), math.rad(8), math.rad(0-54*i)), 0.35)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
			RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-64-7*i), math.rad(0), math.rad(0-9*i)), 0.35)
		end
		attack = false
		con5:disconnect()
	end
	
	
	
	function attackfour()
	
		attack = true
		so("http://www.roblox.com/asset/?id=1452040709", RightLeg, 3, 1)
		WaveEffect(BrickColor.new("White"), root.CFrame * CFrame.new(0, -1, 0) * euler(0, math.random(-50, 50), 0), 1, 1, 1, 1, 0.5, 1, 0.05)
		for i = 0, 5.14, 0.1 do
			swait()
			SphereEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
			rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.8) * angles(math.rad(24+4*i), math.rad(0), math.rad(0)), 0.2)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0+11*i), math.rad(0), math.rad(0)), 0.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(0-6*i), math.rad(0), math.rad(36+4*i)), 0.3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(0-6*i), math.rad(0), math.rad(-36-4*i)), 0.3)
			RH.C0 = clerp(RH.C0, CFrame.new(1, -0.6, -0.3) * RHCF * angles(math.rad(0), math.rad(0), math.rad(-28+4*i)), 0.2)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.2, -0.5) * LHCF * angles(math.rad(0), math.rad(0), math.rad(-34-4*i)), 0.2)
		end
		so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
		local velo=Instance.new("BodyVelocity")
		velo.velocity=vt(0,25,0)
		velo.P=8000
		velo.maxForce=Vector3.new(math.huge, math.huge, math.huge)
		velo.Parent=root
		game:GetService("Debris"):AddItem(velo,0.7)
	
	
	
		con5=hum.Touched:connect(function(hit)
			if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
				if attackdebounce == false then
					attackdebounce = true  
					coroutine.resume(coroutine.create(function()
						for i = 0,1.5,0.1 do
							swait()
							hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.6,-1.8)
						end
					end))
					kDamagefunc(hit,3,4,math.random(0,0),"Normal",root,0,1)
					so("http://roblox.com/asset/?id=636494529",rl,2,1)
					RingEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
					RingEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
					SphereEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)
	
	
	
					coroutine.resume(coroutine.create(function()
						for i = 0,1,0.1 do
							swait()
							hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.75*1.8,0.75*1.8),math.random(-0.75*1.8,0.75*1.8),math.random(-0.75*1.8,0.75*1.8)),0.44)
						end
					end))
	
	
					wait(0.14)
					attackdebounce = false
				end
			end
		end)
	
		for i = 0, 5.11, 0.15 do
			swait()
			BlockEffect(BrickColor.new("White"), rl.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
			rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, 0.1+0.2*i) * angles(math.rad(-10-80*i), math.rad(0), math.rad(0)), 0.42)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(-43), math.rad(0), math.rad(0)), 0.42)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-8), math.rad(0), math.rad(60)), 0.35)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-8), math.rad(0), math.rad(-60)), 0.35)
			RH.C0 = clerp(RH.C0, CFrame.new(1, -0.5, 0) * RHCF * angles(math.rad(0), math.rad(0), math.rad(20+10*i)), 0.42)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.5, -0.4) * LHCF * angles(math.rad(0), math.rad(0), math.rad(24)), 0.42)
		end
	
	
		attack = false
		con5:disconnect()
	end
	
	
	
	
	
	local cooldown = false
	function quickkick()
		attack = true
	
	
		con5=hum.Touched:connect(function(hit)
			if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
				if attackdebounce == false then
					attackdebounce = true  
	
					coroutine.resume(coroutine.create(function()
						for i = 0,1.5,0.1 do
							swait()
							hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.3,-1.8)
						end
					end))
	
					kDamagefunc(hit,1,2,math.random(0,0),"Normal",root,0,1)
					so("http://roblox.com/asset/?id=636494529",rl,2,1)
					RingEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
					RingEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
					SphereEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)
	
	
	
					coroutine.resume(coroutine.create(function()
						for i = 0,1,0.1 do
							swait()
							hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.8*1.8,0.8*1.8),math.random(-0.8*1.8,0.8*1.8),math.random(-0.8*1.8,0.8*1.8)),0.44)
						end
					end))
	
	
					wait(0.08)
					attackdebounce = false
				end
			end
		end)
	
		so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
		for i = 0, 11.14, 0.3 do
			swait()
			root.Velocity = root.CFrame.lookVector * 30
			BlockEffect(BrickColor.new("White"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
			rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(-21-30*i), math.rad(8+10*i), math.rad(0-90*i)), 0.35)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
			RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-64-2*i), math.rad(0), math.rad(0-9*i)), 0.35)
		end
		attack = false
		con5:disconnect()
	end
	
	
	
	
	
	
	
	
	function Taunt()
		attack = true
		hum.WalkSpeed = 0
		Cso("1535995570", hed, 8.45, 1)
		for i = 0, 8.2, 0.1 do
			swait()
			hum.WalkSpeed = 0
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 12)) * angles(Rad(0), Rad(0), Rad(0)), 0.2)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(25), Rad(0), Rad(16 * Cos(sine / 12))), 0.2)
			RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(75), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.1)
			LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-75), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.1)
			RW.C0 = clerp(RW.C0, CF(1.1* Player_Size, 0.5 + 0.05 * Sin(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(180), Rad(6), Rad(-56)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1* Player_Size, 0.1 + 0.05 * Sin(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(45), Rad(6), Rad(86)), 0.1)
		end
		attack = false
		hum.WalkSpeed = 8
	end
	
	
	
	
	
	
	
	function Hyperkickcombo()
	
		attack = true
		so("http://www.roblox.com/asset/?id=1452040709", RightLeg, 3, 1)
		WaveEffect(BrickColor.new("White"), root.CFrame * CFrame.new(0, -1, 0) * euler(0, math.random(-50, 50), 0), 1, 1, 1, 1, 0.5, 1, 0.05)
		for i = 0, 7.14, 0.1 do
			swait()
			SphereEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
			rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.8) * angles(math.rad(24), math.rad(0), math.rad(0)), 0.2)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-20), math.rad(0), math.rad(36)), 0.3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-20), math.rad(0), math.rad(-36)), 0.3)
			RH.C0 = clerp(RH.C0, CFrame.new(1, -0.6, -0.3) * RHCF * angles(math.rad(0), math.rad(0), math.rad(-28)), 0.2)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.2, -0.5) * LHCF * angles(math.rad(0), math.rad(0), math.rad(-34)), 0.2)
		end
		local Cracking = Cso("292536356", tors, 10, 1)
		for i = 0, 7.14, 0.1 do
			swait()
			hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
			Aura(5, 0.15, "Add" , root.CFrame * CF(Mrandom(-12, 12), -6, Mrandom(-12, 12)) * angles(Rad(90 + Mrandom(-12, 12)), 0, 0), 1.5, 1.5, 10, -0.015, BrickC"Lime green", 0, "Sphere")
			WaveEffect(BrickColor.new("Lime green"), root.CFrame * CFrame.new(0, -6, 0) * euler(0, math.random(-25, 25), 0), 1, 1, 1, 1, 0.2, 1, 0.05)
			SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
			SphereEffect(BrickColor.new("Lime green"),ll.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
			rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.8) * angles(math.rad(24), math.rad(0), math.rad(0)), 0.2)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(30), math.rad(0), math.rad(0)), 0.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(20), math.rad(0), math.rad(36)), 0.3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(20), math.rad(0), math.rad(-36)), 0.3)
			RH.C0 = clerp(RH.C0, CFrame.new(1, -0.6, -0.3) * RHCF * angles(math.rad(0), math.rad(0), math.rad(-28)), 0.2)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.2, -0.5) * LHCF * angles(math.rad(0), math.rad(0), math.rad(-34)), 0.2)
		end
		Cracking.Playing = false
		so("http://www.roblox.com/asset/?id=197161452", char, 3, 0.8)
		so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
		SphereEffect(BrickColor.new("Lime green"),tors.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,38,38,38,0.08)
		local velo=Instance.new("BodyVelocity")
		velo.velocity=vt(0,27,0)
		velo.P=11000
		velo.maxForce=Vector3.new(math.huge, math.huge, math.huge)
		velo.Parent=root
		game:GetService("Debris"):AddItem(velo,1.24)
	
	
	
		con5=hum.Touched:connect(function(hit)
			if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
				if attackdebounce == false then
					attackdebounce = true  
					coroutine.resume(coroutine.create(function()
						for i = 0,1.5,0.1 do
							swait()
							hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,3.4,-1.8)
						end
					end))
					kDamagefunc(hit,2,3,math.random(0,0),"Normal",root,0,1)
					so("http://roblox.com/asset/?id=636494529",rl,2,1.6)
					RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
					RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
					SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)
	
	
	
					coroutine.resume(coroutine.create(function()
						for i = 0,1,0.1 do
							swait()
							hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
						end
					end))
	
	
					wait(0.09)
					attackdebounce = false
				end
			end
		end)
	
		for i = 0, 9.11, 0.2 do
			swait()
			BlockEffect(BrickColor.new("Lime green"), rl.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
			rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, 0.1+0.12*i) * angles(math.rad(-10-95*i), math.rad(0), math.rad(0)), 0.42)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(-43), math.rad(0), math.rad(0)), 0.42)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-8), math.rad(0), math.rad(60)), 0.35)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-8), math.rad(0), math.rad(-60)), 0.35)
			RH.C0 = clerp(RH.C0, CFrame.new(1, -0.5, 0) * RHCF * angles(math.rad(0), math.rad(0), math.rad(20+10*i)), 0.42)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.5, -0.4) * LHCF * angles(math.rad(0), math.rad(0), math.rad(24)), 0.42)
		end
	
	
	
	
		con5:disconnect()
	
	
	
	
	
	
		con5=hum.Touched:connect(function(hit)
			if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
				if attackdebounce == false then
					attackdebounce = true  
					coroutine.resume(coroutine.create(function()
						for i = 0,1.5,0.1 do
							swait()
							hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.1,-1.8)
						end
					end))
					kDamagefunc(hit,3,4,math.random(0,0),"Normal",root,0,1)
	
					so("http://roblox.com/asset/?id=636494529",rl,2,1.6)
					RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
					RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
					SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)
	
	
	
					coroutine.resume(coroutine.create(function()
						for i = 0,1,0.1 do
							swait()
							hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
						end
					end))
	
	
					wait(0.08)
					attackdebounce = false
				end
			end
		end)
	
	
	
		so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
		for i = 0, 9.14, 0.3 do
			swait()
			root.Velocity = root.CFrame.lookVector * 20
			BlockEffect(BrickColor.new("Lime green"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
			rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(53), math.rad(8), math.rad(0-54*i)), 0.35)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
			RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-64-7*i), math.rad(0), math.rad(0-9*i)), 0.35)
		end
	
	
	
		con5:disconnect()
	
	
	
		con5=hum.Touched:connect(function(hit)
			if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
				if attackdebounce == false then
					attackdebounce = true  
					coroutine.resume(coroutine.create(function()
						for i = 0,1.5,0.1 do
							swait()
							hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.1,-1.8)
						end
					end))
					kDamagefunc(hit,3,4,math.random(0,0),"Normal",root,0,1)
					so("http://roblox.com/asset/?id=636494529",rl,2,1.6)
					RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
					RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
					SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)
	
	
	
					coroutine.resume(coroutine.create(function()
						for i = 0,1,0.1 do
							swait()
							hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
						end
					end))
	
	
					wait(0.05)
					attackdebounce = false
				end
			end
		end)
	
	
		so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
		for i = 0, 15.14, 0.32 do
			swait()
			root.Velocity = root.CFrame.lookVector * 20
			BlockEffect(BrickColor.new("Lime green"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
			rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(-21-50*i), math.rad(8+20*i), math.rad(0-90*i)), 0.35)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
			RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
			RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-64-2*i), math.rad(0), math.rad(0-4*i)), 0.35)
		end
	
		attack = false
		con5:disconnect()
	
	end
	
	
	
	
	
	local ultra = false
	
	function Galekicks()
	
		attack = true
		so("http://www.roblox.com/asset/?id=1452040709", RightLeg, 3, 1)
		for i = 0, 1.65, 0.1 do
			swait()
			root.Velocity = root.CFrame.lookVector * 0
			SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
			rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
			tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
			RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
			LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
			RH.C0 = clerp(RH.C0, CFrame.new(1, .62 , -0.3) * RHCF * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
			LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
		end
	
	
		for i = 1, 17 do
	
			con5=hum.Touched:connect(function(hit)
				if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
					if attackdebounce == false then
						attackdebounce = true  
						coroutine.resume(coroutine.create(function()
							for i = 0,1.5,0.1 do
								swait()
								hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.1,-1.8)
							end
						end))
						kDamagefunc(hit,1,2,math.random(0,0),"Normal",root,0,1)
						so("http://roblox.com/asset/?id=636494529",rl,2,1.6)
						RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
						RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
						SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)
	
	
	
						coroutine.resume(coroutine.create(function()
							for i = 0,1,0.1 do
								swait()
								hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
							end
						end))
	
	
						wait(0.05)
						attackdebounce = false
					end
				end
			end)
	
			for i = 0, .1, 0.2 do
				swait()
				BlockEffect(BrickColor.new("Lime green"), rl.CFrame*CF(0,-1,0), 2, 2, 2, 1.5, 1.5, 1.5, 0.03)
				root.Velocity = root.CFrame.lookVector * 10
				rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, -0.3) * angles(math.rad(-44), math.rad(-2), math.rad(90)), 0.7)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-24), math.rad(-90)), 0.7)
				RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.7)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.7)
				RH.C0 = clerp(RH.C0, CFrame.new(1, -.6 , 0) * RHCF * angles(math.rad(math.random(-100,-10)), math.rad(0), math.rad(2)), 0.7)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-34), math.rad(0), math.rad(0)), 0.7)
			end
	
			so("http://roblox.com/asset/?id=1340545854",rl,1,math.random(0.7,1))
	
			for i = 0, 0.4, 0.2 do
				swait()
				rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
				RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
				RH.C0 = clerp(RH.C0, CFrame.new(1, .62 , -0.3) * RHCF * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
			end
			con5:disconnect()
		end
	
	
		u =   mouse.KeyDown:connect(function(key)
			if key == 'r' and combohits >= 150 then
				ultra = true
				SphereEffect(BrickColor.new("Really red"),tors.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,15,15,15,0.04)
			end
		end)
		wait(0.3)
		if ultra == true then 
			combohits = 0
			wait(0.1)
			for i = 0, 1.65, 0.1 do
				swait()
				root.Velocity = root.CFrame.lookVector * 0
				SphereEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
				rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
				RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
				RH.C0 = clerp(RH.C0, CFrame.new(1, .62 , -0.3) * RHCF * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
			end
	
	
			so("http://roblox.com/asset/?id=146094803",hed,1,1.2)
	
			for i = 1, 65 do
				--Aura(5, 0.15, "Add" , root.CFrame * CF(Mrandom(-12, 12), -6, Mrandom(-12, 12)) * angles(Rad(90 + Mrandom(-12, 12)), 0, 0), 1.5, 1.5, 10, -0.015, BrickC"Really red", 0, "Brick")
				con5=hum.Touched:connect(function(hit)
					if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
						if attackdebounce == false then
							attackdebounce = true  
							coroutine.resume(coroutine.create(function()
								for i = 0,1.5,0.1 do
									swait()
									hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.1,-1.8)
								end
							end))
							kDamagefunc(hit,1,2,math.random(0,0),"Normal",root,0,1)
	
	
	
	
							so("http://roblox.com/asset/?id=636494529",rl,2,1.6)
							RingEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
							RingEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
							SphereEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)
	
	
	
							coroutine.resume(coroutine.create(function()
								for i = 0,1,0.1 do
									swait()
									hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
								end
							end))
	
	
							wait(0.05)
							attackdebounce = false
						end
					end
				end)
	
				for i = 0, .03, 0.1 do
					swait()
					BlockEffect(BrickColor.new("Really red"), rl.CFrame*CF(0,-1,0), 2, 2, 2, 1.5, 1.5, 1.5, 0.03)
					root.Velocity = root.CFrame.lookVector * 10
					rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, -0.3) * angles(math.rad(-44), math.rad(-2), math.rad(90)), 0.7)
					tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-24), math.rad(-90)), 0.7)
					RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.7)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.7)
					RH.C0 = clerp(RH.C0, CFrame.new(1, -.6 , 0) * RHCF * angles(math.rad(math.random(-100,-10)), math.rad(0), math.rad(2)), 0.7)
					LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-34), math.rad(0), math.rad(0)), 0.7)
				end
	
				so("http://roblox.com/asset/?id=1340545854",rl,1,math.random(0.7,1))
	
				for i = 0, 0.07, 0.1 do
					swait()
					rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
					tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
					RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
					RH.C0 = clerp(RH.C0, CFrame.new(1, .62 , -0.3) * RHCF * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
					LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
				end
				con5:disconnect()
			end
	
			for i = 0, 1.65, 0.1 do
				swait()
				root.Velocity = root.CFrame.lookVector * 0
				SphereEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
				rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
				RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
				RH.C0 = clerp(RH.C0, CFrame.new(1, .62 , -0.3) * RHCF * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
			end
	
			con5=hum.Touched:connect(function(hit)
				if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
					if attackdebounce == false then
						attackdebounce = true  
						coroutine.resume(coroutine.create(function()
							for i = 0,1.5,0.1 do
								swait()
								--hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.1,-1.8)
							end
						end))
						kDamagefunc(hit, 1, 3, 0,"Normal",root,0,1)
						so("http://roblox.com/asset/?id=636494529",rl,2,.63)
						RingEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
						RingEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
						SphereEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)
	
	
						coroutine.resume(coroutine.create(function()
							for i = 0,1,0.1 do
								swait()
								hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
							end
						end))
	
	
						wait(0.05)
						attackdebounce = false
					end
				end
			end)
	
			so("http://www.roblox.com/asset/?id=1452040709", RightLeg, 1, 1.4)
			SphereEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,38,38,38,0.08)
	
			for i = 0, 2, 0.1 do
				swait()
				--BlockEffect(BrickColor.new("Really red"), rl.CFrame*CF(0,-1,0), 2, 2, 2, 1.5, 1.5, 1.5, 0.03)
				rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
				RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
				RH.C0 = clerp(RH.C0, CFrame.new(1, -.6 , 0.2) * RHCF * angles(math.rad(-50), math.rad(0), math.rad(2)), 0.2)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
			end
			SphereEffect(BrickColor.new("Really red"),tors.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,8,8,8,0.04)
	
			wait(0.25)
			con5:Disconnect() 
	
	
	
	
			con5=hum.Touched:connect(function(hit)
				if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
					if attackdebounce == false then
						attackdebounce = true  
	
						kDamagefunc(hit,1,2,math.random(0,0),"Normal",root,0,1)
						so("http://roblox.com/asset/?id=565207203",ll,7,0.63)
	
						RingEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,2.2,6,2.2,0.04)
						RingEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,2.2,6,2.2,0.04)
						SphereEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,8,8,8,0.04)
						SpecialEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,8,8,8,0.04)
						SphereEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,5,18,5,0.04)
						WaveEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,1.5,16,1.5,0.04)
	
						coroutine.resume(coroutine.create(function()
							for i = 0,1,0.1 do
								swait()
								hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8)),0.24)
							end
						end))
	
						wait(0.06)
						attackdebounce = false
	
					end
				end
			end)
	
			coroutine.resume(coroutine.create(function()
				while ultra == true do
					swait()
					root.CFrame = root.CFrame*CFrame.new(math.random(-3,3),math.random(-2,2),math.random(-3,3))
				end
			end))
	
	
			so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
			for i = 1,3 do
				for i = 0, 9.14, 0.45 do
					swait()
					root.Velocity = root.CFrame.lookVector * 30
					BlockEffect(BrickColor.new("Really red"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
					rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(8), math.rad(8), math.rad(0-94*i)), 0.35)
					tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
					RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
					LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-64-7*i), math.rad(0), math.rad(0-9*i)), 0.35)
				end
			end
	
	
			for i = 1,3 do
				for i = 0, 11.14, 0.45 do
					swait()
					root.Velocity = root.CFrame.lookVector * 30
					BlockEffect(BrickColor.new("Really red"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
					rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(-21-30*i), math.rad(8+10*i), math.rad(0-110*i)), 0.35)
					tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
					RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(27), math.rad(0), math.rad(74)), 0.35)
					LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-34-2*i), math.rad(0), math.rad(0-9*i)), 0.35)
				end
	
	
	
			end
			so("http://www.roblox.com/asset/?id=197161452", char, 0.5, 0.8)
			con5:disconnect()
	
	
		end -- combo hit end
		attack = false
		ultra = false
		u:disconnect()
	
	end
	
	
	
	
	-------------------------------------------------------
	--End Attacks N Stuff--
	-------------------------------------------------------
	mouse.KeyDown:connect(function(key)
		if string.byte(key) == 48 then
			Swing = 2
			hum.WalkSpeed = 24.82
		end
	end)
	mouse.KeyUp:connect(function(key)
		if string.byte(key) == 48 then
			Swing = 1
			hum.WalkSpeed = 8
		end
	end)
	
	
	
	
	
	
	
	mouse.NewButton1Down:connect(function()
		if attack==false then
			if attacktype==1 then
				attack=true
				attacktype=2
				attackone()
			elseif attacktype==2 then
				attack=true
				attacktype=3
				attacktwo()
			elseif attacktype==3 then
				attack=true
				attacktype=4
				attackthree()
			elseif attacktype==4 then
				attack=true
				attacktype=1
				attackfour()
			end
		end
	end)
	
	
	
	
	mouse.KeyDown:connect(function(key)
		if key == 'e' and attack == false and cankick == true and cooldown == false then
			quickkick()
			cooldown = true
	
			coroutine.resume(coroutine.create(function()
				wait(2)
				cooldown = false
			end))
	
	
	
		end
	end)
	
	
	
	
	
	
	
	
	mouse.KeyDown:connect(function(key)
		if attack == false then
			if key == 't' then
				Taunt()
			elseif key == 'f' then
				Hyperkickcombo()
			elseif key == 'r' then
				Galekicks()
			end
		end
	end)
	
	-------------------------------------------------------
	--Start Animations--
	-------------------------------------------------------
	print("By Makhail07 and KillerDarkness0105")
	print("Basic Animations by Makhail07")
	print("Attack Animations by KillerDarkness0105")
	print("This is pretty much our final script together")
	print("--------------------------------")
	print("Attacks")
	print("E in air: Quick Kicks")
	print("Left Mouse: 4 click combo")
	print("F: Hyper Kicks")
	print("R: Gale Kicks, Spam R if your combo is over 150 to do an ultra combo")
	print("--------------------------------")
	while true do
		swait()
		sine = sine + change
		local torvel = (root.Velocity * Vector3.new(1, 0, 1)).magnitude
		local velderp = root.Velocity.y
		hitfloor, posfloor = rayCast(root.Position, CFrame.new(root.Position, root.Position - Vector3.new(0, 1, 0)).lookVector, 4* Player_Size, char)
	
		if hitfloor == nil then
			cankick = true
		else
			cankick = false
		end
	
	
		if equipped == true or equipped == false then
			if attack == false then
				idle = idle + 1
			else
				idle = 0
			end
			if 1 < root.Velocity.y and hitfloor == nil then
				Anim = "Jump"
				if attack == false then
					hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(-16), Rad(0), Rad(0)), 0.15)
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.1)
					RH.C0 = clerp(RH.C0, CF(1* Player_Size, -.2 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
					LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.9 - 0.1 * Cos(sine / 20), -.5* Player_Size) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(13 + 4.5 * Sin(sine / 20))), 0.1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(-13 - 4.5 * Sin(sine / 20))), 0.1)
				end
			elseif -1 > root.Velocity.y and hitfloor == nil then
				Anim = "Fall"
				if attack == false then
					hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(24), Rad(0), Rad(0)), 0.15)
					neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.1)
					RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
					LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * LHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(65), Rad(-.6), Rad(45 + 4.5 * Sin(sine / 20))), 0.1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(55), Rad(-.6), Rad(-45 - 4.5 * Sin(sine / 20))), 0.1)
				end
			elseif torvel < 1 and hitfloor ~= nil then
				Anim = "Idle"
				change = 1
				if attack == false then
					hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 12)) * angles(Rad(0), Rad(0), Rad(20)), 0.1)
					tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-6.5 * Sin(sine / 12)), Rad(0), Rad(-20)), 0.1)
					RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(75), Rad(0)) * angles(Rad(-12.5), Rad(0), Rad(0)), 0.1)
					LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(-65), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(6)), 0.1)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.2 + 0.05 * Sin(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(110), Rad(6 + 6.5 * Sin(sine / 12)), Rad(25)), 0.1)
					LW.C0 = clerp(LW.C0, CF(-1.3* Player_Size, 0.2 + 0.05 * Sin(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(110), Rad(6 - 6.5 * Sin(sine / 12)), Rad(25)), 0.1)
				end
			elseif torvel > 2 and torvel < 22 and hitfloor ~= nil then
				Anim = "Walk"
				change = 1
				if attack == false then
					hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(3 - 2.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(8 * Cos(sine / 7))), 0.15)
					tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-1), Rad(0), Rad(0) - hed.RotVelocity.Y / 15), 0.15)
					RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.8 - 0.5 * Cos(sine / 7) / 2* Player_Size, 0.6 * Cos(sine / 7) / 2* Player_Size)  * angles(Rad(-15 - 15 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
					LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.8 + 0.5 * Cos(sine / 7) / 2* Player_Size, -0.6 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 + 15 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(56)  * Cos(sine / 7) , Rad(10 * Cos(sine / 7)), Rad(6) - ra.RotVelocity.Y / 75), 0.1)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-56)  * Cos(sine / 7) , Rad(10 * Cos(sine / 7)) ,	Rad(-6) + la.RotVelocity.Y / 75), 0.1)
				end
			elseif torvel >= 22 and hitfloor ~= nil then
				Anim = "Sprint"
				change = 1.35
				if attack == false then
					hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
					rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(26 - 4.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(15 * Cos(sine / 7))), 0.15)
					tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-8.5 - 2 * Sin(sine / 20)), Rad(0), Rad(0) - hed.RotVelocity.Y / 15), 0.15)
					RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.925 - 0.5 * Cos(sine / 7) / 2* Player_Size, 0.7 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 - 55 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 0.1 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 0.1 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
					LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.925 + 0.5 * Cos(sine / 7) / 2* Player_Size, -0.7 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 + 55 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 0.1 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 0.1 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
					RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 30)* Player_Size, 0.34 * Cos(sine / 7* Player_Size)) * angles(Rad(-65) , Rad(0), Rad(13) - ra.RotVelocity.Y / 75), 0.15)
					LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 30)* Player_Size, -0.34 * Cos(sine / 7* Player_Size)) * angles(Rad(-65)  , Rad(0) ,	Rad(-13) + la.RotVelocity.Y / 75), 0.15)
				end
			end
		end
		Music.SoundId = "rbxassetid://"..SONG
		Music.Looped = true
		Music.Pitch = 1
		Music.Volume = 0.7
		Music.Parent = tors
		Music:Resume()
		if 0 < #Effects then
			for e = 1, #Effects do
				if Effects[e] ~= nil then
					local Thing = Effects[e]
					if Thing ~= nil then
						local Part = Thing[1]
						local Mode = Thing[2]
						local Delay = Thing[3]
						local IncX = Thing[4]
						local IncY = Thing[5]
						local IncZ = Thing[6]
						if 1 >= Thing[1].Transparency then
							if Thing[2] == "Block1" then
								Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
								local Mesh = Thing[1].Mesh
								Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
								Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							elseif Thing[2] == "Block2" then
								Thing[1].CFrame = Thing[1].CFrame + Vector3.new(0, 0, 0)
								local Mesh = Thing[7]
								Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
								Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							elseif Thing[2] == "Block3" then
								Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)) + Vector3.new(0, 0.15, 0)
								local Mesh = Thing[7]
								Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
								Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							elseif Thing[2] == "Cylinder" then
								local Mesh = Thing[1].Mesh
								Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
								Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							elseif Thing[2] == "Blood" then
								local Mesh = Thing[7]
								Thing[1].CFrame = Thing[1].CFrame * Vector3.new(0, 0.5, 0)
								Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
								Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							elseif Thing[2] == "Elec" then
								local Mesh = Thing[1].Mesh
								Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
								Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							elseif Thing[2] == "Disappear" then
								Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							elseif Thing[2] == "Shatter" then
								Thing[1].Transparency = Thing[1].Transparency + Thing[3]
								Thing[4] = Thing[4] * CFrame.new(0, Thing[7], 0)
								Thing[1].CFrame = Thing[4] * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
								Thing[6] = Thing[6] + Thing[5]
							end
						else
							Part.Parent = nil
							table.remove(Effects, e)
						end
					end
				end
			end
		end
	end
	-------------------------------------------------------
	--End Animations And Script--
	-------------------------------------------------------
else
    game.StarterGui:SetCore("ChatMakeSystemMessage", {
        Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
        Color = Color3.fromRGB(255, 0, 0),
        TextSize = 20,
        Font = Enum.Font.Cartoon
    });
end
end)



        
function playid(id, song, lastforever)
        if song ~= nil then
            if lastforever == true then
                music.PlaybackSpeed = 0.70
            else
                music.PlaybackSpeed = 1
            end
            
            music.Playing = false
            music.TimePosition = 0
            music.SoundId = "rbxassetid://"..tostring(song)
            music.Playing = true
        else
            music.TimePosition = 0
            music.Playing = false
        end
        local heartbeat = game["Run Service"].Heartbeat
        animid = 'rbxassetid://'..tostring(id)
            plr=game.Players.LocalPlayer
            bruhmomentrighthahahahhahah=plr.Character.Raw
            cf=bruhmomentrighthahahahhahah.HumanoidRootPart.CFrame
            t=bruhmomentrighthahahahhahah.Torso
            rs=t["Right Shoulder"]
            ls=t["Left Shoulder"]
            rh=t["Right Hip"]
            lh=t["Left Hip"]
            n=t["Neck"]
            rj=bruhmomentrighthahahahhahah.HumanoidRootPart["RootJoint"]
            rsc0=rs.C0
            lsc0=ls.C0
            rhc0=rh.C0
            lhc0=lh.C0
            rjc0=rj.C0
            nc0=n.C0
            gc0=CFrame.new()
            orsc0=rs.C0
            olsc0=ls.C0
            orhc0=rh.C0
            olhc0=lh.C0
            orjc0=rj.C0
            onc0=n.C0
            count2 = 100
            maxcount2=100
            game["Run Service"].Heartbeat:Connect(function()
                count2 = count2+1
                if count2<=maxcount2 then
                    rs.Transform=rs.Transform:Lerp(rsc0,count2/maxcount2)
                    ls.Transform=ls.Transform:Lerp(lsc0,count2/maxcount2)
                    rh.Transform=rh.Transform:Lerp(rhc0,count2/maxcount2)
                    lh.Transform=lh.Transform:Lerp(lhc0,count2/maxcount2)
                    n.Transform=n.Transform:Lerp(nc0,count2/maxcount2)
                    rj.Transform=rj.Transform:Lerp(rjc0,count2/maxcount2)
                end
            end)
            animid=game:GetObjects(animid)[1]
            function wait2(tim)
                if tim<0.1 then
                    wait(0.001)
                else
                for i=1,tim*40 do
                    wait(0.001)
                end
                end
            end
            anim={}
            function kftotbl(kf)
                tbl3 = {}
                for i,v in pairs(kf:GetDescendants()) do
                    if v:IsA("Pose") then
                    tbl3[string.sub(v.Name,1,1)..string.sub(v.Name,#v.Name,#v.Name)] = v.CFrame
                    end
                end
                return(tbl3)
            end
            for i,v in pairs(animid:GetChildren()) do
                if v:IsA("Keyframe") then
                anim[v.Time]=kftotbl(v)
                end
            end
            
            function getnext(tbl,number)
            c=100
            rtrnv=0
            for i,v in pairs(tbl) do
                if i>number and i-number<c then
                    c=i-number
                    rtrnv=i
                end
            end
            return(rtrnv)
            end
            count = 0
            char=game.Players.LocalPlayer.Character.Raw
            hhhh=game.Players.LocalPlayer.Character.Raw.Humanoid.Animator
            hhhh.Parent = nil
            for _,v in pairs(char.Humanoid:GetPlayingAnimationTracks()) do
                v:Stop()
            end
            while wait() do
            for i,oasjdadlasdkadkldjkl in pairs(anim) do
            asdf=getnext(anim,count)
            v=anim[asdf]
            if v["Lg"] then
                lhc0 = v["Lg"]
            end
            if v["Rg"] then
                rhc0 = v["Rg"]
            end
            if v["Lm"] then
                lsc0 = v["Lm"]
            end
            if v["Rm"] then
                rsc0 = v["Rm"]
            end
            if v["To"] then
                rjc0 = v["To"]
            end
            if v["Hd"] then
                nc0 = v["Hd"]
            end
            count2=0
            maxcount2=asdf-count
            count=asdf
            wait2(asdf-count)
            count2=maxcount2
            if v["Lg"] then
                char.Torso["Left Hip"].Transform = v["Lg"]
            end
            if v["Rg"] then
                char.Torso["Right Hip"].Transform = v["Rg"]
            end
            if v["Lm"] then
                char.Torso["Left Shoulder"].Transform = v["Lm"]
            end
            if v["Rm"] then
                char.Torso["Right Shoulder"].Transform = v["Rm"]
            end
            if v["To"] then
                char.HumanoidRootPart["RootJoint"].Transform = v["To"]
            end
            end
            end
        end

    
    

Animations:Button("Smug Dance", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("3450125501")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Parrot", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("3656900015")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Roach", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("4087012028")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Billie Jean", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("4792883833")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Conga", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("4572096542")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Whip", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("4633952191")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Floss", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("4812941481")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Carlton 2", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("4837749916")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Take The L", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("4827299133")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Aerostep", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("4776588732")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Helicopter", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("4724894341")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Smooth Moves", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("4900539662")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)
 Animations:Button("Anthony Shuffle", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("4837748730")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Kazotsky Kick", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("4846209506")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Pogo", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("3053543383")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Boogie Down", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("5025546871")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Thriller", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("4699820365")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Spongebob", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("4896926493")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Engineer", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("4677980227")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 
 Animations:Button("Sniper", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("4677930905")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Freestylin'", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("4432024917", "3132426762")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Crabby", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("3643129020")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Electro Shuffle", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("3619935462")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)



 Animations:Button("Revenge", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("3696716156")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Got That", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("3742184308")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Torture Dance", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("4109162757")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Soldier", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("4787449997")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Dream Feet", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("4300218011")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Peter Parker (what)", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("4776598075")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Goopie", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("5238669868", "5177150121")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Garry Dance", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("4300223810")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Casey", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("3442913250")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Praise the Lord", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("4776745048")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Nic", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("4550142152")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Side Hustle", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("4863897442")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Rewind", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("5011408603")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Minecraft Parrot", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("4300228160")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)


 Animations:Button("Breakdown", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("4558409610")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("OOOH A RAT!", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("4746273203")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)



 Animations:Button("Medic", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("4679640288")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Skibidi", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("4835795413")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Default Dance", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("4776575115")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Tidy", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("4831391731")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Demoman", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("4764153637")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Electro Swing", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("4820078879")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Club Penguin", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("6265042122")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Double Step", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("4715102040")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Drip", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("4959380041")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Fright Fun", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("5596328928")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Heel-toe Hop", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("5352468249")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Jive", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("5231214106")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

HatScripts:Button("Banzai Bazooka", "funny button go brr", function()
    if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		local script = game:GetObjects("rbxassetid://6730580482")[1]

local MODULE = script
local CHARACTER = game.Players.LocalPlayer.Character.Raw
local PLAYER = game.Players.LocalPlayer
local HUM = CHARACTER.Humanoid
local REMOTE = MODULE.Event

local ROOT = HUM.Torso
local HEAD = CHARACTER.Head
local TORSO = CHARACTER.Torso
local RIGHTARM = CHARACTER["Right Arm"]
local LEFTARM = CHARACTER["Left Arm"]
local RIGHTLEG = CHARACTER["Right Leg"]
local LEFTLEG = CHARACTER["Left Leg"]
local ROOTJOINT = ROOT["RootJoint"]
local NECK = TORSO["Neck"]
local RIGHTSHOULDER = TORSO["Right Shoulder"]
local LEFTSHOULDER = TORSO["Left Shoulder"]
local RIGHTHIP = TORSO["Right Hip"]
local LEFTHIP = TORSO["Left Hip"]
local MOUSEPOS = ROOT.Position

IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor

--//====================================================\\--
--||                       FE CODE
--\\====================================================//--

local owner = game.Players.LocalPlayer
local Player = owner
local Mouse,mouse,UserInputService,ContextActionService = game.Players.LocalPlayer:GetMouse(),game.Players.LocalPlayer:GetMouse(),game:GetService("UserInputService"),game:GetService("ContextActionService")


local function align(part0, part1)
    attachment = Instance.new("Attachment", part0)
    attachment.Position = Vector3.new(0.3, 0, 0) -- positioning
    attachment.Orientation = Vector3.new(-45, 90, 0) -- orienation/rotation

    attachment02 = Instance.new("Attachment", part1) -- arm or part

    lol = Instance.new("AlignPosition", part0)
    lol.Attachment0 = attachment
    lol.Attachment1 = attachment02
    lol.MaxForce = 67734
    lol.RigidityEnabled = true -- makes it not wobbly

    pog = Instance.new("AlignOrientation", part0)
    pog.Attachment0 = attachment
    pog.Attachment1 = attachment02
    pog.Responsiveness = 200
    pog.RigidityEnabled = true-- makes it not wobbly
end
game.Players.LocalPlayer.Character["Back Attack Missle Launcher"].Handle:BreakJoints()
align(game.Players.LocalPlayer.Character["Back Attack Missle Launcher"].Handle, script.Bazooka)
script.Bazooka.Transparency = 1

--//====================================================\\--
--||                  BACKGROUND VALUES
--\\====================================================//--

local ANIM_SPEED = 3
local MOUSE = PLAYER:GetMouse()
local MOUSEPOS = Mouse.Hit.p
local FRAME_SPEED = 1 / 60 -- (1 / 30) OR (1 / 60)
local CHANGE = 2 / ANIM_SPEED
local DAMAGEMULTIPLIER = 1
local ANIM = "Idle"
local KEYHOLD = false
local MOUSEHOLD = false
local SINE = 0
local ATTACKING = false
local Debris = game:GetService("Debris")
local Effects = IT("Folder",CHARACTER)
Effects.Name = "FXFolder"
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local BGM = 213546066
local BOMB = 2671146857
local STORED = 9999999999999

--//====================================================\\--
--||                     HEARTBEAT
--\\====================================================//--

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"

script:WaitForChild("ArtificialHB")

frame = FRAME_SPEED
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				ArtificialHB:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

function PositiveAngle(NUMBER)
	if NUMBER >= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function NegativeAngle(NUMBER)
	if NUMBER <= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, NUMBER do
			ArtificialHB.Event:wait()
		end
	end
end

--//====================================================\\--
--||                       CLERP
--\\====================================================//--

function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
 
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp;
	if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > 0.0001 then
			local theta = ACOS(-cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((t - 1) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end

function Clerp(a, b, t)
	local qa = {QuaternionFromCFrame(a)}
	local qb = {QuaternionFromCFrame(b)}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end

--//====================================================\\--
--||                     FUNCTIONS
--\\====================================================//--

function WeldParts(A,B)
	local WLD = IT("ManualWeld")
	WLD.Part0 = A
	WLD.Part1 = B
	WLD.C1 = B.CFrame:inverse() * A.CFrame
	WLD.Parent = A
	return WLD
end

--NewSound({ID = 0,PARENT = ROOT,VOLUME = 0.5,PITCH = 1,LOOP = false,MAXDISTANCE = 1000,EMITTERSIZE = 10,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
function NewSound(TABLE)
	local ID = "rbxassetid://"..(TABLE.ID or 0)
	local PARENT = (TABLE.PARENT or ROOT)
	local VOLUME = (TABLE.VOLUME or 0.5)
	local PITCH = (TABLE.PITCH or 1)
	local LOOP = (TABLE.LOOP or false)
	local MAXDISTANCE = (TABLE.MAXDISTANCE or 100)
	local EMITTERSIZE = (TABLE.EMITTERSIZE or 10)
	local PLAYING = (TABLE.PLAYING or true)
	local PLAYONREMOVE = (TABLE.PLAYONREMOVE or false)
	local DOESDEBRIS = (TABLE.DOESDEBRIS or true)
	if ID ~= "rbxassetid://0" then
		local SOUND = IT("Sound",PARENT)
		SOUND.SoundId = ID
		SOUND.Volume = VOLUME
		SOUND.Pitch = PITCH
		SOUND.Looped = LOOP
		SOUND.MaxDistance = MAXDISTANCE
		SOUND.EmitterSize = EMITTERSIZE
		SOUND.PlayOnRemove = PLAYONREMOVE
		if DOESDEBRIS == true and PLAYING == true and LOOP == false then
			Debris:AddItem(SOUND,SOUND.TimeLength+5)
		end
		if PLAYING == true then
			SOUND:Play()
		end
		return SOUND
	end
end

function ManSlaughter(MAN)
return
end

function AreaOfEffect(AREA,RANGE,FLING,RETURN)
	local HIT = {}
	for index, CHILD in pairs(workspace:GetChildren()) do
		if CHILD:FindFirstChildOfClass("Humanoid") then
			local HUMAN = CHILD:FindFirstChildOfClass("Humanoid")
			local ROOT = HUMAN.Torso
			if ROOT then
				if (ROOT.Position - AREA).Magnitude <= RANGE then
					if RETURN == true then
						if CHILD ~= CHARACTER then
							table.insert(HIT,{CHILD,HUMAN,ROOT})
						end
					else
						if CHILD ~= CHARACTER then
							ManSlaughter(CHILD)
						end

					end
				end
			end
		end
	end
	if RETURN == true then
		return HIT
	end
end

function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = ROOT.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end

function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function CameraShake(AREA,RANGE,SHAKE,TIMER)
	for index, CHILD in pairs(workspace:GetChildren()) do
		if CHILD:FindFirstChildOfClass("Humanoid") then
			local HUMAN = CHILD:FindFirstChildOfClass("Humanoid")
			local ROOT = HUMAN.Torso
			if ROOT and game.Players:GetPlayerFromCharacter(CHILD) then
				if (ROOT.Position - AREA).Magnitude <= RANGE then
					if CHILD:FindFirstChild("CamShake") then
						Debris:AddItem(CHILD:FindFirstChild("CamShake"),0.05)
					end
					local CAMSHAKE = script.CamShake:Clone()
					CAMSHAKE.Parent = CHILD
					local TIMER_V = IT("NumberValue",CAMSHAKE)
					TIMER_V.Name = "Timer"
					TIMER_V.Value = TIMER
					local SHAKE_V = IT("NumberValue",CAMSHAKE)
					SHAKE_V.Name = "Shake"
					SHAKE_V.Value = SHAKE
					CAMSHAKE.Disabled = false
					Debris:AddItem(CAMSHAKE,15)
				end
			end
		end
	end
end

--//====================================================\\--
--||                     CHARACTER
--\\====================================================//--

local HELMET = MODULE.Helmet
HELMET.Parent = CHARACTER
for index, CHILD in pairs(CHARACTER:GetChildren()) do
	if CHILD ~= ROOT then
		if CHILD:IsA("Accessory") then
			
		end
	end
end

HELMET.CFrame = HEAD.CFrame*CF(0,0.5,0)
HELMET.Anchored = false
WeldParts(HEAD,HELMET)
local BAZOOKA = MODULE.Bazooka
BAZOOKA.Parent = CHARACTER
BAZOOKA.Anchored = false
local GRIP = IT("Motor6D")
GRIP.Part0 = RIGHTARM
GRIP.Part1 = BAZOOKA
GRIP.C0 = CF(0,-1,-0.5)*ANGLES(RAD(-90),0,0)*CF(0,0,1.85)
local G_C0 = GRIP.C0
GRIP.Parent = RIGHTARM
for i = 1, 15 do
	local FACE = CreatePart(3, CHARACTER, "Fabric", 0, 0+(i-1)/15.2, "Dark stone grey", "FaceGradient", VT(1.01,0.58,1.01),false)
	FACE.Color = C3(0,0,0)
	HEAD:FindFirstChildOfClass("SpecialMesh"):Clone().Parent = FACE
	FACE.CFrame = HEAD.CFrame*CF(0,0.3-(i-1)/35,0)
	WeldParts(HEAD,FACE)
end
local MISSILE = MODULE.Missile
MISSILE.Parent = nil
local GUI = MODULE.ControlsGUI
GUI.Parent = PLAYER.PlayerGui
GUI.ToggleButton.MouseButton1Click:Connect(function()
	if GUI.ToggleButton.Controls.Visible == false then
		GUI.ToggleButton.Controls.Visible = true
	elseif GUI.ToggleButton.Controls.Visible == true then
		GUI.ToggleButton.Controls.Visible = false
	end
end)
local STOREDGUI = GUI.ToggleButton.Stored
STOREDGUI.Text = "STORED: "..STORED
function AddTo(ADD)
	STORED = STORED + ADD
	STOREDGUI.Text = "STORED: "..STORED
end

--//====================================================\\--
--||                     ABILITIES
--\\====================================================//--

function Fire_in_the_hole()
	if STORED > 0 then
		ATTACKING = true
		local GYRO = IT("BodyGyro")
		GYRO.D = 50
		GYRO.P = 5000
		GYRO.MaxTorque = VT(0,4000000,0)
		GYRO.CFrame = CF(ROOT.Position,Mouse.Hit.p)
		GYRO.Parent = ROOT
		ATTACKING = true
		coroutine.resume(coroutine.create(function()
			repeat
				Swait()
				GYRO.CFrame = CF(ROOT.Position,Mouse.Hit.p)
			until ATTACKING == false
			GYRO:Remove()
		end))
		repeat
			for i=0, 0.06, 0.1 / ANIM_SPEED do
				Swait()
				ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02) * ANGLES(RAD(0), RAD(0), RAD(45)), 2.5 / ANIM_SPEED)
				NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-45)) * ANGLES(RAD(5), RAD(0), RAD(0)), 2.5 / ANIM_SPEED)
				RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 2.5 / ANIM_SPEED)
				LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-45), RAD(0), RAD(-45)) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
				RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(45), RAD(0)) * CF(0.4,0,0) * ANGLES(RAD(-10), RAD(0), RAD(0)), 2.5 / ANIM_SPEED)
				LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1.1, -1, 0) * ANGLES(RAD(0), RAD(-135), RAD(0)) * CF(-0.4,0,0) * ANGLES(RAD(-10), RAD(0), RAD(0)), 2.5 / ANIM_SPEED)
			end
			AddTo(-1)
			coroutine.resume(coroutine.create(function()
				local GOTO = Mouse.Hit.p
				local ROCKET = MISSILE:Clone()
				ROCKET.Parent = Effects
				ROCKET.CFrame = CF(BAZOOKA.CFrame*CF(0,0,-2).p,GOTO)
				NewSound({ID = 440145223,PARENT = BAZOOKA,VOLUME = 2,PITCH = MRANDOM(9,11)/10,LOOP = false,MAXDISTANCE = 80,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
				NewSound({ID = 440145223,PARENT = ROCKET,VOLUME = 2,PITCH = MRANDOM(9,11)/10,LOOP = false,MAXDISTANCE = 80,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
				for i = 1, 200 do
					Swait()
					local HIT,POS = Raycast(ROCKET.Position,ROCKET.CFrame.lookVector,5,CHARACTER)
					if HIT then
						ROCKET.CFrame = CF(POS)
						break
					end
					ROCKET.CFrame = ROCKET.CFrame*CF(0,0,-4)
				end
				ROCKET.Transparency = 1
				ROCKET.Hind:Remove()
				ROCKET.CFrame = CF(ROCKET.Position)
				ROCKET.Size = VT(0,0,0)
				NewSound({ID = 142070127,PARENT = ROCKET,VOLUME = 7,PITCH = MRANDOM(8,12)/10,LOOP = false,MAXDISTANCE = 300,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
				for index, CHILD in pairs(script.Grenade:GetChildren()) do
					local C = CHILD:Clone()
					C.Parent = ROCKET
					C:Emit(125)
				end
				CameraShake(ROCKET.Position,50,125,70)
				AreaOfEffect(ROCKET.Position,35,200,false)
				Debris:AddItem(ROCKET,2)
			end))
			for i=0, 0.025, 0.1 / ANIM_SPEED do
				Swait()
				ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02) * ANGLES(RAD(0), RAD(0), RAD(45)), 2.5 / ANIM_SPEED)
				NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-45)) * ANGLES(RAD(5), RAD(0), RAD(0)), 2.5 / ANIM_SPEED)
				RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(200), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 2.5 / ANIM_SPEED)
				LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-45), RAD(0), RAD(-45)) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
				RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(45), RAD(0)) * CF(0.4,0,0) * ANGLES(RAD(-10), RAD(0), RAD(0)), 2.5 / ANIM_SPEED)
				LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1.1, -1, 0) * ANGLES(RAD(0), RAD(-135), RAD(0)) * CF(-0.4,0,0) * ANGLES(RAD(-10), RAD(0), RAD(0)), 2.5 / ANIM_SPEED)
			end
		until MOUSEHOLD == false or STORED <= 0
		if STORED <= 0 then
			STORED = 0
			STOREDGUI.Text = "STORED: 0"
		end
		ATTACKING = false
	end
end
function Store()
	HUM.WalkSpeed = 0
	HUM.JumpPower = 0
	ATTACKING = true
	repeat
		for i=0, 0.01, 0.1 / ANIM_SPEED do
			Swait()
			GRIP.C0 = Clerp(GRIP.C0, CF(0,-1,-0.5)*ANGLES(RAD(-80),RAD(15),0)*CF(0,0,1.85), 2.5 / ANIM_SPEED)
			ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02 + 0.05 * COS(SINE / 6)) * ANGLES(RAD(0), RAD(0), RAD(-5)), 0.5 / ANIM_SPEED)
			NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(15)), 2.5 / ANIM_SPEED)
			RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.7, 0.45, 0) * ANGLES(RAD(35), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, 2.5 / ANIM_SPEED)
			LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(45), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 2.5 / ANIM_SPEED)
			RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / ANIM_SPEED)
			LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / ANIM_SPEED)
		end
		local ROCKET = MISSILE:Clone()
		ROCKET.Anchored = false
		ROCKET:ClearAllChildren()
		ROCKET.CFrame = LEFTARM.CFrame*CF(0,-1,0) * ANGLES(RAD(0), RAD(90), RAD(0))
		ROCKET.Parent = CHARACTER
		WeldParts(ROCKET,LEFTARM)
		for i=0, 0.02, 0.1 / ANIM_SPEED do
			Swait()
			GRIP.C0 = Clerp(GRIP.C0, CF(0,-1,-0.5)*ANGLES(RAD(-80),RAD(15),0)*CF(0,0,1.85), 2.5 / ANIM_SPEED)
			ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02 + 0.05 * COS(SINE / 6)) * ANGLES(RAD(0), RAD(0), RAD(-5)), 0.5 / ANIM_SPEED)
			NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(15)), 2.5 / ANIM_SPEED)
			RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.675, 0.45, 0.3) * ANGLES(RAD(35), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, 2.5 / ANIM_SPEED)
			LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-45), RAD(0), RAD(25)) * LEFTSHOULDERC0, 2.5 / ANIM_SPEED)
			RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / ANIM_SPEED)
			LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / ANIM_SPEED)
		end
		for i=0, 0.02, 0.1 / ANIM_SPEED do
			Swait()
			GRIP.C0 = Clerp(GRIP.C0, CF(0,-1,-0.5)*ANGLES(RAD(-80),RAD(15),0)*CF(0,0,1.85), 2.5 / ANIM_SPEED)
			ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02 + 0.05 * COS(SINE / 6)) * ANGLES(RAD(0), RAD(0), RAD(-5)), 0.5 / ANIM_SPEED)
			NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(15)), 2.5 / ANIM_SPEED)
			RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.7, 0.45, 0) * ANGLES(RAD(35), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, 2.5 / ANIM_SPEED)
			LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(45), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 2.5 / ANIM_SPEED)
			RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / ANIM_SPEED)
			LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(-2.5)), 0.5 / ANIM_SPEED)
		end
		NewSound({ID = 440145223,PARENT = BAZOOKA,VOLUME = 1,PITCH = MRANDOM(9,11)/6,LOOP = false,MAXDISTANCE = 80,EMITTERSIZE = 15,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
		for i=0, 0.05, 0.1 / ANIM_SPEED do
			Swait()
			GRIP.C0 = Clerp(GRIP.C0, CF(0,-1,-0.5)*ANGLES(RAD(-80),RAD(15),0)*CF(0,0,1.85), 2.5 / ANIM_SPEED)
			ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02 + 0.05 * COS(SINE / 6)) * ANGLES(RAD(0), RAD(0), RAD(5)), 0.5 / ANIM_SPEED)
			NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(-15)), 2.5 / ANIM_SPEED)
			RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.75, 0.45, -0.1) * ANGLES(RAD(45), RAD(0), RAD(-45)) * RIGHTSHOULDERC0, 2.5 / ANIM_SPEED)
			LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-0.9, 0.5, -0.75) * ANGLES(RAD(60), RAD(0), RAD(37.5)) * LEFTSHOULDERC0, 2.5 / ANIM_SPEED)
			RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(2.5)), 0.5 / ANIM_SPEED)
			LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(2.5)), 0.5 / ANIM_SPEED)
		end
		ROCKET:Remove()
		BAZOOKA.Face.Pop:Emit(5)
		AddTo(1)
	until KEYHOLD == false
	ATTACKING = false
	HUM.WalkSpeed = 100
	HUM.JumpPower = 50
end

function Dance()
	HUM.WalkSpeed = 0
	HUM.JumpPower = 0
	ATTACKING = true
	local REMOVETRACK = false
	local TRACK = nil
	if ROOT:FindFirstChild("BGM_MUSIC") then
		TRACK = ROOT:FindFirstChild("BGM_MUSIC")
		TRACK.Volume = 5
	else
		TRACK = NewSound({ID = BOMB,PARENT = ROOT,VOLUME = 5,PITCH = 1,LOOP = true,MAXDISTANCE = 300,EMITTERSIZE = 300,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
		REMOVETRACK = true
	end
	TRACK.SoundId = "rbxassetid://"..BOMB
	TRACK:Play()
	local DONEWITHDANCING = false
	local NC = mouse.KeyDown:connect(function(key)
		key=key:lower()
		local V2 = key
		if V2 == "m" then
			DONEWITHDANCING = true
			ATTACKING = false
			if REMOVETRACK == true then
				TRACK:Remove()
			else
				TRACK:Play()
				TRACK.Volume = 1.25
				TRACK.SoundId = "rbxassetid://"..BGM
			end
		end
	end)
	local I = 0
	local RAVE = IT("PointLight",ROOT)
	RAVE.Brightness = 25
	RAVE.Color = BrickColor.random().Color
	repeat
		I = I + 2
		Swait()
		RAVE.Color = BrickColor.random().Color
		ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0 - 0.32 * SIN(I / 10), 0, -0.55 - 0.05 * COS(I / 5)) * ANGLES(RAD(0), RAD(0 - 20 * SIN(I / 10)), RAD(0)), 1.5 / ANIM_SPEED)
		NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0 - 20 * SIN(I / 10)), RAD(0)), 1.5 / ANIM_SPEED)
		RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(170), RAD(10), RAD(-35 * COS(I/10)))  *CF(0,-1,0) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
		LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(170), RAD(-10), RAD(-35 * COS(I/10))) * CF(0,-1,0) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
		RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1.35, -0.475 + 0.36 * SIN(I / 10) + 0.05 * COS(I / 5), -0.35) * ANGLES(RAD(0), RAD(45), RAD(0)) * ANGLES(RAD(-12 - 19 * SIN(I / 10)), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
		LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1.35, -0.475 - 0.36 * SIN(I / 10) + 0.05 * COS(I / 5), -0.35) * ANGLES(RAD(0), RAD(-45), RAD(0)) * ANGLES(RAD(-12 + 19 * SIN(I / 10)), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
	until DONEWITHDANCING == true
	RAVE:Remove()
	NC:Disconnect()
	if REMOVETRACK == true then
		TRACK:Remove()
	else
		TRACK:Play()
		TRACK.Volume = 1.25
		TRACK.SoundId = "rbxassetid://"..BGM
	end
	ATTACKING = false
	HUM.WalkSpeed = 100
	HUM.JumpPower = 50
end

--//====================================================\\--
--||                       WRAP
--\\====================================================//--

mouse.Button1Down:connect(function()
	MOUSEHOLD = true
	if ATTACKING == false then
		Fire_in_the_hole()
	end
end)

mouse.Button1Up:connect(function()
	MOUSEHOLD = false
end)

mouse.KeyDown:connect(function(key)
	key=key:lower()
	local V2 = key
	KEYHOLD = true
				if V2 == "z" then
					Store()
				elseif V2 == "m" then
					Dance()
				elseif V2 == "t" then
					NewSound({ID = 145757437,PARENT = ROOT,VOLUME = 10,PITCH = 1,LOOP = false,MAXDISTANCE = 100,EMITTERSIZE = 25,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
				elseif V2 == "e" then
					if ROOT:FindFirstChild("BGM_MUSIC") then
						ROOT:FindFirstChild("BGM_MUSIC"):Remove()
					else
						local M = NewSound({ID = BGM,PARENT = ROOT,VOLUME = 1.25,PITCH = 1,LOOP = true,MAXDISTANCE = 300,EMITTERSIZE = 300,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
						M.Name = "BGM_MUSIC"
					end
				end
end)

mouse.KeyUp:connect(function()
	KEYHOLD = false
end)

--[[
REMOTE.OnClientEvent:Connect(function(PLR,V1,V2)
	if PLR == PLAYER and ANIM ~= "Sit" then
		--if V1 == "MousePositionUpdate" then
			--MOUSEPOS = V2
		if V1 == "KeyUp" then
			KEYHOLD = false
		elseif V1 == "MouseUp" then
			MOUSEHOLD = false
		end
		if ATTACKING == false then
			if V1 == "MouseDown" then
				MOUSEHOLD = true
				Fire_in_the_hole()
			elseif V1 == "KeyDown" then
				KEYHOLD = true
				if V2 == "z" then
					Store()
				elseif V2 == "m" then
					Dance()
				elseif V2 == "t" then
					NewSound({ID = 145757437,PARENT = ROOT,VOLUME = 10,PITCH = 1,LOOP = false,MAXDISTANCE = 100,EMITTERSIZE = 25,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
				elseif V2 == "e" then
					if ROOT:FindFirstChild("BGM_MUSIC") then
						ROOT:FindFirstChild("BGM_MUSIC"):Remove()
					else
						local M = NewSound({ID = BGM,PARENT = ROOT,VOLUME = 1.25,PITCH = 1,LOOP = true,MAXDISTANCE = 300,EMITTERSIZE = 300,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
						M.Name = "BGM_MUSIC"
					end
				end
			end
		end
	end
end)
]]--

local M = NewSound({ID = BGM,PARENT = ROOT,VOLUME = 1.25,PITCH = 1,LOOP = true,MAXDISTANCE = 300,EMITTERSIZE = 300,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
M.Name = "BGM_MUSIC"
HUM.WalkSpeed = 100
while true do
	Swait()
	local MOUSEPOS = Mouse.Hit.p
	SINE = SINE + CHANGE
	if CHARACTER:FindFirstChild("Animate") then
		CHARACTER:FindFirstChild("Animate"):Destroy()
	end
	if CHARACTER:FindFirstChild("Sound") then
		CHARACTER:FindFirstChild("Sound"):Destroy()
	end
	for _,v in next, HUM:GetPlayingAnimationTracks() do
		v:Stop();
	end
	local TORSOVELOCITY = (ROOT.Velocity * VT(1, 0, 1)).magnitude
	local TORSOVERTICALVELOCITY = ROOT.Velocity.y
	local HITFLOOR = Raycast(ROOT.Position, (CF(ROOT.Position, ROOT.Position + VT(0, -1, 0))).lookVector, 4+HUM.HipHeight, CHARACTER)
	local WALKSPEEDVALUE = 0.5
	local SITTING = HUM.Sit
	if ANIM == "Walk" and TORSOVELOCITY > 1 and SITTING == false then
		RIGHTHIP.C1 = Clerp(RIGHTHIP.C1, CF(0.5, 0.875 - 0.3 * SIN(SINE / WALKSPEEDVALUE), -0.5 * COS(SINE / WALKSPEEDVALUE) +0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0) - RIGHTLEG.RotVelocity.Y / 35, RAD(0), RAD(55 * COS(SINE / WALKSPEEDVALUE))), 2 / ANIM_SPEED)
		LEFTHIP.C1 = Clerp(LEFTHIP.C1, CF(-0.5, 0.875 + 0.3 * SIN(SINE / WALKSPEEDVALUE), 0.5 * COS(SINE / WALKSPEEDVALUE) +0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0) + LEFTLEG.RotVelocity.Y / 35, RAD(0), RAD(55 * COS(SINE / WALKSPEEDVALUE))), 2 / ANIM_SPEED)
	elseif (ANIM ~= "Walk") or (TORSOVELOCITY < 1) or SITTING == true then
		RIGHTHIP.C1 = Clerp(RIGHTHIP.C1, CF(0.5, 1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / ANIM_SPEED)
		LEFTHIP.C1 = Clerp(LEFTHIP.C1, CF(-0.5, 1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / ANIM_SPEED)
	end
	if ATTACKING == false then
		GRIP.C0 = Clerp(GRIP.C0, G_C0, 1.5 / ANIM_SPEED)
	end
	if SITTING == false then
		if HITFLOOR then
			if TORSOVELOCITY < 1 and HITFLOOR ~= nil then
				ANIM = "Idle"
				if ATTACKING == false then
					ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.02 + 0.05 * COS(SINE / 6)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
					NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * COS(SINE / 6)), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
					RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(100), RAD(0), RAD(5 + 2.5 * COS(SINE / 6))) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
					LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-25 - 2.5 * COS(SINE / 6))) * LEFTSHOULDERC0, 1.5 / ANIM_SPEED)
					RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
					LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1 - 0.05 * COS(SINE / 6), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(0)), 1.5 / ANIM_SPEED)
				end
			elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
				ANIM = "Walk"
				if ATTACKING == false then
					ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.05 + 0.05 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(-10), RAD(0), RAD(0)), 2 / ANIM_SPEED)
					NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(10), RAD(0), RAD(0)), 2 / ANIM_SPEED)
					RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(135), RAD(0), RAD(5 + 2.5 * COS(SINE / WALKSPEEDVALUE))) * RIGHTSHOULDERC0, 2 / ANIM_SPEED)
					LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-15), RAD(0), RAD(-25 - 2.5 * COS(SINE / WALKSPEEDVALUE))) * LEFTSHOULDERC0, 2 / ANIM_SPEED)
					RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1 , -1 - 0.05 * COS(SINE / WALKSPEEDVALUE), 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-15)), 2 / ANIM_SPEED)
					LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1 - 0.05 * COS(SINE / WALKSPEEDVALUE), 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(15)), 2 / ANIM_SPEED)
				end
			end
		else
			if TORSOVERTICALVELOCITY > 0 then
				ANIM = "Jump"
				if ATTACKING == false then
					ROOTJOINT.C0 = Clerp(ROOTJOINT.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / ANIM_SPEED)
					NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-20), RAD(0), RAD(0)), 1 / ANIM_SPEED)
					RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(25), RAD(0), RAD(5 + 2.5 * COS(SINE / 6))) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
					LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-2), RAD(0), RAD(10)) * LEFTSHOULDERC0, 1 / ANIM_SPEED)
					RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -0.4, -0.6) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-20)), 1 / ANIM_SPEED)
					LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1, -0.3) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 1 / ANIM_SPEED)
			    end
			else
				ANIM = "Fall"
				if ATTACKING == false then
					ROOTJOINT.C0 = Clerp(ROOTJOINT.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / ANIM_SPEED)
					NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(20), RAD(0), RAD(0)), 1 / ANIM_SPEED)
					RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(150), RAD(0), RAD(5 + 2.5 * COS(SINE / 6))) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
					LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-2), RAD(0), RAD(-60)) * LEFTSHOULDERC0, 1 / ANIM_SPEED)
					RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -0.5, -0.5) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 1 / ANIM_SPEED)
					LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 1 / ANIM_SPEED)
				end
			end
		end
	else
		ANIM = "Sit"
		if ATTACKING == false then
			ROOTJOINT.C0 = Clerp(ROOTJOINT.C0,ROOTC0 * CF(0, 0, -0.5) * ANGLES(RAD(0), RAD(0), RAD(0)), 1.25 / ANIM_SPEED)
			NECK.C0 = Clerp(NECK.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1.25 / ANIM_SPEED)
			RIGHTSHOULDER.C0 = Clerp(RIGHTSHOULDER.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 1.5 / ANIM_SPEED)
			LEFTSHOULDER.C0 = Clerp(LEFTSHOULDER.C0, CF(-1.5, 0.65, 0) * ANGLES(RAD(50), RAD(-10), RAD(45))*CF(0,-0.25,0) * LEFTSHOULDERC0, 1.25 / ANIM_SPEED)
			RIGHTHIP.C0 = Clerp(RIGHTHIP.C0, CF(1, -0.25, -1) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 1.25 / ANIM_SPEED)
			LEFTHIP.C0 = Clerp(LEFTHIP.C0, CF(-1, -0.25, -1) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-10)), 1.25 / ANIM_SPEED)
		end
	end
end
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
end)

HatScripts:Button("Arsenal Delinquent", "funny button go brr", function()
    if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		local script = game:GetObjects("rbxassetid://6726523130")[1]
local Player = game.Players.LocalPlayer
local Mouse,mouse,UserInputService,ContextActionService = game.Players.LocalPlayer:GetMouse(),game.Players.LocalPlayer:GetMouse(),game:GetService("UserInputService"),game:GetService("ContextActionService")
	
wait(0.2)
PlayerGui = Player.PlayerGui
Cam = workspace.CurrentCamera
Backpack = Player.Backpack
Character = Player.Character.Raw
Humanoid = Character.Humanoid
RootPart = Character.HumanoidRootPart
Torso = Character.Torso
Head = Character.Head
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart.RootJoint
Neck = Torso.Neck
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]
local MOUSEPOS = RootPart.Position
local TIME = 0
local sick = Instance.new("Sound",Torso)

IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
--//=================================\\
--|| 	      USEFUL VALUES
--\\=================================//

Animation_Speed = 3
Frame_Speed = 0.016666666666666666
local FORCERESET = false
Frame_Speed = 1 / 80 -- (1 / 60) OR (1 / 80)
local Speed = 25
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local DAMAGEMULTIPLIER = 1
local ANIM = "Idle"
local ATTACK = false
local BMUSIC = IT("Sound", RootPart)
local VOLUME = 2
local PITCH = 1
local SONGID = 1305709235  --1347700465
local EQUIPPED = false
local HOLD = false
local COMBO = 1
local Type = "Ban"
local reason = "Ur damn skids nigga"
local Rooted = false
local SINE = 0
local SIZE = 1
local KEYHOLD = false
local CHANGE = 2 / Animation_Speed
local WALKINGANIM = false
local VALUE1 = false
local VALUE2 = false
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
--ROBLOXIDLEANIMATION.Parent = Humanoid
local WEAPONGUI = IT("ScreenGui", PlayerGui)
WEAPONGUI.Name = "BanishV3Gui"
local Characterb = IT("Model")
Characterb.Name = "shackisgaylol"
local CharacterA = IT("Model")
CharacterA.Name = "shackismegagaylol"
local Effects = IT("Folder", CharacterA)
Effects.Name = "Effects"
local Effects2 = IT("Folder", Characterb)
Effects.Name = "Effects"
local ANIMATOR = Humanoid.Animator
local ANIMATE = Character:FindFirstChild("Animate")
local UNANCHOR = true
local TOBANISH = {}
script.Parent = PlayerGui

--//=================================\\
--\\=================================//


--//=================================\\
--|| SAZERENOS' ARTIFICIAL HEARTBEAT
--\\=================================//



frame = Frame_Speed
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()


game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then

			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
			end
		lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

--//=================================\\
--\\=================================//

--//=================================\\
--|| 	      SOME FUNCTIONS
--\\=================================//

local BODY = {}
for _, c in pairs(Character:GetDescendants()) do
	if c:IsA("BasePart") and c.Name ~= "Handle" then
		if c ~= RootPart and c ~= Torso and c ~= Head and c ~= RightArm and c ~= LeftArm and c ~= RightLeg and c ~= LeftLeg then
			c.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
		end
		table.insert(BODY,{c,c.Parent,c.Material,c.Color,c.Transparency})
	elseif c:IsA("JointInstance") then
		table.insert(BODY,{c,c.Parent,nil,nil,nil})
	end
end
for e = 1, #BODY do
	if BODY[e] ~= nil then
		local STUFF = BODY[e]
		local PART = STUFF[1]
		local PARENT = STUFF[2]
		local MATERIAL = STUFF[3]
		local COLOR = STUFF[4]
		local TRANSPARENCY = STUFF[5]
		if PART.ClassName == "Part" and PART ~= RootPart then
			PART.Material = MATERIAL
			PART.Color = COLOR
			PART.Transparency = TRANSPARENCY
		end
		PART.AncestryChanged:Connect(function()
			PART.Parent = PARENT
		end)
	end
end

function refit()
	Character.Parent = workspace
	for e = 1, #BODY do
		if BODY[e] ~= nil then
			local STUFF = BODY[e]
			local PART = STUFF[1]
			local PARENT = STUFF[2]
			local MATERIAL = STUFF[3]
			local COLOR = STUFF[4]
			local TRANSPARENCY = STUFF[5]
			if PART:IsA("BasePart") and PART ~= RootPart then
				PART.Material = MATERIAL
				PART.Color = COLOR
				PART.Transparency = TRANSPARENCY+EXTRATRANS
			end
			if PART.Parent ~= PARENT then
				Humanoid:remove()
				PART.Parent = PARENT
				Humanoid = IT("Humanoid",Character)
			end
		end
	end
end

function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function PositiveAngle(NUMBER)
	if NUMBER >= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function NegativeAngle(NUMBER)
	if NUMBER <= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function Swait(NUMBER)
    game:GetService("RunService").RenderStepped:Wait()
end

function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
	local NEWMESH = IT(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or VT(0, 0, 0)
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end

function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end

	local function weldBetween(a, b)
	    local weldd = Instance.new("ManualWeld")
	    weldd.Part0 = a
	    weldd.Part1 = b
	    weldd.C0 = CFrame.new()
	    weldd.C1 = b.CFrame:inverse() * a.CFrame
	    weldd.Parent = a
	    return weldd
	end


function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
 
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp;
	if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > 0.0001 then
			local theta = ACOS(-cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((t - 1) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end

function Clerp(a, b, t)
	local qa = {QuaternionFromCFrame(a)}
	local qb = {QuaternionFromCFrame(b)}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end

function CreateFrame(PARENT, TRANSPARENCY, BORDERSIZEPIXEL, POSITION, SIZE, COLOR, BORDERCOLOR, NAME)
	local frame = IT("Frame")
	frame.BackgroundTransparency = TRANSPARENCY
	frame.BorderSizePixel = BORDERSIZEPIXEL
	frame.Position = POSITION
	frame.Size = SIZE
	frame.BackgroundColor3 = COLOR
	frame.BorderColor3 = BORDERCOLOR
	frame.Name = NAME
	frame.Parent = PARENT
	return frame
end

function CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)
	local label = IT("TextLabel")
	label.BackgroundTransparency = 1
	label.Size = UD2(1, 0, 1, 0)
	label.Position = UD2(0, 0, 0, 0)
	label.TextColor3 = TEXTCOLOR
	label.TextStrokeTransparency = STROKETRANSPARENCY
	label.TextTransparency = TRANSPARENCY
	label.FontSize = TEXTFONTSIZE
	label.Font = TEXTFONT
	label.BorderSizePixel = BORDERSIZEPIXEL
	label.TextScaled = false
	label.Text = TEXT
	label.Name = NAME
	label.Parent = PARENT
	return label
end


function NoOutlines(PART)
	PART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10
end

function CreateWeld(parent,part0,part1,C1X,C1Y,C1Z,C1Xa,C1Ya,C1Za,C0X,C0Y,C0Z,C0Xa,C0Ya,C0Za)
local weld = Instance.new("Weld")
weld.Parent = parent
weld.Part0 = part0
weld.Part1 = part1
weld.C1 = CFrame.new(C1X,C1Y,C1Z)*CFrame.Angles(C1Xa,C1Ya,C1Za)
weld.C0 = CFrame.new(C0X,C0Y,C0Z)*CFrame.Angles(C0Xa,C0Ya,C0Za)
return weld
end

--NewSound({ID = 0,PARENT = ROOT,VOLUME = 0.5,PITCH = 1,LOOP = false,MAXDISTANCE = 1000,EMITTERSIZE = 10,PLAYING = true,PLAYONREMOVE = false,DOESDEBRIS = true})
function NewSound(TABLE)
	local ID = "rbxassetid://"..(TABLE.ID or 0)
	local PARENT = (TABLE.PARENT or RootPart)
	local VOLUME = (TABLE.VOLUME or 0.5)
	local PITCH = (TABLE.PITCH or 1)
	local LOOP = (TABLE.LOOP or false)
	local MAXDISTANCE = (TABLE.MAXDISTANCE or 100)
	local EMITTERSIZE = (TABLE.EMITTERSIZE or 10)
	local PLAYING = (TABLE.PLAYING or true)
	local PLAYONREMOVE = (TABLE.PLAYONREMOVE or false)
	local DOESDEBRIS = (TABLE.DOESDEBRIS or true)
	if ID ~= "rbxassetid://0" then
		local SOUND = IT("Sound",PARENT)
		SOUND.SoundId = ID
		SOUND.Volume = VOLUME
		SOUND.Pitch = PITCH
		SOUND.Looped = LOOP
		SOUND.MaxDistance = MAXDISTANCE
		SOUND.EmitterSize = EMITTERSIZE
		SOUND.PlayOnRemove = PLAYONREMOVE
		if DOESDEBRIS == true and PLAYING == true and LOOP == false then
			Debris:AddItem(SOUND,SOUND.TimeLength+5)
		end
		if PLAYING == true then
			SOUND:Play()
		end
		return SOUND
	end
end

function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
	local NEWWELD = IT(TYPE)
	NEWWELD.Part0 = PART0
	NEWWELD.Part1 = PART1
	NEWWELD.C0 = C0
	NEWWELD.C1 = C1
	NEWWELD.Parent = PARENT
	return NEWWELD
end

local S = IT("Sound")
function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
	local NEWSOUND = nil
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			repeat wait(1) until NEWSOUND.Playing == false or NEWSOUND.Parent ~= PARENT
			NEWSOUND:remove()
		end
	end))
	return NEWSOUND
end

function CFrameFromTopBack(at, top, back)
	local right = top:Cross(back)
	return CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
end

--WACKYEFFECT({EffectType = "", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
function WACKYEFFECT(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" then
			MSH = IT("BlockMesh",EFFECT)
			MSH.Scale = VT(SIZE.X,SIZE.X,SIZE.X)
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
			end
			local GROWTH = SIZE - ENDSIZE
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			for LOOP = 1, TIME+1 do
				Swait()
				MSH.Scale = MSH.Scale - GROWTH/TIME
				if TYPE == "Wave" then
					MSH.Offset = VT(0,0,-MSH.Scale.X/8)
				end
				EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
				else
					EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
				end
				if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation
					EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
					EFFECT.Orientation = ORI
				end
			end
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				SOUND.Stopped:Connect(function()
					EFFECT:remove()
				end)
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until SOUND.Playing == false
				EFFECT:remove()
			end
		end
	end))
end

function MakeForm(PART,TYPE)
	if TYPE == "Cyl" then
		local MSH = IT("CylinderMesh",PART)
	elseif TYPE == "Ball" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Sphere"
	elseif TYPE == "Wedge" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Wedge"
	end
end

function SpawnTrail(FROM,TO,BIG)
	local TRAIL = CreatePart(3, Effects, "Neon", 0, 0.5, "New Yeller", "Trail", VT(0,0,0))
	MakeForm(TRAIL,"Cyl")
	local DIST = (FROM - TO).Magnitude
	if BIG == true then
		TRAIL.Size = VT(0.5,DIST,0.5)
	else
		TRAIL.Size = VT(0.25,DIST,0.25)
	end
	TRAIL.CFrame = CF(FROM, TO) * CF(0, 0, -DIST/2) * ANGLES(RAD(90),RAD(0),RAD(0))
	coroutine.resume(coroutine.create(function()
		for i = 1, 5 do
			Swait()
			TRAIL.Transparency = TRAIL.Transparency + 0.1
		end
		TRAIL:remove()
	end))
end

function MagicSphere(SIZE,WAIT,CFRAME,COLOR,GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0, BRICKC(COLOR), "Effect", VT(1,1,1), true)
	local mesh = IT("SpecialMesh",wave)
	mesh.MeshType = "Sphere"
	mesh.Scale = SIZE
	mesh.Offset = VT(0,0,0)
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			wave.Transparency = wave.Transparency + (1/WAIT)
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

function MagicSphereCo(SIZE,WAIT,CFRAME,COLOR,GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0, BRICKC(COLOR), "Effect", VT(1,1,1), true)
	local mesh = IT("SpecialMesh",wave)
	mesh.MeshType = "Sphere"
	mesh.Scale = SIZE
	mesh.Offset = VT(0,0,0)
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			wave.Transparency = wave.Transparency + (1/WAIT)
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

function MagicBlock(SIZE,WAIT,CFRAME,COLOR,GROW)
	local wave = CreatePart(3, Effects, "ForceField", 0, 0.5, BRICKC(COLOR), "Effect", VT(SIZE,SIZE,SIZE), true)
	local mesh = IT("BlockMesh",wave)
	wave.CFrame = CFRAME * ANGLES(RAD(math.random(-360,360)),RAD(math.random(-360,360)),RAD(math.random(-360,360)))
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			wave.CFrame = CFRAME * ANGLES(RAD(math.random(-360,360)),RAD(math.random(-360,360)),RAD(math.random(-360,360)))
			wave.Transparency = wave.Transparency + (0.5/WAIT)
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

function CreateRing(SIZE, DOESROT, ROT, WAIT, CFRAME, COLOR, GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0.5, BRICKC(COLOR), "Effect", VT(0, 0, 0))
	local mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "559831844", "", SIZE, VT(0, 0, 0))
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			if DOESROT == true then
				wave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(0, ROT, 0)
			end
			wave.Transparency = wave.Transparency + 0.5 / WAIT
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

local DECAL = IT("Decal")
function MagicRing()
	local RING = CreatePart(3, Effects, "Granite", 0, 1, "Maroon", "MagicRing", VT(0,0,0),true)
	local MESH = IT("BlockMesh",RING)
	local BOTTOMTEXTURE = DECAL:Clone()
	BOTTOMTEXTURE.Parent = RING
	BOTTOMTEXTURE.Face = "Bottom"
	BOTTOMTEXTURE.Name = "BottomTexture"
	local TOPTEXTURE = DECAL:Clone()
	TOPTEXTURE.Parent = RING
	TOPTEXTURE.Face = "Top"
	TOPTEXTURE.Name = "TopTexture"
	BOTTOMTEXTURE.Texture = "http://www.roblox.com/asset/?id=1208118228"
	TOPTEXTURE.Texture = "http://www.roblox.com/asset/?id=1208118228"
	BOTTOMTEXTURE.Color3 = C3(0,0,0)
	TOPTEXTURE.Color3 = C3(1,1,1)
	return RING,MESH,TOPTEXTURE,BOTTOMTEXTURE
end

Debris = game:GetService("Debris")

function CastProperRay(StartPos, EndPos, Distance, Ignore)
	local DIRECTION = CF(StartPos,EndPos).lookVector
	return Raycast(StartPos, DIRECTION, Distance, Ignore)
end

function turnto(position)
	RootPart.CFrame=CFrame.new(RootPart.CFrame.p,VT(position.X,RootPart.Position.Y,position.Z)) * CFrame.new(0, 0, 0)
end

function SHAKECAM(POSITION, RANGE, INTENSITY, TIME)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO and RANGE >= (TORSO.Position - POSITION).Magnitude then
					local CAMSHAKER = script.CamShake:Clone()
					CAMSHAKER.Shake.Value = INTENSITY
					CAMSHAKER.Timer.Value = TIME
					CAMSHAKER.Parent = CHILD
					CAMSHAKER.Disabled = false
				end
			end
		end
	end
end

--//=================================\\
--||	     WEAPON CREATION
--\\=================================//

--usedmostly on shackluster edits and shit
---------------------------------Weapon/armor creation------------------------

function WWeld(a, b, acf)
    local we = Instance.new("Weld", a)
    we.Part0 = a
    we.Part1 = b
if acf ~= nil then
    we.C0 = acf
end
end

for i = 1,10 do
wait()
end

TORSO = script.Torso

TORSO.Parent = Character

WWeld(TORSO.Torso,Torso, CF(0, 0, 0)*ANGLES(RAD(176),RAD(359),RAD(180)), CF(0, 0, 0))



-------------------------------------------------------------------------------------------
--- outfit




local Tec9 = script.Tec9:Clone()
Tec9.Parent = RightArm
for i, v in pairs(Tec9:GetChildren()) do
    v.Transparency = 1
end
CreateWeld(Tec9.Handle,RightArm,Tec9.Handle,-0.3,-0.2,-0.9,math.rad(90),math.rad(0),math.rad(180),0,0,0,math.rad(0),math.rad(0),math.rad(0))
local Hole = Tec9.Hole


game.Players.LocalPlayer.Character["VN9K [Front]"].Handle:BreakJoints()
local function align(part0, part1)
    attachment = Instance.new("Attachment", part0)
    attachment.Position = Vector3.new(1, -0.5, -0.3) -- positioning
    attachment.Orientation = Vector3.new(90, 90, 0) -- orienation/rotation
    
    attachment02 = Instance.new("Attachment", part1) -- arm or part
    
    lol = Instance.new("AlignPosition", part0)
    lol.Attachment0 = attachment
    lol.Attachment1 = attachment02
    lol.MaxForce = math.huge
    lol.RigidityEnabled = true -- makes it not wobbly
    
    pog = Instance.new("AlignOrientation", part0)
    pog.Attachment0 = attachment
    pog.Attachment1 = attachment02
    pog.Responsiveness = 20
    pog.RigidityEnabled = true-- makes it not wobbly
end
align(game.Players.LocalPlayer.Character["VN9K [Front]"].Handle, game.Players.LocalPlayer.Character["Right Arm"])


local Particle = IT("ParticleEmitter",nil)
Particle.Enabled = false
Particle.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,0.3),NumberSequenceKeypoint.new(0.3,0),NumberSequenceKeypoint.new(1,1)})
Particle.LightEmission = 0.5
Particle.Rate = 150
Particle.ZOffset = 0.2
Particle.Rotation = NumberRange.new(-180, 180)
Particle.RotSpeed = NumberRange.new(-180, 180)
Particle.Texture = "http://www.roblox.com/asset/?id=304437537"
Particle.Color = ColorSequence.new(C3(1,1,1),C3(0,0,0))

--ParticleEmitter({Speed = 5, Drag = 0, Size1 = 1, Size2 = 5, Lifetime1 = 1, Lifetime2 = 1.5, Parent = Torso, Emit = 100, Offset = 360, Enabled = false})
function ParticleEmitter(Table)
	local PRTCL = Particle:Clone()
	local Speed = Table.Speed or 5
	local Drag = Table.Drag or 0
	local Size1 = Table.Size1 or 1
	local Size2 = Table.Size2 or 5
	local Lifetime1 = Table.Lifetime1 or 1
	local Lifetime2 = Table.Lifetime2 or 1.5
	local Parent = Table.Parent or Torso
	local Emit = Table.Emit or 100
	local Offset = Table.Offset or 360
	local Acel = Table.Acel or VT(0,0,0)
	local Enabled = Table.Enabled or false
	PRTCL.Parent = Parent
	PRTCL.Size = NumberSequence.new(Size1,Size2)
	PRTCL.Lifetime = NumberRange.new(Lifetime1,Lifetime2)
	PRTCL.Speed = NumberRange.new(Speed)
	PRTCL.VelocitySpread = Offset
	PRTCL.Drag = Drag
	PRTCL.Acceleration = Acel
	if Enabled == false then
		PRTCL:Emit(Emit)
		Debris:AddItem(PRTCL,Lifetime2)
	else
		PRTCL.Enabled = true
	end
	return PRTCL
end

--ParticleEmitter({Speed = 5, Drag = 0, Size1 = 1, Size2 = 5, Lifetime1 = 1, Lifetime2 = 1.5, Parent = Torso, Emit = 100, Offset = 360, Enabled = false})

for _, c in pairs(CharacterA:GetChildren()) do
	if c.ClassName == "Part" then
		c.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
	end
end

CharacterA.Parent = Character

Characterb.Parent = Character


local SKILLTEXTCOLOR = C3(1,1,1)
local SKILLFONT = ""
local SKILLTEXTSIZE = 7

local BODY = {}
for _, c in pairs(Character:GetDescendants()) do
	if c:IsA("BasePart") and c.Name ~= "Handle" then
		if c ~= RootPart and c ~= Torso and c ~= Head and c ~= RightArm and c ~= LeftArm and c ~= RightLeg and c ~= LeftLeg then
			c.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
		end
		table.insert(BODY, {
			c,
			c.Parent,
			c.Material,
			c.Color,
			c.Transparency,
			c.Size,
			c.Name
		})
	elseif c:IsA("JointInstance") or c:IsA("Shirt") or c:IsA("Pants") then
		table.insert(BODY, {
			c,
			c.Parent,
			nil,
			nil,
			nil,
			nil,
			nil
		})
	end
end
function refit()
	Character.Parent = workspace
	Effects.Parent = Character
	for e = 1, #BODY do
		if BODY[e] ~= nil then
			local STUFF = BODY[e]
			local PART = STUFF[1]
			local PARENT = STUFF[2]
			local MATERIAL = STUFF[3]
			local COLOR = STUFF[4]
			local TRANSPARENCY = STUFF[5]
			local NAME = STUFF[7]
			if PART.ClassName == "Part" and PART ~= RootPart then
				PART.Material = MATERIAL
				PART.Transparency = TRANSPARENCY
				PART.Name = NAME
			end
			if PART.Parent ~= PARENT then
				if PART.Name == "Head" or PART.Name == "Neck" or PART.Name == "Torso" then
					Humanoid:remove()
				end
				PART.Parent = PARENT
				if PART.Name == "Head" or PART.Name == "Neck" or PART.Name == "Torso" then
					Humanoid = IT("Humanoid", Character)
				end
			end
		end
	end
end
Humanoid.Died:connect(function()
	refit()
end)

--[[local SKILL1FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.1, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 1 Frame")
local SKILL2FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.63, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 2 Frame")
local SKILL3FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.215, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 3 Frame")
local SKILL4FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.525, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 4 Frame")
local SKILL5FRAME = CreateFrame(WEAPONGUI, 1, 2, UD2(0.365, 0, 0.90, 0), UD2(0.26, 0, 0.07, 0), C3(0,0,0), C3(0, 0, 0), "Skill 5 Frame")
]]
--[[local SKILL1TEXT = CreateLabel(SKILL1FRAME, "[Z] Banish Bullet", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 1")
local SKILL2TEXT = CreateLabel(SKILL2FRAME, "[B] Ability 2", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 2")
local SKILL3TEXT = CreateLabel(SKILL3FRAME, "[C] Ability 3", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 3")
local SKILL4TEXT = CreateLabel(SKILL4FRAME, "[V] Ability 4", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 4")
local SKILL5TEXT = CreateLabel(SKILL5FRAME, "[X] Mercy", SKILLTEXTCOLOR, SKILLTEXTSIZE, SKILLFONT, 0, 2, 0.7, "Text 5")
]]

function chatfunc(text)
	local chat = coroutine.wrap(function()
	if Character:FindFirstChild("TalkingBillBoard")~= nil then
		Character:FindFirstChild("TalkingBillBoard"):destroy()
	end
	local Bill = Instance.new("BillboardGui",Character)
	Bill.Size = UDim2.new(0,100,0,40)
	Bill.StudsOffset = Vector3.new(0,3,0)
	Bill.Adornee = Character.Head
	Bill.Name = "TalkingBillBoard"
	local Hehe = Instance.new("TextLabel",Bill)
	Hehe.BackgroundTransparency = 1
	Hehe.BorderSizePixel = 0
	Hehe.Text = ""
	Hehe.Font = "SourceSansItalic"
	Hehe.TextSize = 40
	Hehe.TextStrokeTransparency = 0
	Hehe.Size = UDim2.new(1,0,0.5,0)
	coroutine.resume(coroutine.create(function()
		while Hehe ~= nil do
			Swait()	
			Hehe.Position = UDim2.new(math.random(-.4,.4),math.random(-5,5),.05,math.random(-5,5))	
			Hehe.Rotation = math.random(-5,5)
			Hehe.TextColor3 = Color3.new(0,0,0)
			Hehe.TextStrokeColor3 = Color3.new(1,1,1)
		end
	end))
	for i = 1,string.len(text),1 do
		Swait()
		Hehe.Text = string.sub(text,1,i)
	end
	Swait(90)--Re[math.random(1, 93)]
	for i = 0, 1, .025 do
		Swait()
		Bill.ExtentsOffset = Vector3.new(math.random(-i, i), math.random(-i, i), math.random(-i, i))
		Hehe.TextStrokeTransparency = i
		Hehe.TextTransparency = i
	end
	Bill:Destroy()
	end)
chat()
end

function onChatted(msg)
	chatfunc(msg)
end

Player.Chatted:connect(onChatted)

function printbye(Name)
	local MESSAGES = {"You cannot struggle, ","Your existance is an insult, ","Fade, ","Your existance is not desired, ","You are not permitted here, ","You are not to decide your fate, ","Be gone, ","You are already dead, ","Your live is an anomaly, ","Don't dare to return, ","Why are you resisting, ","You cannot exist here, ","Why are you struggling, ","Your fate was already decided, ","Goodbye, ","You cannot ignore my command, ","You cannot resist my command, ","You already died, "}
	chatfunc(MESSAGES[MRANDOM(1,#MESSAGES)]..Name..".")	
end

workspace.ChildAdded:connect(function(instance)
    for BANISH = 1, #TOBANISH do
		if TOBANISH[BANISH] ~= nil then
			if instance.Name == TOBANISH[BANISH] then
				coroutine.resume(coroutine.create(function()
					printbye(instance.Name)
					instance:ClearAllChildren()
					Debris:AddItem(instance,0.0005)
				end))
			end
		end
	end
end)

--//=================================\\
--||			DAMAGING
--\\=================================//

function Banish(Foe)
	if Foe then
		coroutine.resume(coroutine.create(function()
			--if game.Players:FindFirstChild(Foe.Name) then
				table.insert(TOBANISH,Foe.Name)
				printbye(Foe.Name)
			--end
			Foe.Archivable = true
			local CLONE = Foe:Clone()
			Foe:Destroy()
			CLONE.Parent = Effects
			CLONE:BreakJoints()
			local MATERIALS = {"Glass","Neon"}
			for _, c in pairs(CLONE:GetDescendants()) do
				if c:IsA("BasePart") then
					if c.Name == "Torso" or c.Name == "UpperTorso" or c == CLONE.PrimaryPart then
 						CreateSound(340722848, c, 10, 1, false)
					end
					c.Anchored = true
					c.Transparency = c.Transparency + 0.2
					c.Material = MATERIALS[MRANDOM(1,2)]
					c.Color = C3(1,1,1)
					if c.ClassName == "MeshPart" then
						c.TextureID = ""
					end
					if c:FindFirstChildOfClass("SpecialMesh") then
						c:FindFirstChildOfClass("SpecialMesh").TextureId = ""
					end
					if c:FindFirstChildOfClass("Decal") then
						c:FindFirstChildOfClass("Decal"):remove()
					end
					c.Name = "Banished"
					c.CanCollide = false
				else
					c:remove()
				end
			end
			local A = false
			for i = 1, 35 do
				if A == false then
					A = true
				elseif A == true then
					A = false
				end
				for _, c in pairs(CLONE:GetDescendants()) do
					if c:IsA("BasePart") then
						c.Anchored = true
						c.Material = MATERIALS[MRANDOM(1,2)]
						c.Transparency = c.Transparency + 0.8/35
						if A == false then
							c.CFrame = c.CFrame*CF(MRANDOM(-45,45)/45,MRANDOM(-45,45)/45,MRANDOM(-45,45)/45)
						elseif A == true then
							c.CFrame = c.CFrame*CF(MRANDOM(-45,45)/45,MRANDOM(-45,45)/45,MRANDOM(-45,45)/45)						
						end
					end
				end
				Swait()
			end
			CLONE:remove()
		end))
	end
end

function ApplyAoE(POSITION,RANGE,ISBANISH)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if ISBANISH == true then
							Banish(CHILD)
						else
							if ISBANISH == "Gravity" then
								HUM.PlatformStand = true
								if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
									local grav = Instance.new("BodyPosition",TORSO)
									grav.D = 15
									grav.P = 20000
									grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
									grav.position = TORSO.Position
									grav.Name = "V3BanishForce"..Player.Name
								else
									TORSO:FindFirstChild("V3BanishForce"..Player.Name).position = TORSO.Position+VT(0,0.3,0)
									TORSO.RotVelocity = VT(MRANDOM(-25,25),MRANDOM(-25,25),MRANDOM(-25,25))
								end
							else
								HUM.PlatformStand = false
							end
						end
					elseif ISBANISH == "Gravity" then
						if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
							TORSO:FindFirstChild("V3BanishForce"..Player.Name):remove()
							HUM.PlatformStand = false
						end
					end
				end
			end
		end
	end
end


function ManualDamage(Humanoid,Damage,TorsoPart)
	local defence = Instance.new("BoolValue",Humanoid.Parent)
	defence.Name = ("HitBy"..Player.Name)
	game:GetService("Debris"):AddItem(defence, 0.001)
	Damage = Damage * DAMAGEMULTIPLIER
	if Humanoid.Health ~= 0 then
		local CritChance = MRANDOM(1,100)
		if Damage > Humanoid.Health then
			Damage = math.ceil(Humanoid.Health)
			if Damage == 0 then
				Damage = 0.1
			end
		end
		Humanoid.Health = Humanoid.Health - Damage
	end
end

local asd = Instance.new("ParticleEmitter")
asd.Color = ColorSequence.new(Color3.new(0.5, 0, 0), Color3.new(.3, 0, 0))
asd.LightEmission = .1
asd.Texture = "http://www.roblox.com/asset/?ID=291880914"
aaa = NumberSequence.new({NumberSequenceKeypoint.new(0, 0.6),NumberSequenceKeypoint.new(1, 2)})
bbb = NumberSequence.new({NumberSequenceKeypoint.new(0, 1),NumberSequenceKeypoint.new(0.0636, 0), NumberSequenceKeypoint.new(1, 1)})
asd.Transparency = bbb
asd.Size = aaa
asd.ZOffset = .9
asd.Acceleration = Vector3.new(0, -15, 0)
asd.LockedToPart = false
asd.EmissionDirection = "Back"
asd.Lifetime = NumberRange.new(1, 2)
asd.Rotation = NumberRange.new(-100, 100)
asd.RotSpeed = NumberRange.new(-100, 100)
asd.Speed = NumberRange.new(10)
asd.Enabled = false
asd.VelocitySpread = 999

function getbloody(victim,amount)
	local PART = CreatePart(3, Effects, "Metal", 0, 1, "Mid gray", "Blood", victim.Size)
	PART.CFrame = victim.CFrame
	local HITPLAYERSOUNDS = {"356551938","264486467"}
	Debris:AddItem(PART,5)
	CreateSound(HITPLAYERSOUNDS[MRANDOM(1, #HITPLAYERSOUNDS)], PART, 1, (math.random(8,12)/10))
	CreateSound(HITPLAYERSOUNDS[MRANDOM(1, #HITPLAYERSOUNDS)], PART, 1, (math.random(8,12)/10))
	CreateSound(HITPLAYERSOUNDS[MRANDOM(1, #HITPLAYERSOUNDS)], PART, 1, (math.random(8,12)/10))
	local prtcl = asd:Clone()
	prtcl.Parent = PART
	prtcl:Emit(amount*10)
end

function ManualAoE(POSITION,RANGE,MINDMG,MAXDMG,FLING,INSTAKILL)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character and CHILD.Parent ~= Effects then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if INSTAKILL == true then
							CHILD:BreakJoints()
						else
							local DMG = MRANDOM(MINDMG,MAXDMG)
							ManualDamage(HUM,DMG,TORSO)
						end
						if FLING > 0 then
							for _, c in pairs(CHILD:GetChildren()) do
								if c:IsA("BasePart") then
									local bv = Instance.new("BodyVelocity") 
									bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
									bv.velocity = CF(POSITION,TORSO.Position).lookVector*FLING
									bv.Parent = c
									Debris:AddItem(bv,0.05)
								end
							end
						end
					end
				end
			end
		end
	end
end

function Dismember(MAN,DOWHAT)
	for index, CHILD in pairs(MAN:GetDescendants()) do
		if CHILD:IsA("Script") or CHILD:IsA("LocalScript") then
			CHILD:Destroy()
		end
	end
	if DOWHAT == "Ragdoll" then
		local HUM = MAN:FindFirstChildOfClass("Humanoid")
		if HUM then
			HUM.Health = 0
		end
		if MAN:FindFirstChild("UpperTorso") then
			local SCRIPT = script.R15Ragdoll:Clone()
			SCRIPT.Parent = MAN
			SCRIPT.Disabled = false
		else
			local SCRIPT = script.R6Ragdoll:Clone()
			SCRIPT.Parent = MAN
			SCRIPT.Disabled = false
		end
		MAN:BreakJoints()
	else
		local TORSO = MAN:FindFirstChild("Torso") or MAN:FindFirstChild("UpperTorso")
		local HED = MAN:FindFirstChild("Head")
		if TORSO and HED then
			if DOWHAT == "Head" then
				if TORSO:FindFirstChild("TorsoA4") then
					TORSO:FindFirstChild("TorsoA4"):Remove()
				elseif MAN:FindFirstChild("RagdollConstraintHead") then
					MAN:FindFirstChild("RagdollConstraintHead"):Remove()
				end
				HED:BreakJoints()
			elseif DOWHAT == "RightArm" then
				if TORSO:FindFirstChild("TorsoA3") then
					TORSO:FindFirstChild("TorsoA3"):Remove()
				elseif MAN:FindFirstChild("RagdollConstraintRightUpperArm") then
					MAN:FindFirstChild("RagdollConstraintRightUpperArm"):Remove()
				end
			elseif DOWHAT == "LeftArm" then
				if TORSO:FindFirstChild("TorsoA2") then
					TORSO:FindFirstChild("TorsoA2")
				elseif MAN:FindFirstChild("RagdollConstraintLeftUpperArm") then
					MAN:FindFirstChild("RagdollConstraintLeftUpperArm"):Remove()
				end
			elseif DOWHAT == "Legs" then
				if TORSO.Name == "Torso" then
					if TORSO:FindFirstChild("TorsoA") then
						TORSO:FindFirstChild("TorsoA"):Remove()
					end
					if TORSO:FindFirstChild("TorsoA1") then
						TORSO:FindFirstChild("TorsoA1"):Remove()
					end
				elseif MAN:FindFirstChild("RagdollConstraintUpperTorso") then
					MAN:FindFirstChild("RagdollConstraintUpperTorso"):Remove()
				end
			end
		end
	end
end

function AttachmentCFrame(A)
	return A.Parent.CFrame*CF(A.Position)
end

function R15Ragdoll(character,KeepArms)
	character:BreakJoints()
	coroutine.resume(coroutine.create(function()
		recurse(character, function(_,v)
			if v:IsA("Attachment") then
				v.Axis = Vector3.new(0, 1, 0)
				v.SecondaryAxis = Vector3.new(0, 0, 1)
				v.Rotation = Vector3.new(0, 0, 0)
			end
		end)
		for _,child in next,character:GetChildren() do
			if child:IsA("Accoutrement") then
				for _,part in next,child:GetChildren() do
					if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
						local attachment1 = part:FindFirstChildOfClass("Attachment")
						local attachment0 = getAttachment0(character,attachment1.Name)
						if attachment0 and attachment1 then
							local constraint = Instance.new("HingeConstraint")
							constraint.Attachment0 = attachment0
							constraint.Attachment1 = attachment1
							constraint.LimitsEnabled = true
							constraint.UpperAngle = 0
							constraint.LowerAngle = 0
							constraint.Parent = character
						end
						ArtificialHitbox(part)
					elseif part.Name == "HumanoidRootPart" then
						part:remove()
					end
				end
			end
		end
		
		ragdollJoint(character,character.LowerTorso, character.UpperTorso, "Waist", "BallSocket", {
			{"LimitsEnabled",true};
			{"UpperAngle",5};
		})
		if character:FindFirstChild("Head") then
			ragdollJoint(character,character.UpperTorso, character.Head, "Neck", "BallSocket", {
				{"LimitsEnabled",true};
				{"UpperAngle",15};
			})
		end
		
		local handProperties = {
			{"LimitsEnabled", true};
			{"UpperAngle",0};
			{"LowerAngle",0};
		}
		ragdollJoint(character,character.LeftLowerArm, character.LeftHand, "LeftWrist", "Hinge", handProperties)
		ragdollJoint(character,character.RightLowerArm, character.RightHand, "RightWrist", "Hinge", handProperties)
		
		local shinProperties = {
			{"LimitsEnabled", true};
			{"UpperAngle", 0};
			{"LowerAngle", -75};
		}
		ragdollJoint(character,character.LeftUpperLeg, character.LeftLowerLeg, "LeftKnee", "Hinge", shinProperties)
		ragdollJoint(character,character.RightUpperLeg, character.RightLowerLeg, "RightKnee", "Hinge", shinProperties)
		
		local footProperties = {
			{"LimitsEnabled", true};
			{"UpperAngle", 15};
			{"LowerAngle", -45};
		}
		ragdollJoint(character,character.LeftLowerLeg, character.LeftFoot, "LeftAnkle", "Hinge", footProperties)
		ragdollJoint(character,character.RightLowerLeg, character.RightFoot, "RightAnkle", "Hinge", footProperties)
		if KeepArms == true then
			ragdollJoint(character,character.UpperTorso, character.RightUpperArm, "RightShoulder", "BallSocket")
			ragdollJoint(character,character.RightUpperArm, character.RightLowerArm, "RightElbow", "BallSocket")
			ragdollJoint(character,character.UpperTorso, character.LeftUpperArm, "LeftShoulder", "BallSocket")
			ragdollJoint(character,character.LeftUpperArm, character.LeftLowerArm, "LeftElbow", "BallSocket")
		end
		ragdollJoint(character,character.LowerTorso, character.LeftUpperLeg, "LeftHip", "BallSocket")
		ragdollJoint(character,character.LowerTorso, character.RightUpperLeg, "RightHip", "BallSocket")
		Debris:AddItem(character,5)
	end))
end

function Ragdoll(Character2,CharTorso,KeepArms)
	coroutine.resume(coroutine.create(function()
		Character2:BreakJoints()
		local hum = Character2:findFirstChild("Humanoid")
		hum:remove()
		local function Scan(ch)
			local e
			for e = 1,#ch do
				Scan(ch[e]:GetChildren())
				if ch[e].ClassName == "Weld" or ch[e].ClassName == "Motor6D" then
					ch[e]:remove()
				end
			end
		end
		local NEWHUM = IT("Humanoid")
		NEWHUM.Name = "Corpse"
		NEWHUM.Health = 0
		NEWHUM.MaxHealth = 0
		NEWHUM.PlatformStand = true
		NEWHUM.Parent = Character2
		NEWHUM.DisplayDistanceType = "None"
	
		local ch = Character2:GetChildren()
		local i
		for i = 1,#ch do
			if ch[i].Name == "THandle1" or ch[i].Name == "THandle2" then
				ch[i]:remove()
			end
		end
	
		local Torso2 = Character2.Torso
		local movevector = Vector3.new()
	
		if Torso2 then
			movevector = CFrame.new(CharTorso.Position,Torso2.Position).lookVector
			local Head = Character2:FindFirstChild("Head")
			if Head then
				local Neck = Instance.new("Weld")
				Neck.Name = "Neck"
				Neck.Part0 = Torso2
				Neck.Part1 = Head
				Neck.C0 = CFrame.new(0, 1.5, 0)
				Neck.C1 = CFrame.new()
				Neck.Parent = Torso2
	
			end
			local Limb = Character2:FindFirstChild("Right Arm")
			if Limb and KeepArms == true then
	
				Limb.CFrame = Torso2.CFrame * CFrame.new(1.5, 0, 0)
				local Joint = Instance.new("Glue")
				Joint.Name = "RightShoulder"
				Joint.Part0 = Torso2
				Joint.Part1 = Limb
				Joint.C0 = CFrame.new(1.5, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
				Joint.C1 = CFrame.new(-0, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
				Joint.Parent = Torso2
	
				local B = Instance.new("Part")
				B.TopSurface = 0
				B.BottomSurface = 0
				B.formFactor = "Symmetric"
				B.Size = Vector3.new(1, 1, 1)
				B.Transparency = 1
				B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
				B.Parent = Character2
				local W = Instance.new("Weld")
				W.Part0 = Limb
				W.Part1 = B
				W.C0 = CFrame.new(0, -0.5, 0)
				W.Parent = Limb
	
			end
			local Limb = Character2:FindFirstChild("Left Arm")
			if Limb and KeepArms == true then
	
				Limb.CFrame = Torso2.CFrame * CFrame.new(-1.5, 0, 0)
				local Joint = Instance.new("Glue")
				Joint.Name = "LeftShoulder"
				Joint.Part0 = Torso2
				Joint.Part1 = Limb
				Joint.C0 = CFrame.new(-1.5, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
				Joint.C1 = CFrame.new(0, 0.5, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
				Joint.Parent = Torso2
	
				local B = Instance.new("Part")
				B.TopSurface = 0
				B.BottomSurface = 0
				B.formFactor = "Symmetric"
				B.Size = Vector3.new(1, 1, 1)
				B.Transparency = 1
				B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
				B.Parent = Character2
				local W = Instance.new("Weld")
				W.Part0 = Limb
				W.Part1 = B
				W.C0 = CFrame.new(0, -0.5, 0)
				W.Parent = Limb
	
			end
			local Limb = Character2:FindFirstChild("Right Leg")
			if Limb then
	
				Limb.CFrame = Torso2.CFrame * CFrame.new(0.5, -2, 0)
				local Joint = Instance.new("Glue")
				Joint.Name = "RightHip"
				Joint.Part0 = Torso2
				Joint.Part1 = Limb
				Joint.C0 = CFrame.new(0.5, -1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
				Joint.C1 = CFrame.new(0, 1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
				Joint.Parent = Torso2
	
				local B = Instance.new("Part")
				B.TopSurface = 0
				B.BottomSurface = 0
				B.formFactor = "Symmetric"
				B.Size = Vector3.new(1, 1, 1)
				B.Transparency = 1
				B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
				B.Parent = Character2
				local W = Instance.new("Weld")
				W.Part0 = Limb
				W.Part1 = B
				W.C0 = CFrame.new(0, -0.5, 0)
				W.Parent = Limb
	
			end
			local Limb = Character2:FindFirstChild("Left Leg")
			if Limb then
	
				Limb.CFrame = Torso2.CFrame * CFrame.new(-0.5, -2, 0)
				local Joint = Instance.new("Glue")
				Joint.Name = "LeftHip"
				Joint.Part0 = Torso2
				Joint.Part1 = Limb
				Joint.C0 = CFrame.new(-0.5, -1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
				Joint.C1 = CFrame.new(-0, 1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
				Joint.Parent = Torso2
	
				local B = Instance.new("Part")
				B.TopSurface = 0
				B.BottomSurface = 0
				B.formFactor = "Symmetric"
				B.Size = Vector3.new(1, 1, 1)
				B.Transparency = 1
				B.CFrame = Limb.CFrame * CFrame.new(0, -0.5, 0)
				B.Parent = Character2
				local W = Instance.new("Weld")
				W.Part0 = Limb
				W.Part1 = B
				W.C0 = CFrame.new(0, -0.5, 0)
				W.Parent = Limb
	
			end
			--[
			local Bar = Instance.new("Part")
			Bar.TopSurface = 0
			Bar.BottomSurface = 0
			Bar.formFactor = "Symmetric"
			Bar.Size = Vector3.new(1, 1, 1)
			Bar.Transparency = 1
			Bar.CFrame = Torso2.CFrame * CFrame.new(0, 0.5, 0)
			Bar.Parent = Character2
			local Weld = Instance.new("Weld")
			Weld.Part0 = Torso2
			Weld.Part1 = Bar
			Weld.C0 = CFrame.new(0, 0.5, 0)
			Weld.Parent = Torso2
			--]]
		end
		Character2.Parent = workspace
		Debris:AddItem(Character2,5)
	
		return Character2,Torso2
	end))
end

function KickThatNigga(CHARACTER)
	g = game.Players:GetPlayers()
	local kickfolder = IT("Folder",Effects)
	local naeeym2 = Instance.new("BillboardGui",kickfolder)
	naeeym2.AlwaysOnTop = false
	naeeym2.Size = UDim2.new(5,35,2,35)
	naeeym2.StudsOffset = Vector3.new(0,1,0)
	naeeym2.Name = "Mark"
	local tecks2 = Instance.new("TextLabel",naeeym2)
	tecks2.BackgroundTransparency = 1
	tecks2.TextScaled = true
	tecks2.BorderSizePixel = 0
	tecks2.Text = ""
	tecks2.Font = "SciFi"
	tecks2.TextSize = 30
	tecks2.TextStrokeTransparency = 1
	tecks2.TextColor3 = Color3.new(1,0,0)
	tecks2.TextStrokeColor3 = Color3.new(1,0,0)
	tecks2.Size = UDim2.new(1,0,0.5,0)
	tecks2.Parent = naeeym2
	 CreateSound("527749592", CHARACTER, 600, 1, false)
	for i,v in ipairs(CHARACTER:GetChildren()) do
		if v.ClassName == "Part" or v.ClassName == "MeshPart" then
			if v.Name ~= "HumanoidRootPart" then
				local BOD = v:Clone()
				BOD.CanCollide = false
				BOD.Anchored = true
				BOD.CFrame = v.CFrame
				BOD.Parent = kickfolder
				BOD.Material = "Granite"
				BOD.Color = C3(.3,0,0)
				if BOD:FindFirstChildOfClass("Decal") then
					BOD:FindFirstChildOfClass("Decal"):remove()
				end
				if BOD.Name == "Head" then
					naeeym2.Adornee = BOD
				end
				if BOD.ClassName == "MeshPart" then
					BOD.TextureID = ""
				end
			end
		end
	end

	if CHARACTER ~= Character then
	CHARACTER:remove()
	end
	if CHARACTER.Name == "Helkern" then
		Character:BreakJoints()
	end
	coroutine.resume(coroutine.create(function()
		for i = 1, 50 do
			Swait()
			for i,v in ipairs(kickfolder:GetChildren()) do
				if v.ClassName == "Part" or v.ClassName == "MeshPart" then
					v.Transparency = 1
				end
				naeeym2.Enabled = false
			end
			Swait()
			for i,v in ipairs(kickfolder:GetChildren()) do
				if v.ClassName == "Part" or v.ClassName == "MeshPart" then
					v.Transparency = 0
				end
				naeeym2.Enabled = true
			end
		end
		kickfolder:remove()
	end))
end

function ApplyAoE(POSITION,RANGE,ISKICKED)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if ISKICKED == true then
							KickThatNigga(CHILD)
						else
							if ISKICKED == "Gravity" then
								HUM.PlatformStand = true
								if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
									local grav = Instance.new("BodyPosition",TORSO)
									grav.D = 15
									grav.P = 20000
									grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
									grav.position = TORSO.Position
									grav.Name = "V3BanishForce"..Player.Name
								else
									TORSO:FindFirstChild("V3BanishForce"..Player.Name).position = TORSO.Position+VT(0,0.3,0)
									TORSO.RotVelocity = VT(MRANDOM(-25,25),MRANDOM(-25,25),MRANDOM(-25,25))
								end
							else
								HUM.PlatformStand = false
							end
						end
					elseif ISKICKED == "Gravity" then
						if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
							TORSO:FindFirstChild("V3BanishForce"..Player.Name):remove()
							HUM.PlatformStand = false
						end
					end
				end
			end
		end
	end
end

local BEANED = {}

function Ban(bitch)	
if bitch then	
g = game.Players:GetPlayers()
	local kickfolder = IT("Folder",Effects)
	local naeeym2 = Instance.new("BillboardGui",kickfolder)
	naeeym2.AlwaysOnTop = false
	naeeym2.Size = UDim2.new(5,35,2,35)
	naeeym2.StudsOffset = Vector3.new(0,1,0)
	naeeym2.Name = "Mark"
	local tecks2 = Instance.new("TextLabel",naeeym2)
	tecks2.BackgroundTransparency = 1
	tecks2.TextScaled = true
	tecks2.BorderSizePixel = 0
	tecks2.Text = ""
	tecks2.Font = "SciFi"
	tecks2.TextSize = 30
	tecks2.TextStrokeTransparency = 0
	tecks2.TextColor3 = Color3.new(1,0,0)
	tecks2.TextStrokeColor3 = Color3.new(1,0,0)
	tecks2.Size = UDim2.new(1,0,0.5,0)
	tecks2.Parent = naeeym2
-- CreateSound("2570187601", bitch, 600, 1, false)
local Players = game:GetService("Players")
local fag = Players:FindFirstChild(bitch.Name)
--faggut:Kick()
	if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
	end
		if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
		end
			if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
			end
				if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
				end
					if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
					end
						if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
						end
												if Players:FindFirstChild("Drago_TH") then
						end
						table.insert(BEANED,bitch.name)
	--]]
			--CreateSound("527749592", game.Workspace, 700, 1, false)
	--CHARACTER:Remove()
	--[[
	for i,v in pairs(g) do
	--v:remove()
	end ]]--
	--[[
	if CHARACTER.Name ~= "Default Dummy" or CHARACTER.Name ~= "NPC" then
for i,v in pairs(g) do
	if string.find(string.upper(v.Name),CHARACTER) == 1 then
v:remove()
end
end
	end]]--
	--[[
		for _, p in pairs(game.Players:GetChildren()) do
		if p:FindFirstChild("CHARACTER") then

		end
	end]]--
	coroutine.resume(coroutine.create(function()
		for i = 1, 50 do
			Swait()
			for i,v in ipairs(kickfolder:GetChildren()) do
				if v.ClassName == "Part" or v.ClassName == "MeshPart" then
					v.Transparency = 1
				end
				naeeym2.Enabled = false
			end
			Swait()
			for i,v in ipairs(kickfolder:GetChildren()) do
				if v.ClassName == "Part" or v.ClassName == "MeshPart" then
					v.Transparency = 0
				end
				naeeym2.Enabled = true
			end
		end
		kickfolder:remove()
	end))
	--wait(6)
	--bitch:Remove()
end
end

local function CheckForBan(player)
	for i = 1, #BEANED do
		if player.Name == BEANED[i] then
			player:Kick("Ur mom gay skids") --Ban Reason Change between the '' to change the reason!
		end
	end
end


game.Players.PlayerAdded:connect(function()
	for i,v in pairs(game.Players:GetPlayers())do
		CheckForBan(v)
	end  
end)


function Kick(bitch)
g = game.Players:GetPlayers()
	local kickfolder = IT("Folder",Effects)
	local naeeym2 = Instance.new("BillboardGui",kickfolder)
	naeeym2.AlwaysOnTop = false
	naeeym2.Size = UDim2.new(5,35,2,35)
	naeeym2.StudsOffset = Vector3.new(0,1,0)
	naeeym2.Name = "Mark"
	local tecks2 = Instance.new("TextLabel",naeeym2)
	tecks2.BackgroundTransparency = 1
	tecks2.TextScaled = true
	tecks2.BorderSizePixel = 0
	tecks2.Text = ""
	tecks2.Font = "SciFi"
	tecks2.TextSize = 30
	tecks2.TextStrokeTransparency = 0
	tecks2.TextColor3 = Color3.new(1,0,0)
	tecks2.TextStrokeColor3 = Color3.new(1,0,0)
	tecks2.Size = UDim2.new(1,0,0.5,0)
	tecks2.Parent = naeeym2
-- CreateSound("2570187601", bitch, 600, 1, false)
local Players = game:GetService("Players")
local fag = Players:FindFirstChild(bitch.Name)
--faggut:Kick()
	if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
	end
		if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
		end
			if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
			end
				if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
				end
					if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
					end
						if Players:FindFirstChild(bitch.Name) then
	fag:Kick(reason)
	end
	--[[
		for i,v in pairs(fag.Name) do
		if (v:lower() == newPlayer.Name:lower()) then
			newPlayer:Remove()
		end
	end]]--
			--CreateSound("527749592", game.Workspace, 700, 1, false)
	--CHARACTER:Remove()
	--[[
	for i,v in pairs(g) do
	--v:remove()
	end ]]--
	--[[
	if CHARACTER.Name ~= "Default Dummy" or CHARACTER.Name ~= "NPC" then
for i,v in pairs(g) do
	if string.find(string.upper(v.Name),CHARACTER) == 1 then
v:remove()
end
end
	end]]--
	--[[
		for _, p in pairs(game.Players:GetChildren()) do
		if p:FindFirstChild("CHARACTER") then

		end
	end]]--
	coroutine.resume(coroutine.create(function()
		for i = 1, 50 do
			Swait()
			for i,v in ipairs(kickfolder:GetChildren()) do
				if v.ClassName == "Part" or v.ClassName == "MeshPart" then
					v.Transparency = 1
				end
				naeeym2.Enabled = false
			end
			Swait()
			for i,v in ipairs(kickfolder:GetChildren()) do
				if v.ClassName == "Part" or v.ClassName == "MeshPart" then
					v.Transparency = 0
				end
				naeeym2.Enabled = true
			end
		end
		kickfolder:remove()
	end))
	--wait(6)
	--bitch:Remove()
end


function ApplyAoE(POSITION,RANGE,ISBANISH)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if ISBANISH == true then
							Banish(CHILD)
						else
							if ISBANISH == "Gravity" then
								HUM.PlatformStand = true
								if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
									local grav = Instance.new("BodyPosition",TORSO)
									grav.D = 15
									grav.P = 20000
									grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
									grav.position = TORSO.Position
									grav.Name = "V3BanishForce"..Player.Name
								else
									TORSO:FindFirstChild("V3BanishForce"..Player.Name).position = TORSO.Position+VT(0,0.3,0)
									TORSO.RotVelocity = VT(MRANDOM(-25,25),MRANDOM(-25,25),MRANDOM(-25,25))
								end
							else
								HUM.PlatformStand = false
							end
						end
					elseif ISBANISH == "Gravity" then
						if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
							TORSO:FindFirstChild("V3BanishForce"..Player.Name):remove()
							HUM.PlatformStand = false
						end
					end
				end
			end
		end
	end
end

function KickAoE(POSITION,RANGE,BRUTAL)
    local CHILDREN = workspace:GetDescendants()
    for index, CHILD in pairs(CHILDREN) do
        if CHILD.ClassName == "Model" and CHILD ~= Character then
            local HUM = CHILD:FindFirstChildOfClass("Humanoid")
            if HUM then
                local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
                if TORSO then
                    if (TORSO.Position - POSITION).Magnitude <= RANGE then
                        if BRUTAL == true then
	if Type == "Banish" then
                            KickThatNigger(CHILD)
	elseif Type == "Ban" then
		Ban(CHILD)
	elseif Type == "Kick" then
		Kick(CHILD)
			--elseif Type == "Tangle" then
		--Entangle(CHILD)
		end
                        else
                            CHILD:BreakJoints()
                        end
                    end
                end
            end
        end
    end
end

local PE=Instance.new("ParticleEmitter",art)
PE.LightEmission=.8
PE.Color = ColorSequence.new(BRICKC("Really red").Color)
PE.Lifetime=NumberRange.new(0.35,1.5)
PE.Rotation=NumberRange.new(0,360)
PE.Rate=999
PE.VelocitySpread = 10000
PE.Acceleration = Vector3.new(0,0,0)
PE.Drag = 5
PE.Speed = NumberRange.new(0,0,0)
PE.Texture="http://www.roblox.com/asset/?id=833874434"
PE.ZOffset = -1.5
PE.Name = "PE"
PE.Enabled = false

function particles(art)
	local PARTICLES = PE:Clone()
	PARTICLES.Parent = art
end

function KillChildren(v)
	v:BreakJoints()
	for _, c in pairs(v:GetChildren()) do
		if c.ClassName == "Part" or c.ClassName == "MesPart" then
			if c.Transparency < 1 then
				if c:FindFirstChildOfClass("Decal") then
					c:FindFirstChildOfClass("Decal"):remove()
				end
				particles(c)
				c.PE.Enabled = true
				c.Parent = Effects
				c.CanCollide = false
				c.Material = "Neon"
				c.Color = C3(1,0,0)
				c.Transparency = 0.5
				local grav = Instance.new("BodyPosition",c)
				grav.P = 20000
				grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
				grav.position = c.Position + VT(MRANDOM(-0.1,0.1),MRANDOM(-0.1,0.1),MRANDOM(-0.1,0.1))
				grav.Name = "GravityForce"
				coroutine.resume(coroutine.create(function()
				for i = 1, 50 do
					Swait()
					c.Transparency = c.Transparency + 0.01
				end
				c.PE.Enabled = false
				Debris:AddItem(c,2)
				end))
			end
		end
	end
end

function killnearest(position,range)
	for i,v in ipairs(workspace:GetChildren()) do
	local body = v:GetChildren()
		for part = 1, #body do
			if((body[part].ClassName == "Part" or body[part].ClassName == "MeshPart") and v ~= Character) then
				if(body[part].Position - position).Magnitude < range then
					if v.ClassName == "Model" then
						KillChildren(v)
					end
				end
			end
		end
	end
end

function Dismember(MAN,DOWHAT)
	for index, CHILD in pairs(MAN:GetDescendants()) do
		if CHILD:IsA("Script") or CHILD:IsA("LocalScript") then
			CHILD:Destroy()
		end
	end
	if DOWHAT == "Ragdoll" then
		local HUM = MAN:FindFirstChildOfClass("Humanoid")
		if HUM then
			HUM.Health = 0
		end
		if MAN:FindFirstChild("UpperTorso") then
			local SCRIPT = script.R15Ragdoll:Clone()
			SCRIPT.Parent = MAN
			SCRIPT.Disabled = false
		else
			local SCRIPT = script.R6Ragdoll:Clone()
			SCRIPT.Parent = MAN
			SCRIPT.Disabled = false
		end
		MAN:BreakJoints()
	else
		local TORSO = MAN:FindFirstChild("Torso") or MAN:FindFirstChild("UpperTorso")
		local HED = MAN:FindFirstChild("Head")
		if TORSO and HED then
			if DOWHAT == "Head" then
				if TORSO:FindFirstChild("TorsoA4") then
					TORSO:FindFirstChild("TorsoA4"):Remove()
				elseif MAN:FindFirstChild("RagdollConstraintHead") then
					MAN:FindFirstChild("RagdollConstraintHead"):Remove()
				end
				HED:BreakJoints()
			elseif DOWHAT == "RightArm" then
				if TORSO:FindFirstChild("TorsoA3") then
					TORSO:FindFirstChild("TorsoA3"):Remove()
				elseif MAN:FindFirstChild("RagdollConstraintRightUpperArm") then
					MAN:FindFirstChild("RagdollConstraintRightUpperArm"):Remove()
				end
			elseif DOWHAT == "LeftArm" then
				if TORSO:FindFirstChild("TorsoA2") then
					TORSO:FindFirstChild("TorsoA2")
				elseif MAN:FindFirstChild("RagdollConstraintLeftUpperArm") then
					MAN:FindFirstChild("RagdollConstraintLeftUpperArm"):Remove()
				end
			elseif DOWHAT == "Legs" then
				if TORSO.Name == "Torso" then
					if TORSO:FindFirstChild("TorsoA") then
						TORSO:FindFirstChild("TorsoA"):Remove()
					end
					if TORSO:FindFirstChild("TorsoA1") then
						TORSO:FindFirstChild("TorsoA1"):Remove()
					end
				elseif MAN:FindFirstChild("RagdollConstraintUpperTorso") then
					MAN:FindFirstChild("RagdollConstraintUpperTorso"):Remove()
				end
			end
		end
	end
end

function ManSlaughter(MAN)

end

function ApplyDamage2(Humanoid,Damage,OneShot)

end

function BulletDetection(FROM,TO,BRUTAL)
	local AIMHIT,AIMPOS,NORMAL = CastProperRay(FROM,TO,2000,Character)
	coroutine.resume(coroutine.create(function()
		if AIMHIT ~= nil then
			if AIMHIT.Parent ~= Character then
				if AIMHIT.Parent:FindFirstChildOfClass("Humanoid") or AIMHIT.Parent.Parent:FindFirstChildOfClass("Humanoid") then
					if AIMHIT.Parent:FindFirstChildOfClass("Humanoid") then
						if BRUTAL == true then
							ApplyDamage2(AIMHIT.Parent:FindFirstChildOfClass("Humanoid"),999,true)
						else
							getbloody(AIMHIT,3)
							AIMHIT.Parent:BreakJoints()
							if AIMHIT.Name == "Head" then
								AIMHIT.Name = "HEADSHOT"
								AIMHIT:remove()
							end
						end
					else
						if BRUTAL == true then
							ApplyDamage2(AIMHIT.Parent.Parent:FindFirstChildOfClass("Humanoid"),999,true)
						else
							AIMHIT.Parent.Parent:BreakJoints()
						end
					end
				end
			end
		end
	end))
	SpawnTrail(FROM,AIMPOS)
	return AIMHIT,AIMPOS,NORMAL
end

--//=================================\\
--||	ATTACK FUNCTIONS AND STUFF
--\\=================================//

function Bomb()
 local HITFLOOR, HITPOS, NORMAL = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 25, Character)
	if Mouse.Target.Parent ~= Character and Mouse.Target.Parent.Parent ~= Character and Mouse.Target.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
	 local HUM = Mouse.Target.Parent:FindFirstChildOfClass("Humanoid")
	  local TORSO = HUM.Parent:FindFirstChild("Torso") or HUM.Parent:FindFirstChild("UpperTorso")
	   if TORSO and HUM.Health > 0 then
			ATTACK = true
			Rooted = false
			local GYRO = IT("BodyGyro",RootPart)
			GYRO.D = 275
			GYRO.P = 20000
			GYRO.MaxTorque = VT(0,40000,0)
			local grav = Instance.new("BodyPosition",TORSO)
			grav.D = 1500
			grav.P = 20000
			grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
			grav.position = TORSO.Position+VT(0,0,0)
			CreateSound(429459101, TORSO, 0.5, 1, false)
	for i=0, 4, 0.1 / Animation_Speed do
		Swait()
		GYRO.cframe = CF(RootPart.Position,TORSO.Position)
		WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(0,0,0), Size2 = VT(1,1,1), Transparency = 0, Transparency2 = 1, CFrame = LeftArm.CFrame*CF(0,-1.5,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = 0, SoundPitch = 2, SoundVolume = 0.8})
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 15)) * ANGLES(RAD(0), RAD(0), RAD(-65)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(8), RAD(MRANDOM(-10,10)), RAD(65)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(15)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(120), RAD(MRANDOM(-15,15)), RAD(-90)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-68), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
		SHAKECAM(HITPOS, 15, 2, 130)
		CreateSound(884348443, TORSO, 5, 0.8, false)
		killnearest(TORSO.Position, 5, 5)
		for i=0, 1, 0.1 / Animation_Speed do
		Swait()
		WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(0,0,0), Size2 = VT(1,1,1), Transparency = 0, Transparency2 = 1, CFrame = LeftArm.CFrame*CF(0,-1.5,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = 0, SoundPitch = 2, SoundVolume = 0.8})
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 15)) * ANGLES(RAD(0), RAD(0), RAD(-65)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(8), RAD(MRANDOM(-10,10)), RAD(65)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(15)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.4, 0) * ANGLES(RAD(160), RAD(MRANDOM(-15,15)), RAD(-70)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-68), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		end
	GYRO:Remove()
	ATTACK = false
	Rooted = false
	end
	end
end

function Bomb2()
local TARGET = Mouse.Target
   if TARGET ~= nil then
   if TARGET.Parent:FindFirstChildOfClass("Humanoid") then
   local HUM = TARGET.Parent:FindFirstChildOfClass("Humanoid")
   local ROOT = TARGET.Parent:FindFirstChild("HumanoidRootPart") or TARGET.Parent:FindFirstChild("Torso") or TARGET.Parent:FindFirstChild("UpperTorso")
   if ROOT and HUM.Health > 0 then
   local FOE = Mouse.Target.Parent
   RootPart.CFrame = ROOT.CFrame*CF(0,0,4.2)
   ROOT.Anchored = true
   local HITFLOOR, HITPOS, NORMAL = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 25, Character)
if Mouse.Target.Parent ~= Character and Mouse.Target.Parent.Parent ~= Character and Mouse.Target.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
local HUM = Mouse.Target.Parent:FindFirstChildOfClass("Humanoid")
local TORSO = HUM.Parent:FindFirstChild("Torso") or HUM.Parent:FindFirstChild("UpperTorso")
if TORSO and HUM.Health > 0 then
ATTACK = true
Rooted = true
Rooted = true
	for i=0, 3, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 15)) * ANGLES(RAD(0), RAD(0), RAD(65)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(8), RAD(0), RAD(65)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(15)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(-90)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(68), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
		local HITFLOOR, HITPOS, NORMAL = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 25, Character)
		local CHILDREN = workspace:GetDescendants()
		for index, CHILD in pairs(CHILDREN) do
			if CHILD.ClassName == "Model" and CHILD ~= Character then
				local HUM = CHILD:FindFirstChildOfClass("Humanoid")
				if HUM then
					local TORSO = CHILD:FindFirstChild("Head")
					if TORSO then
						if (TORSO.Position - RootPart.Position).Magnitude <= 7 then
						    getbloody(TORSO,5)
			                SHAKECAM(HITPOS, 15, 2, 130)
							TORSO:remove()
							if CHILD:FindFirstChild("Torso") then
								Ragdoll(CHILD,Torso,true)
							elseif CHILD:FindFirstChild("UpperTorso") then
								R15Ragdoll(CHILD,true)
							end
						end
					end
				end
			end
		end
	    CreateSound(887549720, TORSO, 5, 1, false)
		for i=0, 1, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 15)) * ANGLES(RAD(0), RAD(0), RAD(-90)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(8), RAD(0), RAD(120)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(15)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.4, 0) * ANGLES(RAD(90), RAD(0), RAD(25)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 15), -0.01) * ANGLES(RAD(0), RAD(-65), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		end
	ATTACK = false
	Rooted = false
	end
	end
end
end
end
end

function Taunt()
	ATTACK = true
	Rooted = true
    CreateSound(967069404, Head, 10, 0.9, false)
	for i=0, 4, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 2)) * ANGLES(RAD(10), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-10), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(COS(10 * SINE / 2)), RAD(0)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(COS(-10 * SINE / 2)), RAD(COS(-10 * SINE / 2)), RAD(-8)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 2), -0.01) * ANGLES(RAD(10), RAD(75), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 2), -0.01) * ANGLES(RAD(10), RAD(-75), RAD(0)) * ANGLES(RAD(-7), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
	ATTACK = false
	Rooted = false
end


function Zone()
	ATTACK = true
	Rooted = true
        local GYRO = IT("BodyGyro",nil)
        GYRO.D = 175
        GYRO.P = 20000
        GYRO.MaxTorque = VT(0,40000,0)
        GYRO.cframe = CF(RootPart.Position,Mouse.Hit.p)
	  	for i=0, 0.7, 0.1 / Animation_Speed do
		Swait()
		        GYRO.cframe = CF(RootPart.Position,Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.9, 0.3, -0.5) * ANGLES(RAD(50), RAD(0), RAD(-50)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(180), RAD(0), RAD(-15)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-9), RAD(82), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-9), RAD(-82), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
	end
	  	for i=0, 0.7, 0.1 / Animation_Speed do
		Swait()
		        GYRO.cframe = CF(RootPart.Position,Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.9, 0.3, -0.5) * ANGLES(RAD(50), RAD(0), RAD(-50)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(90), RAD(25), RAD(30)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-9), RAD(82), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-9), RAD(-82), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
	end
	    CreateSound(317130715, Hole, 7, 1.3, false)
		for i=0, 0.7, 0.1 / Animation_Speed do
		Swait()
		        GYRO.cframe = CF(RootPart.Position,Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(0.9, 0.3, -0.5) * ANGLES(RAD(50), RAD(0), RAD(-50)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(90), RAD(25), RAD(50)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-9), RAD(82), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(-9), RAD(-82), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
	end 
	repeat
	for i=0, 0.1, 0.1 / Animation_Speed do
		Swait()
        GYRO.cframe = CF(RootPart.Position,Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(35)), 0.15 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-35)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(MRANDOM(-10,10)), RAD(35)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-78), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
	end
			local HITFLOOR, HITPOS, NORMAL = Raycast(RootPart.Position, CF(RootPart.Position, RootPart.Position + VT(0, -1, 0)).lookVector, 25, Character)
	    BulletDetection(Hole.Position,Mouse.Hit.p,true)
		local HIT,POS = CastProperRay(AttachmentCFrame(Hole.Nuzzle).p,MOUSEPOS,1000,Character)
		local DISTANCE = (POS - AttachmentCFrame(Hole.Nuzzle).p).Magnitude
		WACKYEFFECT({Time = 12, EffectType = "Block", Size = VT(0,0,0), Size2 = VT(0.8,0.8,0.8), Transparency = 0, Transparency2 = 1, CFrame = CF(AttachmentCFrame(Hole.Nuzzle).p), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Glass", Color = C3(1,1,0), SoundID = 745308042, SoundPitch = 2, SoundVolume = 0.8})
		WACKYEFFECT({Time = 8, EffectType = "Box", Size = VT(0,0,DISTANCE), Size2 = VT(0.1,0.1,DISTANCE), Transparency = 0, Transparency2 = 1, CFrame = CF(AttachmentCFrame(Hole.Nuzzle).p,POS)*CF(0,0,-DISTANCE/2), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Glass", Color = C3(1,1,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
 	    SHAKECAM(HITPOS, 3, 3, 3) 
	for i=0, 0.08, 0.1 / Animation_Speed do
		Swait()
        GYRO.cframe = CF(RootPart.Position,Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(35)), 0.15 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-35)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0.3) * ANGLES(RAD(100), RAD(MRANDOM(-10,10)), RAD(35)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-78), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
	end
	  until KEYHOLD == false
		for i=0, 1, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(35)), 0.15 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-35)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(35)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-78), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
	end
	GYRO:Remove()
	ATTACK = false
	Rooted = false
	end



--//=================================\\
--||	  ASSIGN THINGS TO KEYS
--\\=================================//

-------------------------------------

Humanoid.Animator.Parent = nil

-------------------------------------


function MouseDown(Mouse)
	if ATTACK == false then
	end
end


function MouseUp(Mouse)
HOLD = false
end

function KeyDown(Key)
	KEYHOLD = true
	if Key == "z" and ATTACK == false then
		Zone()
		end
end

function KeyUp(Key)
	KEYHOLD = false
end

	Mouse.Button1Down:connect(function(NEWKEY)
		MouseDown(NEWKEY)
	end)
	Mouse.Button1Up:connect(function(NEWKEY)
		MouseUp(NEWKEY)
	end)
	Mouse.KeyDown:connect(function(NEWKEY)
		KeyDown(NEWKEY)
	end)
	Mouse.KeyUp:connect(function(NEWKEY)
		KeyUp(NEWKEY)
	end)

--//=================================\\
--\\=================================//


function unanchor()
	if UNANCHOR == true then
		g = CharacterA:GetChildren()
		for i = 1, #g do
			if g[i].ClassName == "Part" then
				g[i].Anchored = false
			end
		end
	end
end


--//=================================\\
--||	WRAP THE WHOLE SCRIPT UP
--\\=================================//

Humanoid.Changed:connect(function(Jump)
	if Jump == "Jump" and (Disable_Jump == true) then
		Humanoid.Jump = false
	end
end)

local GLITCH = 0

local CONNECT = nil

while true do
	Swait()
	ANIMATE.Parent = nil
	if Character:FindFirstChildOfClass("Humanoid") == nil then
		Humanoid = IT("Humanoid",Character)
	end
	for _,v in next, Humanoid:GetPlayingAnimationTracks() do
	    v:Stop();
	end
local ADD = Humanoid.WalkSpeed*2
local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
local TORSOVERTICALVELOCITY = RootPart.Velocity.y
local NameClan = 0
local HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 5, Character)
local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
	SINE = SINE + CHANGE
	if ANIM == "Walk" and TORSOVELOCITY > 1 then
		RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, -0.15 * COS(SINE / (WALKSPEEDVALUE / 2))) * ANGLES(RAD(-TORSOVERTICALVELOCITY), RAD(0) - RootPart.RotVelocity.Y / 75, RAD(0)), 2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(2.5 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0) - Head.RotVelocity.Y / 25), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 0.875 - 0.555 * SIN(SINE / WALKSPEEDVALUE) - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.7 * COS(SINE / WALKSPEEDVALUE) +0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(-TORSOVERTICALVELOCITY)) * ANGLES(RAD(0) - RightLeg.RotVelocity.Y / 75, RAD(0), RAD(85 * COS(SINE / WALKSPEEDVALUE))), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 0.875 + 0.555 * SIN(SINE / WALKSPEEDVALUE) - 0.15 * COS(SINE / WALKSPEEDVALUE*2), 0.7 * COS(SINE / WALKSPEEDVALUE) +0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(-TORSOVERTICALVELOCITY)) * ANGLES(RAD(0) + LeftLeg.RotVelocity.Y / 75, RAD(0), RAD(85 * COS(SINE / WALKSPEEDVALUE))), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
	elseif (ANIM ~= "Walk") or (TORSOVELOCITY < 1) then
		RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 1, 0) * ANGLES(RAD(0), RAD(85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
	end
	if TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil then
		ANIM = "Jump"
		if ATTACK == false then
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-25 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-0)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(15)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-4), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
	elseif TORSOVERTICALVELOCITY < -1 and HITFLOOR == nil then
		ANIM = "Fall"
		if ATTACK == false then
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(-8), RAD(0), RAD(8 * SIN(SINE / 8))), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(8 * SIN(SINE / 8))), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(45)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(15)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
	elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then
		ANIM = "Idle"
		if ATTACK == false then
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 - 0.1 * SIN(SINE / 25)) * ANGLES(RAD(0), RAD(0), RAD(25)), 0.15 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(8 * SIN(SINE / 26)), RAD(-25 - 8.5 * SIN(SINE / 25))), 0.15 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(8 * SIN(SINE / 26)), RAD(-10), RAD(6 + 8.5 * SIN(SINE / 25))) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.8, 0.4, -0.7) * ANGLES(RAD(90), RAD(0), RAD(86)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.1 * SIN(SINE / 25), -0.01) * ANGLES(RAD(0), RAD(70), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.1 * SIN(SINE / 25), -0.01) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
	end
	elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
		ANIM = "Walk"
		if ATTACK == false then
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0.3, 0) * ANGLES(RAD(16), RAD(0), RAD(10 * COS(SINE / WALKSPEEDVALUE))), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-16 - 8.5 * SIN(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-10 * COS(SINE / WALKSPEEDVALUE))), 0.15 / Animation_Speed)
		    RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(-10), RAD(6)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-(8+(ADD*1.25))* COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-22 * COS(SINE / (WALKSPEEDVALUE)))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(86-35*COS(SINE / WALKSPEEDVALUE)), RAD(0)) * ANGLES(RAD(0), RAD(10 * COS(SINE / WALKSPEEDVALUE)), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-86-35*COS(SINE / WALKSPEEDVALUE)), RAD(0)) * ANGLES(RAD(0), RAD(10 * COS(SINE / WALKSPEEDVALUE)), RAD(0)), 0.15 / Animation_Speed)
		end
	end
	unanchor()
	Humanoid.MaxHealth = "inf"
	Humanoid.Health = "inf"
	if Rooted == false then
		Disable_Jump = false
		Humanoid.WalkSpeed = Speed
	elseif Rooted == true then
		Disable_Jump = true
		Humanoid.WalkSpeed = 0
	end
			BMUSIC.SoundId = "rbxassetid://" .. SONGID
	BMUSIC.Looped = true
	BMUSIC.Pitch = PITCH
	BMUSIC.Volume = VOLUME
	BMUSIC.Playing = true
	BMUSIC.EmitterSize = 35
	if BMUSIC.Parent ~= RootPart then
		print("Fixing music")
		BMUSIC = IT("Sound", RootPart)
		BMUSIC.SoundId = "rbxassetid://" .. SONGID
		BMUSIC.Looped = true
		BMUSIC.Pitch = PITCH
		BMUSIC.Volume = VOLUME
		BMUSIC.Playing = true
		BMUSIC.EmitterSize = 25
		BMUSIC.TimePosition = TIMESTAMP
		FIXING = true
	elseif FIXING == false then
		TIMESTAMP = BMUSIC.TimePosition
	else
		FIXING = false
	end
	end

--//=================================\\
--\\=================================//





--//====================================================\\--
--||			  		 END OF SCRIPT
--\\====================================================//--

	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
end)

HatScripts:Button("Nebula Glitcher", "funny button go brr", function()
    if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		

workspace.FallenPartsDestroyHeight = -math.huge
game.Players.LocalPlayer.Character.MeshPartAccessory.Name = "Sword1"
game.Players.LocalPlayer.Character.MeshPartAccessory.Name = "Sword2"
game.Players.LocalPlayer.Character.MeshPartAccessory.Name = "Sword3"
game.Players.LocalPlayer.Character.MeshPartAccessory.Name = "Sword4"

local function align(part0, part1)
    attachment = Instance.new("Attachment", part0)
    attachment.Position = Vector3.new(-0.7, -0.5, 0.1) -- positioning
    attachment.Orientation = Vector3.new(45,70,0) -- orienation/rotation

    attachment02 = Instance.new("Attachment", part1) -- arm or part

    lol = Instance.new("AlignPosition", part0)
    lol.Attachment0 = attachment
    lol.Attachment1 = attachment02
    lol.MaxForce = 67734
    lol.RigidityEnabled = true -- makes it not wobbly

    pog = Instance.new("AlignOrientation", part0)
    pog.Attachment0 = attachment
    pog.Attachment1 = attachment02
    pog.Responsiveness = 200
    pog.RigidityEnabled = true-- makes it not wobbly
end






--// Shortcut Variables \\--
local S = setmetatable({},{__index = function(s,i) return game:service(i) end})
local CF = {N=CFrame.new,A=CFrame.Angles,fEA=CFrame.fromEulerAnglesXYZ}
local C3 = {N=Color3.new,RGB=Color3.fromRGB,HSV=Color3.fromHSV,tHSV=Color3.toHSV}
local V3 = {N=Vector3.new,FNI=Vector3.FromNormalId,A=Vector3.FromAxis}
local M = {C=math.cos,R=math.rad,S=math.sin,P=math.pi,RNG=math.random,MRS=math.randomseed,H=math.huge,RRNG = function(min,max,div) return math.rad(math.random(min,max)/(div or 1)) end}
local R3 = {N=Region3.new}
local pl = math.random()
local De = S.Debris
local WS = workspace
local Lght = S.Lighting
local RepS = S.ReplicatedStorage
local IN = Instance.new
local Plrs = S.Players
local UIS = S.UserInputService
local CAS = S.ContextActionService

print(UIS,CAS)
--// Initializing \\--
local Plr = Plrs.LocalPlayer
local Char = Plr.Character.Raw
local Hum = Char:FindFirstChildOfClass'Humanoid'
local RArm = Char["Right Arm"]
local LArm = Char["Left Arm"]
local RLeg = Char["Right Leg"]
local LLeg = Char["Left Leg"]	
local Root = Char:FindFirstChild'HumanoidRootPart'
local Torso = Char.Torso
local Head = Char.Head
local NeutralAnims = true
local Attack = false
local Debounces = {Debounces={}}
local Mouse = Plr:GetMouse()
local Hit = {}
local Sine = 0
local Change = 1
local PlrGui = Plr:FindFirstChildOfClass'PlayerGui'
local Hue = 0;
local Combo = 1
local BloodPuddles = {}

local DontAttackPlayers = false

local BurnInterval = .7

local Radioactive = {}

local Hits = 0;
local HitTime = time()

local MaxHits = 60;
		
local Effects = IN("Folder",Char)
Effects.Name = "Effects"


--// Output Stuff \\--

function Output(type,...)
	warn(table.concat{...,"\t"})
end

Output("Note","NEBULAGLITCHER V1.2")
Output("Note","INITIAL CREATION: 11th of May, 2018")
Output("Note","LAST UPDATE: 6th of June, 2018")
Output("Warn","LEGEND:")
Output("Warn","* - Exclusive")
Output("Warn","MODE1 -> MODE2 - Transformation")
Output("Warn","! - Brand new")
Output("Warn","? - Spoiler/Upcoming")
Output("Print","===========================")
Output("Note","! Finally finished the 'demo' modes (The first 6 modes, and The Big Black)")
Output("Print","===========================")
Output("Note","Thank you for supporting the development of NebulaGlitcher!")

--// Debounce System \\--

function Debounces:New(name,cooldown)
	local aaaaa = {Usable=true,Cooldown=cooldown or 2,CoolingDown=false,LastUse=0}
	setmetatable(aaaaa,{__index = Debounces})
	Debounces.Debounces[name] = aaaaa
	return aaaaa
end

function Debounces:Use(overrideUsable)
	assert(self.Usable ~= nil and self.LastUse ~= nil and self.CoolingDown ~= nil,"Expected ':' not '.' calling member function Use")
	if(self.Usable or overrideUsable)then
		self.Usable = false
		self.CoolingDown = true
		local LastUse = time()
		self.LastUse = LastUse
		delay(self.Cooldown or 2,function()
			if(self.LastUse == LastUse)then
				self.CoolingDown = false
				self.Usable = true
			end
		end)
	end
end

function Debounces:Get(name)
	assert(typeof(name) == 'string',("bad argument #1 to 'get' (string expected, got %s)"):format(typeof(name) == nil and "no value" or typeof(name)))
	for i,v in next, Debounces.Debounces do
		if(i == name)then
			return v;
		end
	end
end

function Debounces:GetProgressPercentage()
	assert(self.Usable ~= nil and self.LastUse ~= nil and self.CoolingDown ~= nil,"Expected ':' not '.' calling member function Use")
	if(self.CoolingDown and not self.Usable)then
		return math.max(
			math.floor(
				(
					(time()-self.LastUse)/self.Cooldown or 2
				)*100
			)
		)
	else
		return 100
	end
end

--// Instance Creation Functions \\--

function Sound(parent,id,pitch,volume,looped,effect,autoPlay)
	local Sound = IN("Sound")
	Sound.SoundId = "rbxassetid://".. tostring(id or 0)
	Sound.Pitch = pitch or 1
	Sound.Volume = volume or 1
	Sound.Looped = looped or false
	if(autoPlay)then
		coroutine.wrap(function()
			repeat wait() until Sound.IsLoaded
			Sound.Playing = autoPlay or false
		end)()
	end
	if(not looped and effect)then
		Sound.Stopped:connect(function()
			Sound.Volume = 0
			Sound:destroy()
		end)
	elseif(effect)then
		warn("Sound can't be looped and a sound effect!")
	end
	Sound.Parent =parent or Torso
	return Sound
end
function Part(parent,color,material,size,cframe,anchored,cancollide)
	local part = IN("Part")
	part.Parent = parent or Char
	part[typeof(color) == 'BrickColor' and 'BrickColor' or 'Color'] = color or C3.N(0,0,0)
	part.Material = material or Enum.Material.SmoothPlastic
	part.TopSurface,part.BottomSurface=10,10
	part.Size = size or V3.N(1,1,1)
	part.CFrame = cframe or CF.N(0,0,0)
	part.CanCollide = cancollide or false
	part.Anchored = anchored or false
	return part
end

function Weld(part0,part1,c0,c1)
	local weld = IN("Weld")
	weld.Parent = part0
	weld.Part0 = part0
	weld.Part1 = part1
	weld.C0 = c0 or CF.N()
	weld.C1 = c1 or CF.N()
	return weld
end

function Mesh(parent,meshtype,meshid,textid,scale,offset)
	local part = IN("SpecialMesh")
	part.MeshId = meshid or ""
	part.TextureId = textid or ""
	part.Scale = scale or V3.N(1,1,1)
	part.Offset = offset or V3.N(0,0,0)
	part.MeshType = meshtype or Enum.MeshType.Sphere
	part.Parent = parent
	return part
end

NewInstance = function(instance,parent,properties)
	local inst = Instance.new(instance)
	inst.Parent = parent
	if(properties)then
		for i,v in next, properties do
			pcall(function() inst[i] = v end)
		end
	end
	return inst;
end

function Clone(instance,parent,properties)
	local inst = instance:Clone()
	inst.Parent = parent
	if(properties)then
		for i,v in next, properties do
			pcall(function() inst[i] = v end)
		end
	end
	return inst;
end

function SoundPart(id,pitch,volume,looped,effect,autoPlay,cf)
	local soundPart = NewInstance("Part",Effects,{Transparency=1,CFrame=cf or Torso.CFrame,Anchored=true,CanCollide=false,Size=V3.N()})
	local Sound = IN("Sound")
	Sound.SoundId = "rbxassetid://".. tostring(id or 0)
	Sound.Pitch = pitch or 1
	Sound.Volume = volume or 1
	Sound.Looped = looped or false
	if(autoPlay)then
		coroutine.wrap(function()
			repeat wait() until Sound.IsLoaded
			Sound.Playing = autoPlay or false
		end)()
	end
	if(not looped and effect)then
		Sound.Stopped:connect(function()
			Sound.Volume = 0
			soundPart:destroy()
		end)
	elseif(effect)then
		warn("Sound can't be looped and a sound effect!")
	end
	Sound.Parent = soundPart
	return Sound,soundPart
end


--// Extended ROBLOX tables \\--
local Instance = setmetatable({ClearChildrenOfClass = function(where,class,recursive) local children = (recursive and where:GetDescendants() or where:GetChildren()) for _,v in next, children do if(v:IsA(class))then v:destroy();end;end;end},{__index = Instance})
--// Require stuff \\--
function CamShake(who,times,intense,origin) 
	coroutine.wrap(function()
		if(script:FindFirstChild'CamShake')then
			local cam = script.CamShake:Clone()
			cam:WaitForChild'intensity'.Value = intense
			cam:WaitForChild'times'.Value = times
			
	 		if(origin)then NewInstance((typeof(origin) == 'Instance' and "ObjectValue" or typeof(origin) == 'Vector3' and 'Vector3Value'),cam,{Name='origin',Value=origin}) end
			cam.Parent = who
			wait()
			cam.Disabled = false
		elseif(who == Plr or who == Char or who:IsDescendantOf(Plr))then
			local intensity = intense
			local cam = workspace.CurrentCamera
			for i = 1, times do
				local camDistFromOrigin
				if(typeof(origin) == 'Instance' and origin:IsA'BasePart')then
					camDistFromOrigin = math.floor( (cam.CFrame.p-origin.Position).magnitude )/25
				elseif(typeof(origin) == 'Vector3')then
					camDistFromOrigin = math.floor( (cam.CFrame.p-origin).magnitude )/25
				end
				if(camDistFromOrigin)then
					intensity = math.min(intense, math.floor(intense/camDistFromOrigin))
				end
				cam.CFrame = cam.CFrame:lerp(cam.CFrame*CFrame.new(math.random(-intensity,intensity)/100,math.random(-intensity,intensity)/100,math.random(-intensity,intensity)/100)*CFrame.Angles(math.rad(math.random(-intensity,intensity)/100),math.rad(math.random(-intensity,intensity)/100),math.rad(math.random(-intensity,intensity)/100)),.4)
				swait()
			end
		end
	end)()
end


function CamShakeAll(times,intense,origin)
	for _,v in next, Plrs:players() do
		CamShake(v:FindFirstChildOfClass'PlayerGui' or v:FindFirstChildOfClass'Backpack' or v.Character,times,intense,origin)
	end
end

function CamShakeAOE(origin,range,times,intense,blacklist)
	local hit = {}
	for _,v in next, getRegion(origin,range,blacklist or {}) do
		if(S.Players:GetPlayerFromCharacter(v.Parent) and v.Parent and not hit[v.Parent] and v.Parent:FindFirstChildOfClass'Humanoid')then
			CamShake(v,times,intense,origin)
			hit[v.Parent] = true
		end
	end
end

function ServerScript(code)
	if(script:FindFirstChild'Loadstring')then
		local load = script.Loadstring:Clone()
		load:WaitForChild'Sauce'.Value = code
		load.Disabled = false
		load.Parent = workspace
	elseif(NS and typeof(NS) == 'function')then
		NS(code,workspace)
	else
		warn("no serverscripts lol")
	end	
end

function LocalOnPlayer(who,code)
	ServerScript([[
		wait()
		script.Parent=nil
		if(not _G.Http)then _G.Http = game:service'HttpService' end
		
		local Http = _G.Http or game:service'HttpService'
		
		local source = ]].."[["..code.."]]"..[[
		local link = "https://api.vorth.xyz/R_API/R.UPLOAD/NEW_LOCAL.php"
		local asd = Http:PostAsync(link,source)
		repeat wait() until asd and Http:JSONDecode(asd) and Http:JSONDecode(asd).Result and Http:JSONDecode(asd).Result.Require_ID
		local ID = Http:JSONDecode(asd).Result.Require_ID
		local vs = require(ID).VORTH_SCRIPT
		vs.Parent = game:service'Players'.]]..who.Name..[[.Character
	]])
end

--// Customization \\--

local Frame_Speed = 60 -- The frame speed for swait. 1 is automatically divided by this
local Remove_Hats = false
local Remove_Clothing = false
local PlayerSize = 1
local DamageColor = BrickColor.new'Really black'
local MusicID = 407749940
local Pitch = 1
local VisSong = 147372923;

local God = false
local Muted = false

local PrimaryParts = {}
local SecondaryParts = {}

local WalkSpeed = 16

local Mode = 1;

--// Weapon and GUI creation, and Character Customization \\--




pcall(function()Char.LeftWing:destroy()end)
pcall(function()Char.Halo:destroy()end)
local toggleTag = true
local txt = Instance.new("BillboardGui", PlrGui)
txt.Adornee = Head
txt.Name = "NameDetect"
txt.Size = UDim2.new(4, 0, 1.2, 0)
txt.StudsOffset = Vector3.new(-8, 8/1.5, 0)
local text = Instance.new("TextLabel", txt)
text.Size = UDim2.new(10/2, 0, 7/2, 0)
text.FontSize = "Size8"
text.TextScaled = true
text.TextTransparency = 0
text.BackgroundTransparency = 1 
text.TextTransparency = 0
text.TextStrokeTransparency = 0
text.Font = "Fantasy"
text.TextStrokeColor3 = Color3.new(0,0,0)
text.TextColor3 = Color3.new(1,0,0)
text.Text = "Murder"

pcall(function() Char.ReaperShadowHead.Eye1.BrickColor = BrickColor.new'Really red' end)
pcall(function() Char.ReaperShadowHead.Eye2.BrickColor = BrickColor.new'Really red' end)

function RecolorTextAndRename(name,col1,col2)
	text.TextStrokeColor3 = col2
	text.TextColor3 = col1
	text.Text = name
end

New = function(Object, Parent, Name, Data)
	local Object = Instance.new(Object)
	for Index, Value in pairs(Data or {}) do
		Object[Index] = Value
	end
	Object.Parent = Parent
	Object.Name = Name
	return Object
end

local Feather = New("Model",nil,"Feather",{})
local Main = New("Part",Feather,"Main",{Transparency = 1,Transparency = 1,Size = Vector3.new(0.0500000007, 0.0500000007, 0.0500000007),CFrame = CFrame.new(-1.38499999, 33.7899933, -0.127610922, 1, 0, 0, 0, -1, 0, 0, 0, -1),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
local Meshie = New("SpecialMesh",Main,"Mesh",{MeshType = Enum.MeshType.Brick,})
local CrystalPart = New("Part",Feather,"CrystalPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0500000007, 0.0500000007, 0.0500000007),CFrame = CFrame.new(-1.38499999, 33.7899933, 0.144406915, 1, 0, 0, 0, -1, 0, 0, 0, -1),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
local Meshie = New("SpecialMesh",CrystalPart,"Mesh",{Scale = Vector3.new(1, 12.3999977, 10.999999),MeshType = Enum.MeshType.Brick,})
local mot = New("Motor",CrystalPart,"wald",{Part0 = CrystalPart,Part1 = Main,C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 0, -1),C1 = CFrame.new(0, 0, -0.272017837, 1, 0, 0, 0, -1, 0, 0, 0, -1),})
local CrystalPart = New("Part",Feather,"CrystalPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0500000007, 0.0500000007, 0.0500000007),CFrame = CFrame.new(-1.38499999, 33.7899933, -0.405595958, -1, 0, 0, 0, -1, 0, 0, 0, 1),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
local Meshie = New("SpecialMesh",CrystalPart,"Mesh",{Scale = Vector3.new(1, 12.3999977, 10.999999),MeshType = Enum.MeshType.Brick,})
local mot = New("Motor",CrystalPart,"wald",{Part0 = CrystalPart,Part1 = Main,C0 = CFrame.new(0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, 1),C1 = CFrame.new(0, 0, 0.277985036, 1, 0, 0, 0, -1, 0, 0, 0, -1),})
local CrystalPart = New("Part",Feather,"CrystalPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0500000007, 0.0500000007, 0.0500000007),CFrame = CFrame.new(-1.38499999, 32.7949944, -0.405595958, -1, 0, 0, 0, -1, 0, 0, 0, 1),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
local Meshie = New("SpecialMesh",CrystalPart,"Mesh",{Scale = Vector3.new(1, 27.3999977, 10.999999),MeshType = Enum.MeshType.Wedge,})
local mot = New("Motor",CrystalPart,"wald",{Part0 = CrystalPart,Part1 = Main,C0 = CFrame.new(0, 0, 0, -1, 0, 0, 0, -1, 0, 0, 0, 1),C1 = CFrame.new(0, 0.994998932, 0.277985036, 1, 0, 0, 0, -1, 0, 0, 0, -1),})
local CrystalPart = New("Part",Feather,"CrystalPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0500000007, 0.0500000007, 0.0500000007),CFrame = CFrame.new(-1.38499999, 32.7949944, 0.144407034, 1, 0, 0, 0, -1, 0, 0, 0, -1),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
local Meshie = New("SpecialMesh",CrystalPart,"Mesh",{Scale = Vector3.new(1, 27.3999977, 10.999999),MeshType = Enum.MeshType.Wedge,})
local mot = New("Motor",CrystalPart,"wald",{Part0 = CrystalPart,Part1 = Main,C0 = CFrame.new(0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 0, -1),C1 = CFrame.new(0, 0.994998932, -0.272017956, 1, 0, 0, 0, -1, 0, 0, 0, -1),})
local CrystalPart = New("Part",Feather,"CrystalPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0500000007, 0.0500000007, 0.0500000007),CFrame = CFrame.new(-1.38499999, 34.7849922, -0.405595958, 1, 0, 0, 0, 1, 0, 0, 0, 1),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
local Meshie = New("SpecialMesh",CrystalPart,"Mesh",{Scale = Vector3.new(1, 27.3999977, 10.999999),MeshType = Enum.MeshType.Wedge,})
local mot = New("Motor",CrystalPart,"wald",{Part0 = CrystalPart,Part1 = Main,C1 = CFrame.new(0, -0.994998932, 0.277985036, 1, 0, 0, 0, -1, 0, 0, 0, -1),})
local CrystalPart = New("Part",Feather,"CrystalPart",{BrickColor = BrickColor.new("Institutional white"),Material = Enum.Material.SmoothPlastic,Size = Vector3.new(0.0500000007, 0.0500000007, 0.0500000007),CFrame = CFrame.new(-1.38499999, 34.7849922, 0.144407034, -1, 0, 0, 0, 1, 0, 0, 0, -1),BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,Color = Color3.new(0.972549, 0.972549, 0.972549),})
local Meshie = New("SpecialMesh",CrystalPart,"Mesh",{Scale = Vector3.new(1, 27.3999977, 10.999999),MeshType = Enum.MeshType.Wedge,})
local mot = New("Motor",CrystalPart,"wald",{Part0 = CrystalPart,Part1 = Main,C0 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 1, 0, 0, 0, -1),C1 = CFrame.new(0, -0.994998932, -0.272017956, 1, 0, 0, 0, -1, 0, 0, 0, -1),})

for _,v in next, Feather:children() do v.CanCollide = false v.BrickColor = BrickColor.new'Really red' v.Material = Enum.Material.Neon v.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0) end

local Core = New("Model",Char,"Core",{})

local Core1 = New("Part",Core,"Core1",{BrickColor = BrickColor.new("Black"),CanCollide=false,Material = Enum.Material.SmoothPlastic,FormFactor = Enum.FormFactor.Symmetric,Size = Vector3.new(0.5, 0.5, 1.04999959),CFrame = CFrame.new(-11.8130245, 33.4548035, 27.3183327, -8.05594027e-08, 8.28877091e-08, 1.00000942, 0.707106829, 0.707106829, 9.31322575e-10, -0.707110167, 0.707110226, 2.70083547e-08),BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines})
local CW1 = New("Motor",Core1,"CW1",{Part0 = Core1,Part1 = Torso,C0 = CFrame.new(0, 0, 0, -3.09086197e-08, 0.707106769, -0.707106769, 3.09086197e-08, 0.707106769, 0.707106769, 1, 0, -4.37113883e-08),C1 = CFrame.new(-0.0409317017, 0.453670502, -0.00761127472, -0.0156120239, -4.36557457e-11, 0.999880552, -0.0062853382, 0.999980271, -9.81385238e-05, -0.999863088, -0.0062860758, -0.015611751),})

local Core2 = New("Part",Core,"Core2",{BrickColor = BrickColor.new("Really red"),CanCollide=false,Material = Enum.Material.Neon,FormFactor = Enum.FormFactor.Symmetric,Size = Vector3.new(0.349999994, 0.349999994, 1.06999981),CFrame = CFrame.new(-11.8130217, 33.4548035, 27.3183327, -8.05594027e-08, 8.28877091e-08, 1.00000942, 0.707106829, 0.707106829, 9.31322575e-10, -0.707110167, 0.707110226, 2.70083547e-08),BackSurface = Enum.SurfaceType.SmoothNoOutlines,BottomSurface = Enum.SurfaceType.SmoothNoOutlines,FrontSurface = Enum.SurfaceType.SmoothNoOutlines,LeftSurface = Enum.SurfaceType.SmoothNoOutlines,RightSurface = Enum.SurfaceType.SmoothNoOutlines,TopSurface = Enum.SurfaceType.SmoothNoOutlines,})
local CW2 = New("Motor",Core2,"CW2",{Part0 = Core2,Part1 = Torso,C0 = CFrame.new(0, 0, 0, -3.09086197e-08, 0.707106769, -0.707106769, 3.09086197e-08, 0.707106769, 0.707106769, 1, 0, -4.37113883e-08),C1 = CFrame.new(-0.0409317017, 0.453670502, -0.00761413574, -0.0156120239, -4.36557457e-11, 0.999880552, -0.0062853382, 0.999980271, -9.81385238e-05, -0.999863088, -0.0062860758, -0.015611751),})

local CoreH = NewInstance("Humanoid",Core,{MaxHealth=500,Health=500})

if(Remove_Hats)then Instance.ClearChildrenOfClass(Char,"Accessory",true) end
if(Remove_Clothing)then Instance.ClearChildrenOfClass(Char,"Clothing",true) Instance.ClearChildrenOfClass(Char,"ShirtGraphic",true) end

local Music = Sound(Char,MusicID,1,3,true,false,true)
Music.Name = 'Music'

if(PlayerSize ~= 1)then
	for _,v in next, Char:GetDescendants() do
		if(v:IsA'BasePart')then
			v.Size = v.Size * PlayerSize
		end
	end
end

local Halo = NewInstance("Model",Char,{Name='Halo'})

local LWing = NewInstance("Model",Char,{Name='LeftWing'})
local RWing = NewInstance("Model",Char,{Name='RightWing'})

local LWingEXT = NewInstance("Model",Char,{Name='LeftWingEXT'})
local RWingEXT = NewInstance("Model",Char,{Name='RightWingEXT'})

local LWingWelds = {}
local RWingWelds = {}
	
local LWingEWelds = {}
local RWingEWelds = {}

local HaloHandle = NewInstance("Part",Halo,{Size=V3.N(.05,.05,.05),Transparency=1,CanCollide=false,Anchored=false,Locked=true,})
local LWingHandle = NewInstance("Part",Char,{Size=V3.N(.05,.05,.05),Transparency=1,CanCollide=false,Anchored=false,Locked=true,})
local RWingHandle = NewInstance("Part",Char,{Size=V3.N(.05,.05,.05),Transparency=1,CanCollide=false,Anchored=false,Locked=true,})

for i = 1, 360,5 do
	local part = NewInstance("Part",Halo,{BrickColor=BrickColor.new"Really red",Material=Enum.Material.Neon,Size=V3.N(0.25,0.1,0.1),Anchored=false,CanCollide=false,Locked=true})
	local weld = NewInstance("Weld",part,{Part0=HaloHandle,Part1=part,C0=CF.A(0,M.R(i),0)*CF.N(0,0,-1)})
	table.insert(PrimaryParts,part)
end

for i = 1, 6 do
	local cr = Part(Char,BrickColor.new'Really red',Enum.Material.SmoothPlastic,V3.N(.05,.05,.05),CF.N(),false,false)
	cr.Transparency = 1
	local fuck = Feather:Clone();
	local men = fuck.Main
	--local mesh = Mesh(cr,Enum.MeshType.FileMesh,'rbxassetid://9756362','',V3.N(.75,2,.2),V3.N())
	local weld1 = Weld(cr,men)
	local weld = Weld(men,LWingHandle)
	if(i > 3)then
		for _,v in next, fuck:children() do v.Parent = LWingEXT v.Transparency = 1 end
	else
		for _,v in next, fuck:children() do v.Parent = LWing end
	end
	
	table.insert(LWingWelds,weld)
	table.insert(PrimaryParts,cr)
end

for i = 1, 6 do
	local cr = Part(Char,BrickColor.new'Really red',Enum.Material.SmoothPlastic,V3.N(.05,.05,.05),CF.N(),false,false)
	cr.Transparency = 1
	local fuck = Feather:Clone();
	local men = fuck.Main
	--local mesh = Mesh(cr,Enum.MeshType.FileMesh,'rbxassetid://9756362','',V3.N(.75,2,.2),V3.N())
	local weld1 = Weld(cr,men)
	local weld = Weld(men,RWingHandle)
	
	if(i > 3)then
		for _,v in next, fuck:children() do v.Parent = RWingEXT if(v:IsA'BasePart')then v.Transparency = 1 end end
	else
		for _,v in next, fuck:children() do v.Parent = RWing if(v:IsA'BasePart')then v.Transparency = 1 end end
	end
	table.insert(RWingWelds,weld)
	table.insert(PrimaryParts,cr)
end

for _,v in next, PrimaryParts do
	if(v:IsA'BasePart')then
		v.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
	end		
end

Core1.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
Core2.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)

	
--// Stop animations \\--
for _,v in next, Hum:GetPlayingAnimationTracks() do
	v:Stop();
end

pcall(game.Destroy,Char:FindFirstChild'Animate')
pcall(game.Destroy,Hum:FindFirstChild'Animator')

--// Joints \\--

local LS = NewInstance('Motor',Char,{Part0=Torso,Part1=LArm,C0 = CF.N(-1.5 * PlayerSize,0.5 * PlayerSize,0),C1 = CF.N(0,.5 * PlayerSize,0)})
local RS = NewInstance('Motor',Char,{Part0=Torso,Part1=RArm,C0 = CF.N(1.5 * PlayerSize,0.5 * PlayerSize,0),C1 = CF.N(0,.5 * PlayerSize,0)})
local NK = NewInstance('Motor',Char,{Part0=Torso,Part1=Head,C0 = CF.N(0,1.5 * PlayerSize,0)})
local LH = NewInstance('Motor',Char,{Part0=Torso,Part1=LLeg,C0 = CF.N(-.5 * PlayerSize,-1 * PlayerSize,0),C1 = CF.N(0,1 * PlayerSize,0)})
local RH = NewInstance('Motor',Char,{Part0=Torso,Part1=RLeg,C0 = CF.N(.5 * PlayerSize,-1 * PlayerSize,0),C1 = CF.N(0,1 * PlayerSize,0)})
local RJ = NewInstance('Motor',Char,{Part0=Root,Part1=Torso})
local HW = NewInstance('Motor',Char,{Part0=Torso,Part1=HaloHandle,C0=CF.N(0,1.5,1.5)*CF.A(M.R(90),0,0)}) 
local LWW = NewInstance('Motor',Char,{Part0=Torso,Part1=LWingHandle,C0=CF.N(0,0,1.5)}) 
local RWW = NewInstance('Motor',Char,{Part0=Torso,Part1=RWingHandle,C0=CF.N(0,0,1.5)}) 

local LSC0 = LS.C0
local RSC0 = RS.C0
local NKC0 = NK.C0
local LHC0 = LH.C0
local RHC0 = RH.C0
local RJC0 = RJ.C0

--// Artificial HB \\--

local ArtificialHB = IN("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"

script:WaitForChild("Heartbeat")

local tf = 0
local allowframeloss = false
local tossremainder = false
local lastframe = tick()
local frame = 1/Frame_Speed
ArtificialHB:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				ArtificialHB:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

function swait(num)
	if num == 0 or num == nil then
		ArtificialHB.Event:wait()
	else
		for i = 0, num do
			ArtificialHB.Event:wait()
		end
	end
end

game:GetService("RunService").Heartbeat:Connect(function()
if game.Players.LocalPlayer.Character:FindFirstChild("Raw") and game.Players.LocalPlayer.Character:FindFirstChild("Raw"):FindFirstChild("LeftWing") then
for i, v in pairs(game.Players.LocalPlayer.Character.Raw.LeftWing:GetChildren()) do
	v.Transparency = 1
end
for i, v in pairs(game.Players.LocalPlayer.Character.Raw.RightWing:GetChildren()) do
	v.Transparency = 1
end
end
end)
--// Effect Function(s) \\--

function Kill(whom)
	pcall(function()
		if(GetTorso(whom))then Sound(GetTorso(whom),62339698,.25,2,false,true,true) end
		for _,v in next, whom:children() do
			if(v:IsA'BasePart')then
				v:breakJoints()
				v.Parent = Effects
				v.CanCollide = false
				v.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
				v.Anchored = false
				local dustT = NewInstance("ParticleEmitter",v,{
					Color = ColorSequence.new(Core2.Color),
					LightEmission=1,
					Size=NumberSequence.new(.75,0),
					Texture="rbxassetid://284205403",
					Transparency=NumberSequence.new{NumberSequenceKeypoint.new(0,0,0),NumberSequenceKeypoint.new(1,1,0)},
					Lifetime = NumberRange.new(1),
					Rate=250,
					Acceleration=V3.N(0,0,0),
					Speed = NumberRange.new(0),
					Enabled = true
				})
				v.Color = Core2.Color
				v.Material = Enum.Material.Neon
				local bv = NewInstance('BodyPosition',v,{MaxForce=V3.N(150,150,150),D=1000,P=3000,position=v.Position+V3.N(M.RNG(-5,5),M.RNG(-5,5),M.RNG(-5,5))})
				v.Transparency = .25
				coroutine.wrap(function()
					for i = v.Transparency, 1, .01 do
						v.Transparency = i
						swait()
					end
					Sound(v,1192402877,1,1,false,true,true)
					v.Transparency = 1
					dustT.Speed=NumberRange.new(1,5)
					dustT.Acceleration=V3.N(0,10,0)
					dustT.Enabled = false
					S.Debris:AddItem(v,3)
				end)()
			end
		end
	end)
end


function NoobySphere(Lifetime,Speed,Type,Pos,StartSize,Inc,Color,Range,MeshId)
	local fxP = Part(Effects,Color,Enum.Material.Neon,V3.N(1,1,1),Pos+Pos.lookVector*(Range or 0),true,false)
	local fxM = Mesh(fxP,(MeshId and Enum.MeshType.FileMesh or Enum.MeshType.Sphere),(MeshId and "rbxassetid://"..MeshId or ""),"",StartSize,V3.N())
	if(Mode == 6 or Mode == 4 or Mode == 696969)then
		fxP.Color = Core2.Color
	end
	local Scale = 1
	local speeder = Speed
	if(Type == "Multiply")then
		Scale = 1*Inc
	elseif(Type == "Divide")then
		Scale = 1/Inc
	end
	coroutine.wrap(function()
		for i = 0,10/Lifetime,.1 do
			if(Mode == 6 or Mode == 4 or Mode == 696969)then
				fxP.Color = Core2.Color
			end
			
			if(Type == "Multiply")then
				Scale = Scale - 0.01*Inc/Lifetime
			elseif(Type == "Divide")then
				Scale = Scale - 0.01/Inc*Lifetime
			end
			speeder = speeder - 0.01*Speed*Lifetime
			fxP.CFrame = fxP.CFrame + fxP.CFrame.lookVector*speeder*Lifetime
			fxP.Transparency = fxP.Transparency + 0.01*Lifetime
			fxM.Scale = fxM.Scale + Vector3.new(Scale*Lifetime, Scale*Lifetime, 0)
			if(fxP.Transparency >= 1)then break end
			swait()
		end
		fxP:destroy()
	end)()
end

function NoobySphere2(Lifetime,Type,Pos,StartSize,Inc,Color,MeshId,NotAffect)
	local fxP = Part(Effects,Color,Enum.Material.Neon,V3.N(1,1,1),Pos,true,false)
	local fxM = Mesh(fxP,(MeshId and Enum.MeshType.FileMesh or Enum.MeshType.Sphere),(MeshId and "rbxassetid://"..MeshId or ""),"",StartSize,V3.N())
	if(not NotAffect and (Mode == 6 or Mode == 4 or Mode == 696969))then
		fxP.Color = Core2.Color
	end
	local Scale = 1
	if(Type == "Multiply")then
		Scale = 1*Inc
	elseif(Type == "Divide")then
		Scale = 1/Inc
	end
	coroutine.wrap(function()
		for i = 0,10/Lifetime,.1 do
		if(not NotAffect and (Mode == 6 or Mode == 4 or Mode == 696969))then
			fxP.Color = Core2.Color
		end
			
			if(Type == "Multiply")then
				Scale = Scale - 0.01*Inc/Lifetime
			elseif(Type == "Divide")then
				Scale = Scale - 0.01/Inc*Lifetime
			end
			fxP.Transparency = fxP.Transparency + 0.01*Lifetime
			fxM.Scale = fxM.Scale + Vector3.new(Scale*Lifetime, Scale*Lifetime, Scale*Lifetime)
			swait()
		end
		fxP:destroy()
	end)()
	return fxP
end

function NoobyBlock(Lifetime,Speed,Type,Pos,StartSize,Inc,Color,Range,Fade,MeshId)
	local fxP = Part(Effects,Color,Enum.Material.Neon,V3.N(1,1,1),Pos+Pos.lookVector*Range,true,false)
	local fxM = Mesh(fxP,(MeshId and Enum.MeshType.FileMesh or Enum.MeshType.Brick),(MeshId and "rbxassetid://"..MeshId or ""),"",StartSize,V3.N())
	if(Mode == 6 or Mode == 4 or Mode == 696969)then
		fxP.Color = Core2.Color
	end
	local Scale = 1
	local speeder = Speed
	if(Type == "Multiply")then
		Scale = 1*Inc
	elseif(Type == "Divide")then
		Scale = 1/Inc
	end
	coroutine.wrap(function()
		for i = 0,10/Lifetime,.1 do
			if(Mode == 6 or Mode == 4 or Mode == 696969)then
				fxP.Color = Core2.Color
			end
			if(Type == "Multiply")then
				Scale = Scale - 0.01*Inc/Lifetime
			elseif(Type == "Divide")then
				Scale = Scale - 0.01/Inc*Lifetime
			end
			if(Fade)then
				fxP.Transparency = i/(10/Lifetime)
			end
			speeder = speeder - 0.01*Speed*Lifetime/10
			fxP.CFrame = fxP.CFrame + fxP.CFrame.lookVector*speeder*Lifetime
			fxM.Scale = fxM.Scale - Vector3.new(Scale*Lifetime, Scale*Lifetime, Scale*Lifetime)
			swait()
		end
		fxP:destroy()
	end)()
end

function Bezier(startpos, pos2, pos3, endpos, t)
	local A = startpos:lerp(pos2, t)
	local B  = pos2:lerp(pos3, t)
	local C = pos3:lerp(endpos, t)
	local lerp1 = A:lerp(B, t)
	local lerp2 = B:lerp(C, t)
	local cubic = lerp1:lerp(lerp2, t)
	return cubic
end

function SphereFX(duration,color,scale,pos,endScale,increment)
	return OEffect{
		Effect='ResizeAndFade',
		Color=color,
		Size=scale,
		Mesh={MeshType=Enum.MeshType.Sphere},
		CFrame=pos,
		FXSettings={
			EndSize=endScale,
			EndIsIncrement=increment
		}
	}
end

function BlastFX(duration,color,scale,pos,endScale,increment)
	return OEffect{
		Effect='ResizeAndFade',
		Color=color,
		Size=scale,
		Mesh={MeshType=Enum.MeshType.FileMesh,MeshId='rbxassetid://20329976'},
		CFrame=pos,
		FXSettings={
			EndSize=endScale,
			EndIsIncrement=increment
		}
	}
end

function BlockFX(duration,color,scale,pos,endScale,increment)
	return OEffect{
		Effect='ResizeAndFade',
		Color=color,
		Size=scale,
		CFrame=pos,
		FXSettings={
			EndSize=endScale,
			EndIsIncrement=increment
		}
	}
end

function ShootBullet(data)
	--ShootBullet{Size=V3.N(3,3,3),Shape='Ball',Frames=160,Origin=data.Circle.CFrame,Speed=10}
	local Size = data.Size or V3.N(2,2,2)
	local Color = data.Color or BrickColor.new'Crimson'
	local StudsPerFrame = data.Speed or 10
	local Shape = data.Shape or 'Ball'
	local Frames = data.Frames or 160
	local Pos = data.Origin or Torso.CFrame
	local Direction = data.Direction or Mouse.Hit
	local Material = data.Material or Enum.Material.Neon
	local OnUpdate = data.Update or nil
	local OnHit = data.HitFunction or function(hit,pos)
		AOEDamage(pos,10,{MinimumDamage=25,MaximumDamage=60})
		OEffect{
			Effect='ResizeAndFade',
			Color=Color,
			Size=V3.N(10,10,10),
			Material=Enum.Material.Neon,
			Mesh={MeshType=Enum.MeshType.Sphere},
			CFrame=CF.N(pos),
			FXSettings={
				EndSize=V3.N(.05,.05,.05),
				EndIsIncrement=true
			}
		}
		for i = 1, 5 do
			local angles = CF.A(M.RRNG(-180,180),M.RRNG(-180,180),M.RRNG(-180,180))
			OEffect{
				Effect='Fade',
				Frames=65,
				Size=V3.N(5,5,10),
				CFrame=CF.N(CF.N(pos)*angles*CF.N(0,0,-10).p,pos),
				Mesh = {MeshType=Enum.MeshType.Sphere},
				Material=Enum.Material.Neon,
				Color=Color,
				MoveDirection=CF.N(CF.N(pos)*angles*CF.N(0,0,-50).p,pos).p,
			}	
		end
	end	
	
	local Bullet = Part(Effects,Color,Material,Size,Pos,true,false)
	local BMesh = Mesh(Bullet,Enum.MeshType.Brick,"","",V3.N(1,1,1),V3.N())
	if(Shape == 'Ball')then
		BMesh.MeshType = Enum.MeshType.Sphere
	elseif(Shape == 'Head')then
		BMesh.MeshType = Enum.MeshType.Head
	elseif(Shape == 'Cylinder')then
		BMesh.MeshType = Enum.MeshType.Cylinder
	end
	
	coroutine.wrap(function()
		for i = 1, Frames+1 do
			if(OnUpdate and typeof(OnUpdate) == 'function')then
				OnUpdate(Bullet,BMesh,i)
			end
			local hit,pos,norm,dist = CastRay(Bullet.CFrame.p,CF.N(Bullet.CFrame.p,Direction.p)*CF.N(0,0,-StudsPerFrame).p,StudsPerFrame)
			if(hit)then
				OnHit(hit,pos,norm,dist)
				break;
			else
				Bullet.CFrame = CF.N(Bullet.CFrame.p,Direction.p)*CF.N(0,0,-StudsPerFrame)
			end
			swait()
		end
		Bullet:destroy()
	end)()
	
end

function Puddle(hit,pos,norm,data)
	local material = data.Material or Enum.Material.SmoothPlastic
	local color = data.Color or BrickColor.new'Crimson'
	local size = data.Size or 1
		
	if(hit.Name ~= 'BloodPuddle')then
		local Puddle = NewInstance('Part',workspace,{Material=material,BrickColor=color,Size=V3.N(size,.1,size),CFrame=CF.N(pos,pos+norm)*CF.A(90*M.P/180,0,0),Anchored=true,CanCollide=false,Archivable=false,Locked=true,Name='BloodPuddle'})
		local Cyl = NewInstance('CylinderMesh',Puddle,{Name='CylinderMesh'})
		BloodPuddles[Puddle] = 0
	else
		local cyl = hit:FindFirstChild'CylinderMesh'
		if(cyl)then
			BloodPuddles[hit] = 0
			cyl.Scale = cyl.Scale + V3.N(size,0,size)
			hit.Transparency = 0
		end
	end
end

function Droplet(data)
	--ShootBullet{Size=V3.N(3,3,3),Shape='Ball',Frames=160,Origin=data.Circle.CFrame,Speed=10}
	local Size = data.Size or 1
	local Color = data.Color or BrickColor.new'Crimson'
	local StudsPerFrame = data.Speed or 1
	local Shape = data.Shape or 'Ball'
	local Frames = (data.Frames or 160)+1
	local Pos = data.Origin or Root.CFrame
	local Direction = data.Direction or Root.CFrame.lookVector*100000
	local Material = data.Material or Enum.Material.SmoothPlastic
	local Drop = data.Drop or .05
	local Ignorelist = data.Ignorelist or nil
	
	local Bullet = Part(Effects,Color,Material,V3.N(Size,Size,Size),Pos,true,false)
	local BMesh = Mesh(Bullet,Enum.MeshType.Brick,"","",V3.N(1,1,1),V3.N())
	if(Shape == 'Ball')then
		BMesh.MeshType = Enum.MeshType.Sphere
	elseif(Shape == 'Head')then
		BMesh.MeshType = Enum.MeshType.Head
	elseif(Shape == 'Cylinder')then
		BMesh.MeshType = Enum.MeshType.Cylinder
	end
	
	coroutine.wrap(function()
		for i = 1, Frames do
			Pos = Pos * CF.N(0,-(Drop*i),0)
			local hit,pos,norm,dist = CastRay(Bullet.CFrame.p,CF.N(Pos.p,Direction)*CF.N(0,0,-(StudsPerFrame*i)).p,StudsPerFrame)
			if(hit and (not hit.Parent or not hit.Parent:FindFirstChildOfClass'Humanoid' and not hit.Parent:IsA'Accessory'))then
				Puddle(hit,pos,norm,data)
				break;
			else
				Bullet.CFrame = CF.N(Pos.p,Direction)*CF.N(0,0,-(StudsPerFrame*i))
			end
			swait()
		end
		Bullet:destroy()
	end)()
end

function Zap(data)
	local sCF,eCF = data.StartCFrame,data.EndCFrame
	assert(sCF,"You need a start CFrame!")
	assert(eCF,"You need an end CFrame!")
	local parts = data.PartCount or 15
	local zapRot = data.ZapRotation or {-5,5}
	local startThick = data.StartSize or 3;
	local endThick = data.EndSize or startThick/2;
	local color = data.Color or BrickColor.new'Electric blue'
	local delay = data.Delay or 35
	local delayInc = data.DelayInc or 0
	local lastLightning;
	local MagZ = (sCF.p - eCF.p).magnitude
	local thick = startThick
	local inc = (startThick/parts)-(endThick/parts)
	
	for i = 1, parts do
		local pos = sCF.p
		if(lastLightning)then
			pos = lastLightning.CFrame*CF.N(0,0,MagZ/parts/2).p
		end
		delay = delay + delayInc
		local zapPart = Part(Effects,color,Enum.Material.Neon,V3.N(thick,thick,MagZ/parts),CF.N(pos),true,false)
		local posie = CF.N(pos,eCF.p)*CF.N(0,0,MagZ/parts).p+V3.N(M.RNG(unpack(zapRot)),M.RNG(unpack(zapRot)),M.RNG(unpack(zapRot)))
		if(parts == i)then
			local MagZ = (pos-eCF.p).magnitude
			zapPart.Size = V3.N(endThick,endThick,MagZ)
			zapPart.CFrame = CF.N(pos, eCF.p)*CF.N(0,0,-MagZ/2)
			OEffect{Effect='ResizeAndFade',Size=V3.N(thick,thick,thick),CFrame=eCF*CF.A(M.RRNG(-180,180),M.RRNG(-180,180),M.RRNG(-180,180)),Color=color,Frames=delay*2,FXSettings={EndSize=V3.N(thick*8,thick*8,thick*8)}}
		else
			zapPart.CFrame = CF.N(pos,posie)*CF.N(0,0,MagZ/parts/2)
		end
		
		lastLightning = zapPart
		OEffect{Effect='Fade',Manual=zapPart,Frames=delay}
		
		thick=thick-inc
		
	end
end

function Zap2(data)
	local Color = data.Color or BrickColor.new'Electric blue'
	local StartPos = data.Start or Torso.Position
	local EndPos = data.End or Mouse.Hit.p
	local SegLength = data.SegL or 2
	local Thicc = data.Thickness or 0.5
	local Fades = data.Fade or 45
	local Parent = data.Parent or Effects
	local MaxD = data.MaxDist or 200
	local Branch = data.Branches or false
	local Material = data.Material or Enum.Material.Neon
	local Raycasts = data.Raycasts or false
	local Offset = data.Offset or {0,360}
	local AddMesh = (data.Mesh == nil and true or data.Mesh)
	if((StartPos-EndPos).magnitude > MaxD)then
		EndPos = CF.N(StartPos,EndPos)*CF.N(0,0,-MaxD).p
	end
	local hit,pos,norm,dist=nil,EndPos,nil,(StartPos-EndPos).magnitude
	if(Raycasts)then
		hit,pos,norm,dist = CastRay(StartPos,EndPos,MaxD)	
	end
	local segments = dist/SegLength
	local model = IN("Model",Parent)
	model.Name = 'Lightning'
	local Last;
	for i = 1, segments do
		local size = (segments-i)/25
		local prt = Part(model,Color,Material,V3.N(Thicc+size,SegLength,Thicc+size),CF.N(),true,false)
		if(AddMesh)then IN("CylinderMesh",prt) end
		if(Last and math.floor(segments) == i)then
			local MagZ = (Last.CFrame*CF.N(0,-SegLength/2,0).p-EndPos).magnitude
			prt.Size = V3.N(Thicc+size,MagZ,Thicc+size)
			prt.CFrame = CF.N(Last.CFrame*CF.N(0,-SegLength/2,0).p,EndPos)*CF.A(M.R(90),0,0)*CF.N(0,-MagZ/2,0)	
		elseif(not Last)then
			prt.CFrame = CF.N(StartPos,pos)*CF.A(M.R(90),0,0)*CF.N(0,-SegLength/2,0)	
		else
			prt.CFrame = CF.N(Last.CFrame*CF.N(0,-SegLength/2,0).p,CF.N(pos)*CF.A(M.R(M.RNG(0,360)),M.R(M.RNG(0,360)),M.R(M.RNG(0,360)))*CF.N(0,0,SegLength/3+(segments-i)).p)*CF.A(M.R(90),0,0)*CF.N(0,-SegLength/2,0)
		end
		Last = prt
		if(Branch)then
			local choice = M.RNG(1,7+((segments-i)*2))
			if(choice == 1)then
				local LastB;
				for i2 = 1,M.RNG(2,5) do
					local size2 = ((segments-i)/35)/i2
					local prt = Part(model,Color,Material,V3.N(Thicc+size2,SegLength,Thicc+size2),CF.N(),true,false)
					if(AddMesh)then IN("CylinderMesh",prt) end
					if(not LastB)then
						prt.CFrame = CF.N(Last.CFrame*CF.N(0,-SegLength/2,0).p,Last.CFrame*CF.N(0,-SegLength/2,0)*CF.A(0,0,M.RRNG(0,360))*CF.N(0,Thicc*7,0)*CF.N(0,0,-1).p)*CF.A(M.R(90),0,0)*CF.N(0,-SegLength/2,0)
					else
						prt.CFrame = CF.N(LastB.CFrame*CF.N(0,-SegLength/2,0).p,LastB.CFrame*CF.N(0,-SegLength/2,0)*CF.A(0,0,M.RRNG(0,360))*CF.N(0,Thicc*7,0)*CF.N(0,0,-1).p)*CF.A(M.R(90),0,0)*CF.N(0,-SegLength/2,0)
					end
					LastB = prt
				end
			end
		end
	end
	if(Fades > 0)then
		coroutine.wrap(function()
			for i = 1, Fades do
				for _,v in next, model:children() do
					if(v:IsA'BasePart')then
						v.Transparency = (i/Fades)
					end
				end
				swait()
			end
			model:destroy()
		end)()
	else
		S.Debris:AddItem(model,.01)
	end
	return {End=(Last and Last.CFrame*CF.N(0,-Last.Size.Y/2,0).p),Last=Last,Model=model}
end

function Tween(obj,props,time,easing,direction,repeats,backwards)
	local info = TweenInfo.new(time or .5, easing or Enum.EasingStyle.Quad, direction or Enum.EasingDirection.Out, repeats or 0, backwards or false)
	local tween = S.TweenService:Create(obj, info, props)
	
	tween:Play()
end

function OEffect(data)
	local FX = data.Effect or 'ResizeAndFade'
	local Parent = data.Parent or Effects
	local Color = data.Color or C3.N(0,0,0)
	local Size = data.Size or V3.N(1,1,1)
	local MoveDir = data.MoveDirection or nil
	local MeshData = data.Mesh or nil
	local SndData = data.Sound or nil
	local Frames = data.Frames or 45
	local Manual = data.Manual or nil
	local Material = data.Material or nil
	local CFra = data.CFrame or Torso.CFrame
	local Settings = data.FXSettings or {}
	local Shape = data.Shape or Enum.PartType.Block
	local Snd,Prt,Msh;
	local RotInc = data.RotInc or {0,0,0}
	if(typeof(RotInc) == 'number')then
		RotInc = {RotInc,RotInc,RotInc}
	end
	coroutine.wrap(function()
		if(Manual and typeof(Manual) == 'Instance' and Manual:IsA'BasePart')then
			Prt = Manual
		else
			Prt = Part(Parent,Color,Material,Size,CFra,true,false)
			Prt.Shape = Shape
		end
		if(typeof(MeshData) == 'table')then
			Msh = Mesh(Prt,MeshData.MeshType,MeshData.MeshId,MeshData.TextureId,MeshData.Scale,MeshData.Offset)
		elseif(typeof(MeshData) == 'Instance')then
			Msh = MeshData:Clone()
			Msh.Parent = Prt
		elseif(Shape == Enum.PartType.Block)then
			Msh = Mesh(Prt,Enum.MeshType.Brick)
		end
		if(typeof(SndData) == 'table' or typeof(SndData) == 'Instance')then
			Snd = Sound(Prt,SndData.SoundId,SndData.Pitch,SndData.Volume,false,false,true)
		end
		if(Snd)then
			repeat swait() until Snd.Playing and Snd.IsLoaded and Snd.TimeLength > 0
			Frames = Snd.TimeLength * Frame_Speed/Snd.Pitch
		end
		Size = (Msh and Msh.Scale or Size)
		local grow = Size-(Settings.EndSize or (Msh and Msh.Scale or Size)/2)
		
		local MoveSpeed = nil;
		if(MoveDir)then
			MoveSpeed = (CFra.p - MoveDir).magnitude/Frames
		end
		if(FX ~= 'Arc')then
			for Frame = 1, Frames do
				if(FX == "Fade")then
					Prt.Transparency  = (Frame/Frames)
				elseif(FX == "Resize")then
					if(not Settings.EndSize)then
						Settings.EndSize = V3.N(0,0,0)
					end
					if(Settings.EndIsIncrement)then
						if(Msh)then
							Msh.Scale = Msh.Scale + Settings.EndSize
						else
							Prt.Size = Prt.Size + Settings.EndSize
						end					
					else
						if(Msh)then
							Msh.Scale = Msh.Scale - grow/Frames
						else
							Prt.Size = Prt.Size - grow/Frames
						end
					end 
				elseif(FX == "ResizeAndFade")then
					if(not Settings.EndSize)then
						Settings.EndSize = V3.N(0,0,0)
					end
					if(Settings.EndIsIncrement)then
						if(Msh)then
							Msh.Scale = Msh.Scale + Settings.EndSize
						else
							Prt.Size = Prt.Size + Settings.EndSize
						end					
					else
						if(Msh)then
							Msh.Scale = Msh.Scale - grow/Frames
						else
							Prt.Size = Prt.Size - grow/Frames
						end
					end 
					Prt.Transparency = (Frame/Frames)
				end
				if(Settings.RandomizeCFrame)then
					Prt.CFrame = Prt.CFrame * CF.A(M.RRNG(-360,360),M.RRNG(-360,360),M.RRNG(-360,360))
				else
					Prt.CFrame = Prt.CFrame * CF.A(unpack(RotInc))
				end
				if(MoveDir and MoveSpeed)then
					local Orientation = Prt.Orientation
					Prt.CFrame = CF.N(Prt.Position,MoveDir)*CF.N(0,0,-MoveSpeed)
					Prt.Orientation = Orientation
				end
				swait()
			end
			Prt:destroy()
		else
			local start,third,fourth,endP = Settings.Start,Settings.Third,Settings.Fourth,Settings.End
			if(not Settings.End and Settings.Home)then endP = Settings.Home.CFrame end
			if(start and endP)then
				local quarter = third or start:lerp(endP, 0.25) * CF.N(M.RNG(-25,25),M.RNG(0,25),M.RNG(-25,25))
				local threequarter = fourth or start:lerp(endP, 0.75) * CF.N(M.RNG(-25,25),M.RNG(0,25),M.RNG(-25,25))
				for Frame = 0, 1, (Settings.Speed or 0.01) do
					if(Settings.Home)then
						endP = Settings.Home.CFrame
					end
					Prt.CFrame = Bezier(start, quarter, threequarter, endP, Frame)
				end
				if(Settings.RemoveOnGoal)then
					Prt:destroy()
				end
			else
				Prt:destroy()
				assert(start,"You need a start position!")
				assert(endP,"You need a start position!")
			end
		end
	end)()
	return Prt,Msh,Snd
end

function Effect(data)
	local Color = data.Color or C3.N(0,0,0)
	local Material = data.Material or Enum.Material.Neon;
	local MeshD = data.Mesh or {};
	local SoundD = data.Sound or nil;
	local Shape = data.Shape or Enum.PartType.Block;
	local Size = data.StartSize or V3.N(.1,.1,.1);
	local ESize = data.EndSize or V3.N(6,6,6);
	local Direction = data.Direction or nil;
	local Speed = data.Speed or .1; -- studs per second
	local Boomerang = data.Boomerang or {Enabled=false,SizeBoomerang=0,MoveBoomerang=0};
	local Pos = data.CFrame or Torso.CFrame;
	local Frames = data.Frames or 60;
	local RotInc = data.RotInc or {0,0,0}
	local StartTrans = data.TransStart or 0;
	local EndTrans = data.TransEnd or 1;
	
	if(typeof(RotInc) == 'number')then RotInc = {RotInc,RotInc,RotInc}; end
	local S,PM,P;
	
	coroutine.wrap(function()
		P = Part(Effects,Color,Material,V3.N(1,1,1),Pos,true,false)
		
		if(MeshD == "Blast")then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://20329976','',Size,V3.N(0,0,-Size.X/8))
		elseif(MeshD == 'Ring')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://559831844','',Size,V3.N(0,0,0))
		elseif(MeshD == 'Slash1')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://662586858','',V3.N(Size.X/10,.001,Size.Z/10),V3.N(0,0,0))
		elseif(MeshD == 'Slash2')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://448386996','',V3.N(Size.X/1000,Size.Y/100,Size.Z/100),V3.N(0,0,0))
		elseif(MeshD == 'Slash3')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://4770583','',Size,V3.N(0,0,0))
		elseif(MeshD == 'Tornado1')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://443529437','',Size/10,V3.N(0,0,0))
		elseif(MeshD == 'Tornado2')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://168892432','',Size/4,V3.N(0,0,0))
		elseif(MeshD == 'Skull')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://4770583','',Size*2,V3.N(0,0,0))
		elseif(MeshD == 'Crystal')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://9756362','',Size,V3.N(0,0,0))
		elseif(MeshD == 'Cloud')then
			PM = Mesh(P,Enum.MeshType.FileMesh,'rbxassetid://1095708','',Size,V3.N(0,0,0))
		elseif(typeof(MeshD) == 'table')then
			local Type = MeshD.Type or Enum.MeshType.Brick
			local ID = MeshD.ID or '';
			local Tex = MeshD.Texture or '';
			local Offset = MeshD.Offset or V3.N(0,0,0)
			PM = Mesh(P,Type,ID,Tex,Size,Offset)
		else
			PM = Mesh(P,Enum.MeshType.Brick,'','',Size)
		end
		
		if(typeof(SoundD) == 'table')then
			local ID = SoundD.ID or '';
			local Pitch = SoundD.Pitch or 1;
			local Volume = SoundD.Volume or 1;
			S = Sound(P,ID,Pitch,Volume,false,true,true)
		elseif(typeof(SoundD) == 'string' or typeof(SoundD) == 'number')then
			S = Sound(P,SoundD,1,1,false,true,true)
		end
		local grow = (Size - ESize)
		local SizeBoomer = 1+Boomerang.SizeBoomerang/50
		local MoveBoomer = 1+Boomerang.MoveBoomerang/50
		if(Boomerang and Boomerang.Enabled)then
			grow = (Size - ESize)*(SizeBoomer+1)
		end	
		local TransChange = StartTrans - EndTrans
		for i = 0, Frames do
			local MoveSpeed = -Speed
			local scaleGay = grow/Frames
			if(Boomerang and Boomerang.Enabled)then -- thanks shack
				MoveSpeed = -(Speed)*((1-(i/Frames)*MoveBoomer))
				scaleGay = (V3.N((grow.X)*((1 - (i/Frames)*SizeBoomer)),(grow.Y)*((1 - (i/Frames)*SizeBoomer)),(grow.Z)*((1 - (i/Frames)*SizeBoomer)))*SizeBoomer)/Frames
			end
			if(PM.MeshId == 'rbxassetid://20329976')then
				PM.Offset = V3.N(0,0,-PM.Scale.Z/8)
			elseif(PM.MeshId == 'rbxassetid://4770583')then
				scaleGay = scaleGay*2
			elseif(PM.MeshId == 'rbxassetid://168892432')then
				scaleGay = scaleGay/4
			elseif(PM.MeshId == 'rbxassetid://443529437')then
				scaleGay = scaleGay/10
			elseif(PM.MeshId == 'rbxassetid://443529437')then
				scaleGay = scaleGay/10
			end
			PM.Scale = PM.Scale - scaleGay
			P.Transparency = P.Transparency - TransChange/Frames
			if(RotInc == 'random')then
				P.CFrame=P.CFrame*CF.A(M.RRNG(-180,180),M.RRNG(-180,180),M.RRNG(-180,180))
			elseif(typeof(RotInc) == 'table')then
				P.CFrame=P.CFrame*CF.A(unpack(RotInc))
			end
			
			
			if(Direction and Speed)then
				local Orientation = P.Orientation
				P.CFrame = CF.N(P.Position,Direction.p)*CF.N(0,0,MoveSpeed)
				P.Orientation = Orientation
			end
			swait()
		end

		P.Transparency = 1
		if(S and S.Playing)then
			repeat swait() until not S.Parent or not S.Playing
		end
		if(S and S.Parent)then
			S:destroy()
		end
	end)()
	
	
end


--if(not Plr:IsFriendsWith(5719877))then warn("You aren't whitelisted, dumbass.") warn("Why did you even try?")script.Disabled = true repeat until nil end

function SoulSteal(whom)
	local torso = (whom:FindFirstChild'Head' or whom:FindFirstChild'Torso' or whom:FindFirstChild'UpperTorso' or whom:FindFirstChild'LowerTorso' or whom:FindFirstChild'HumanoidRootPart')
	print(torso)
	if(torso and torso:IsA'BasePart')then
		local Model = Instance.new("Model",Effects)
		Model.Name = whom.Name.."'s Soul"
		whom:BreakJoints()
		local Soul = Part(Model,BrickColor.new'Really red','Glass',V3.N(.5,.5,.5),torso.CFrame,true,false)
		Soul.Name = 'Head'
		NewInstance("Humanoid",Model,{Health=0,MaxHealth=0})
		OEffect{
			Effect="Arc",
			Manual = Soul,
			FXSettings={
				Start=torso.CFrame,
				Home = Torso,
				RemoveOnGoal = true,
			}
		}
		local lastPoint = Soul.CFrame.p
	
		for i = 0, 1, 0.01 do 
				local point = CFrame.new(lastPoint, Soul.Position) * CFrame.Angles(-math.pi/2, 0, 0)
				local mag = (lastPoint - Soul.Position).magnitude
				OEffect{
					Effect = "Fade",
					CFrame = point * CF.N(0, mag/2, 0),
					Size = V3.N(.5,mag+.5,.5),
					Color = Soul.BrickColor
				}
				lastPoint = Soul.CFrame.p
			swait()
		end
		for i = 1, 5 do
			OEffect{
				Effect="Fade",
				Color = BrickColor.new'Really red',
				MoveDirection = (Torso.CFrame*CFrame.new(M.RNG(-40,40),M.RNG(-40,40),M.RNG(-40,40))).p
			}	
		end
	end
end

--// Other Functions \\ --

function CastRay(startPos,endPos,range,ignoreList)
	local ray = Ray.new(startPos,(endPos-startPos).unit*range)
	local part,pos,norm = workspace:FindPartOnRayWithIgnoreList(ray,ignoreList or {Char},false,true)
	return part,pos,norm,(pos and (startPos-pos).magnitude)
end

function getRegion(point,range,ignore)
    return workspace:FindPartsInRegion3WithIgnoreList(R3.N(point-V3.N(1,1,1)*range/2,point+V3.N(1,1,1)*range/2),ignore,100)
end

function clerp(startCF,endCF,alpha)
	return startCF:lerp(endCF, alpha)
end

function GetTorso(char)
	return char:FindFirstChild'Torso' or char:FindFirstChild'UpperTorso' or char:FindFirstChild'LowerTorso' or char:FindFirstChild'HumanoidRootPart'
end


function ShowDamage(Pos, Text, Time, Color)
	coroutine.wrap(function()
	local Rate = (1 / Frame_Speed)
	local Pos = (Pos or Vector3.new(0, 0, 0))
	local Text = (Text or "")
	local Time = (Time or 2)
	local Color = (Color or Color3.new(1, 0, 1))
	local EffectPart = NewInstance("Part",Effects,{
		Material=Enum.Material.SmoothPlastic,
		Reflectance = 0,
		Transparency = 1,
		BrickColor = BrickColor.new(Color),
		Name = "Effect",
		Size = Vector3.new(0,0,0),
		Anchored = true,
		CFrame = CF.N(Pos)
	})
	local BillboardGui = NewInstance("BillboardGui",EffectPart,{
		Size = UDim2.new(1.25, 0, 1.25, 0),
		Adornee = EffectPart,
	})
	local TextLabel = NewInstance("TextLabel",BillboardGui,{
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		Text = Text,
		Font = "Bodoni",
		TextColor3 = Color,
		TextStrokeColor3 = Color3.new(0,0,0),
		TextStrokeTransparency=0,
		TextScaled = true,
	})
	S.Debris:AddItem(EffectPart, (Time))
	EffectPart.Parent = workspace
	delay(0, function()
		Tween(EffectPart,{CFrame=CF.N(Pos)*CF.N(0,3,0)},Time,Enum.EasingStyle.Elastic,Enum.EasingDirection.Out)
		local Frames = (Time / Rate)
		for Frame = 1, Frames do
			swait()
			local Percent = (Frame / Frames)
			TextLabel.TextTransparency = Percent
			TextLabel.TextStrokeTransparency = Percent
		end
		if EffectPart and EffectPart.Parent then
			EffectPart:Destroy()
		end
	end) end)()
end


function DealDamage(data)
	local Who = data.Who;
	local MinDam = data.MinimumDamage or 15;
	local MaxDam = data.MaximumDamage or 30;
	local MaxHP = data.MaxHP or 1e5; 
	
	local DB = data.Debounce or .2;
	
	local CritData = data.Crit or {}
	local CritChance = CritData.Chance or 0;
	local CritMultiplier = CritData.Multiplier or 1;
	
	local DamageEffects = data.DamageFX or {}
	local DamageType = DamageEffects.Type or "Normal"
	local DeathFunction = DamageEffects.DeathFunction
	
	assert(Who,"Specify someone to damage!")	
	
	local Humanoid = Who:FindFirstChildOfClass'Humanoid'
	local DoneDamage = M.RNG(MinDam,MaxDam) * (M.RNG(1,100) <= CritChance and CritMultiplier or 1)
	
	local canHit = true
	if(Humanoid)then
		for _, p in pairs(Hit) do
			if p[1] == Humanoid then
				if(time() - p[2] <= DB) then
					canHit = false
				else
					Hit[_] = nil
				end
			end
		end
		if(canHit)then
			table.insert(Hit,{Humanoid,time()})
			local HitTorso = GetTorso(Who)
			local player = S.Players:GetPlayerFromCharacter(Who)
			if(not player or not DontAttackPlayers and player.UserId ~= 5719877 and player.UserId ~= 61573184 and player.UserId ~= 19081129)then
				if(Humanoid.MaxHealth >= MaxHP and Humanoid.Health > 0)then
					print'Got kill'
					Hits = math.min(Hits + 1,MaxHits)
					HitTime = time() + 1
					--Humanoid.Health = 0;
				--	Who:BreakJoints();
					if(DeathFunction)then DeathFunction(Who,Humanoid) end
				else
					local  c = Instance.new("ObjectValue",Hum)
					c.Name = "creator"
					c.Value = Player
					S.Debris:AddItem(c,0.35)
					if(Hits >= MaxHits/4)then
						local Mult = (DoneDamage*(Hits/MaxHits))/2
						--DoneDamage = DoneDamage + Mult
					end
					if(Humanoid.Health > 0)then	
						Hits = math.min(Hits + 1,MaxHits)
						HitTime = time() + 1
						if(Mode == 9 and not Radioactive[Who])then
							Radioactive[Who] = {0,M.RNG(time()+4,time()+14)}
						end
						if(Who:FindFirstChild'Head')then
						--	ShowDamage((Who.Head.CFrame * CF.N(0, 0, (Who.Head.Size.Z / 2)).p+V3.N(0,1.5,0)+V3.N(M.RNG(-2,2),0,M.RNG(-2,2))), math.floor(DoneDamage), 1.5, Core2.Color)
						end
						if(Humanoid.Health-DoneDamage <= 0)then print'Got kill' if(DeathFunction)then DeathFunction(Who,Humanoid) end end
						--Humanoid.Health = Humanoid.Health - DoneDamage
					end
					
					if(DamageType == 'Knockback' and HitTorso)then
						local up = DamageEffects.KnockUp or 25
						local back = DamageEffects.KnockBack or 25
						local origin = DamageEffects.Origin or Root
						local decay = DamageEffects.Decay or .5;
						
						local bfos = Instance.new("BodyVelocity",HitTorso)
						bfos.P = 20000	
						bfos.MaxForce = Vector3.new(math.huge,math.huge,math.huge)
						bfos.Velocity = Vector3.new(0,up,0) + (origin.CFrame.lookVector * back)
						S.Debris:AddItem(bfos,decay)
					end
				end
			end
		end
	end		
end

function AOEDamage(where,range,options)
	local hit = {}
	for _,v in next, getRegion(where,range,{Char}) do
		if(v.Parent and v.Parent:FindFirstChildOfClass'Humanoid' and not hit[v.Parent])then
			local callTable = {Who=v.Parent}
			hit[v.Parent] = true
			for _,v in next, options do callTable[_] = v end
			--DealDamage(callTable)
		end
	end
	return hit
end

function AOEHeal(where,range,amount)
	local healed = {}
	for _,v in next, getRegion(where,range,{Char}) do
		local hum = (v.Parent and v.Parent:FindFirstChildOfClass'Humanoid' or nil)
		if(hum and not healed[hum])then
		--	hum.Health = hum.Health + amount
			if(v.Parent:FindFirstChild'Head' and hum.Health > 0)then
				--ShowDamage((v.Parent.Head.CFrame * CF.N(0, 0, (v.Parent.Head.Size.Z / 2)).p+V3.N(0,1.5,0)), "+"..amount, 1.5, BrickColor.new'Lime green'.Color)
			end
		end
	end
end

--// Chat Function \\--

function Chat(text,color)
	--if(game.PlaceId ~= 843468296)then
		coroutine.wrap(function()
			if(Char:FindFirstChild'ChatGUI')then Char.ChatGUI:destroy() end
			local BBG = NewInstance("BillboardGui",Char,{Name='ChatGUI',Size=UDim2.new(0,100,0,40),StudsOffset=V3.N(0,2,0),Adornee=Head})
			local Txt = NewInstance("TextLabel",BBG,{Text = "",BackgroundTransparency=1,TextColor3=color,BorderSizePixel=0,Font=Enum.Font.Antique,TextSize=50,TextStrokeTransparency=1,Size=UDim2.new(1,0,.5,0)})
			local SND = Sound(Head,418252437,M.RNG(9,11)/10,3,false,false,true)
			for i = 1, #text do
				delay(i/25, function()
					SND.Pitch = M.RNG(9,11)/10
					SND.Volume = 3
					SND.Parent = Effects
					SND:Play()
					Txt.Text = text:sub(1,i)
				end)
			end
			delay((#text/25)+2.5, function()
				for i = 0, 1, .025 do
					Txt.TextTransparency=i
					Txt.Rotation = M.RNG(-25,25)
					Txt.Position = UDim2.new(0,M.RNG(-15,15),0,M.RNG(-15,15))
					swait()
				end
				BBG:destroy()
			end)
		end)()
	--else
	--	Chat2(text)
	--end
end

--// Everything else \\--

function ClickGlitch()
	Attack = true
	NeutralAnims = false
	local oWS = WalkSpeed
	WalkSpeed = 0
	Hum.JumpPower = 0
	Hum.AutoRotate = false
	Root.CFrame = CF.N(Root.CFrame.p,CF.N(Mouse.Hit.x,Root.CFrame.y,Mouse.Hit.z).p)
	for i = 0, 2, 0.1 do
		swait()
		local Alpha = .3
		Root.CFrame = CF.N(Root.CFrame.p,CF.N(Mouse.Hit.x,Root.CFrame.y,Mouse.Hit.z).p)
		RJ.C0 = clerp(RJ.C0,CFrame.new(-0.00417825999, 0.00628786907, -0.00260206894, 0.513858557, -0.00539401267, -0.857858002, 1.84496116e-06, 0.99998033, -0.00628653914, 0.85787499, 0.00322880922, 0.513848424),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.496490777, -0.990816116, 0.0216251202, 0.500402868, 0, 0.865792811, -0.00544379698, 0.99998033, 0.00314635527, -0.865775645, -0.00628764462, 0.500392973),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.49852562, -0.990978837, 0.0154569345, 0.500402868, 0, 0.865792811, -0.00544379698, 0.99998033, 0.00314635527, -0.865775645, -0.00628764462, 0.500392973),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.30906916, 0.822547674, -0.226739705, -0.481323838, 0.719669759, -0.500402868, -0.832959116, -0.55330795, 0.00544379698, -0.272959113, 0.419435322, 0.865775645),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.35554826, 0.564801514, -0.116690002, 0.84398663, -0.312275827, 0.436085641, 0.311970115, 0.94716835, 0.074478887, -0.43630439, 0.0731864721, 0.896817923),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(-7.85058364e-06, 1.49894369, -0.0143952277, 0.500402868, 0, 0.865792811, -0.00544379698, 0.99998033, 0.00314635527, -0.865775645, -0.00628764462, 0.500392973),Alpha)
	end
	Sound(LArm,217767125,M.RNG(75,125)/100,10,false,true,true)
	OEffect{
		Effect='Fade',
		Size=V3.N(1,1,1),
		CFrame=LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360)),
		Color=Core2.Color,
		Material=Enum.Material.Neon,
		FXSettings = {
			RandomizeCFrame=true
		}
	}
	coroutine.wrap(function()
		local MousePos = Mouse.Hit
		local effect = Part(Effects,Core2.Color,Enum.Material.Neon,V3.N(2.5,2.5,2.5),MousePos,true,false)
		for i = 0, 6, .1 do
			effect.Color = Core2.Color
			MousePos = MousePos * CF.N(M.RNG(-15,15)/100,M.RNG(-15,15)/100,M.RNG(-15,15)/100)
			effect.CFrame = MousePos*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360))
			effect.Size = V3.N(2.5,2.5,2.5)+V3.N(M.RNG(-150,150)/100,M.RNG(-150,150)/100,M.RNG(-150,150)/100)
			swait()
		end
		AOEDamage(MousePos.p,30,{MinimumDamage=30,MaximumDamage=75})
		for i = 0, 3, .1 do
			effect.Color = Core2.Color
			effect.CFrame = MousePos*CF.A(M.RRNG(0,360),M.RRNG(0,360),M.RRNG(0,360))
			effect.Size = effect.Size + V3.N(1,1,1)
			effect.Transparency = i/3
			swait()
		end
		effect:destroy()
		
	end)()
	for i = 0, 1, 0.1 do
		swait()
		local Alpha = .3
		RJ.C0 = clerp(RJ.C0,CFrame.new(-0.00417744182, 0.00628787512, -0.00260255905, 0.513858557, -0.00539401267, -0.857858002, 1.84496116e-06, 0.99998033, -0.00628653914, 0.85787499, 0.00322880922, 0.513848424),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.496490777, -0.990816116, 0.0216251202, 0.500402868, 0, 0.865792811, -0.00544379698, 0.99998033, 0.00314635527, -0.865775645, -0.00628764462, 0.500392973),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.49852562, -0.990978837, 0.0154569345, 0.500402868, 0, 0.865792811, -0.00544379698, 0.99998033, 0.00314635527, -0.865775645, -0.00628764462, 0.500392973),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.12360537, 0.516349316, -0.117619619, -0.715893924, 0.486921966, -0.500402868, -0.56499064, -0.825079441, 0.00544379698, -0.410221368, 0.28662011, 0.865775645),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.35554826, 0.564801514, -0.116690002, 0.84398663, -0.312275827, 0.436085641, 0.311970115, 0.94716835, 0.074478887, -0.43630439, 0.0731864721, 0.896817923),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(-7.85058364e-06, 1.49894369, -0.0143952277, 0.500402868, 0, 0.865792811, -0.00544379698, 0.99998033, 0.00314635527, -0.865775645, -0.00628764462, 0.500392973),Alpha)
	end
	for i = 0, 1, 0.1 do
		swait()
		local Alpha = .3
		RJ.C0 = clerp(RJ.C0,CFrame.new(-0.00417825999, 0.00628786907, -0.00260206894, 0.513858557, -0.00539401267, -0.857858002, 1.84496116e-06, 0.99998033, -0.00628653914, 0.85787499, 0.00322880922, 0.513848424),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.496490777, -0.990816116, 0.0216251202, 0.500402868, 0, 0.865792811, -0.00544379698, 0.99998033, 0.00314635527, -0.865775645, -0.00628764462, 0.500392973),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.49852562, -0.990978837, 0.0154569345, 0.500402868, 0, 0.865792811, -0.00544379698, 0.99998033, 0.00314635527, -0.865775645, -0.00628764462, 0.500392973),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.30906916, 0.822547674, -0.226739705, -0.481323838, 0.719669759, -0.500402868, -0.832959116, -0.55330795, 0.00544379698, -0.272959113, 0.419435322, 0.865775645),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.35554826, 0.564801514, -0.116690002, 0.84398663, -0.312275827, 0.436085641, 0.311970115, 0.94716835, 0.074478887, -0.43630439, 0.0731864721, 0.896817923),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(-7.85058364e-06, 1.49894369, -0.0143952277, 0.500402868, 0, 0.865792811, -0.00544379698, 0.99998033, 0.00314635527, -0.865775645, -0.00628764462, 0.500392973),Alpha)
	end
	WalkSpeed = oWS
	Hum.JumpPower = 50
	Hum.AutoRotate = true
	Attack = false
	NeutralAnims = true
end

function PureBomb()
	Attack = true
	NeutralAnims = false
	local orb = Part(Effects,BrickColor.new'Baby blue',Enum.Material.Neon,V3.N(1,1,1),RArm.CFrame*CF.N(0,-1,0),true,false)
	local orbM = Mesh(orb,Enum.MeshType.Sphere,"","",V3.N(.1,.1,.1))
	local Scale = 0.1
	local Pos = 0
	Hum.AutoRotate = false
	Sound(orb,136007472,1,5,false,true,true)
	for i = 0, 10, 0.1 do
		Scale = Scale + .05
		orb.CFrame = RArm.CFrame*CF.N(0,-0.5-(Scale/1.5),0)
		Root.CFrame = CF.N(Root.CFrame.p,CF.N(Mouse.Hit.x,Root.CFrame.y,Mouse.Hit.z).p)
		orbM.Scale = V3.N(Scale,Scale,Scale)
		NoobySphere(4,-.1,'Multiply',orb.CFrame*CF.A(M.RRNG(-180,180),M.RRNG(-180,180),M.RRNG(-180,180)),V3.N(1,1,1),0,BrickColor.new'Baby blue',5)
		swait()
		local Alpha = .3
		RJ.C0 = clerp(RJ.C0,CFrame.new(2.74447132e-13, 0.00628674263, 4.19029675e-07, 0.99999994, 4.36557457e-11, 0, -4.3652193e-11, 0.999980211, -0.00628619269, 9.31322575e-10, 0.00628619175, 0.999980271),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.49648428, -0.990819931, 0.0216189958, 0.999878109, -9.59694546e-11, 0.015612145, -9.81408521e-05, 0.999980211, 0.00628542574, -0.0156118376, -0.00628619269, 0.999858439),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.498537898, -0.990974903, 0.0154631026, 0.999878109, -9.59694546e-11, 0.015612145, -9.81408521e-05, 0.999980211, 0.00628542574, -0.0156118376, -0.00628619269, 0.999858439),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.42302692, 0.493415803, -0.00359773822, 0.940765917, 0.153064445, 0.30254063, -0.162465662, 0.986695945, 0.00599612948, -0.297597915, -0.0547934212, 0.953117669),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.49654758, 0.678199768, 0.0230993181, 0.85657078, -0.45250088, 0.248051316, -0.450519741, -0.89016372, -0.0681223199, 0.251631737, -0.0534004271, -0.966348767),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(1.00737716e-05, 1.49894738, -0.0144004971, 0.99999994, 3.67523171e-07, -1.61118805e-07, -3.56500095e-07, 0.997964799, 0.0637688041, 1.8440187e-07, -0.063768819, 0.997964799),Alpha)
	end
	for i = 0, 2, 0.1 do
		swait()
		orb.CFrame = RArm.CFrame*CF.N(0,-0.5-(Scale/1.5),0)
		Root.CFrame = CF.N(Root.CFrame.p,CF.N(Mouse.Hit.x,Root.CFrame.y,Mouse.Hit.z).p)
		local Alpha = .3
		RJ.C0 = clerp(RJ.C0,CFrame.new(-0.00196742709, 0.00628469, -0.000496770546, 0.917528987, -0.00250149658, -0.39766106, 8.55154781e-07, 0.999980211, -0.00628842553, 0.397668958, 0.00576947257, 0.917510867),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.496482432, -0.990816116, 0.0216121897, 0.911208749, 0, 0.411944896, -0.00259129796, 0.999980211, 0.00573186669, -0.41193673, -0.006290399, 0.911190748),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.4985466, -0.990978718, 0.0154598281, 0.911208749, 0, 0.411944896, -0.00259129796, 0.999980211, 0.00573186669, -0.41193673, -0.006290399, 0.911190748),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.49955761, 0.50005585, 0.0206508823, 0.931618989, 0, 0.363436669, -0.00228616199, 0.999980211, 0.0058602551, -0.363429457, -0.006290399, 0.931600571),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.42403603, 0.783231854, 0.129635245, 0.955871105, -0.233268648, 0.178595126, -0.293628395, -0.738623917, 0.60680896, -0.00963485241, -0.63247174, -0.774523556),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(3.81190921e-06, 1.49893928, -0.0144081786, 1, -1.86264515e-09, 0, 0, 0.99796468, 0.0637704432, 2.98023224e-08, -0.0637704507, 0.997964561),Alpha)
	end
	Sound(Root,260433768,1,5.25,false,true,true)
	ShootBullet{Size=V3.N(Scale,Scale,Scale),Shape='Ball',Frames=320,Origin=orb.CFrame,Speed=5,Color=BrickColor.new'Baby blue',HitFunction = function(hit,pos)
		local snd, part = SoundPart(151304356,1,5.25,false,true,true,CF.N(pos))
		AOEDamage(pos,Scale*4,{MinimumDamage=25,MaximumDamage=60})
		OEffect{
			Effect='ResizeAndFade',
			Color=BrickColor.new'Baby blue',
			Size=V3.N(Scale*2,Scale*2,Scale*2),
			Material=Enum.Material.Neon,
			Mesh={MeshType=Enum.MeshType.Sphere},
			CFrame=CF.N(pos),
			FXSettings={
				EndSize=V3.N(.1,.1,.1),
				EndIsIncrement=true
			}
		}
		OEffect{
			Effect='ResizeAndFade',
			Color=BrickColor.new'Pastel light blue',
			Size=V3.N(Scale*1.5,Scale*1.5,Scale*1.5),
			Material=Enum.Material.Neon,
			Mesh={MeshType=Enum.MeshType.Sphere},
			CFrame=CF.N(pos),
			FXSettings={
				EndSize=V3.N(.1,.1,.1),
				EndIsIncrement=true
			}
		}
		for i = 0, 49 do
			NoobyBlock(1,M.RNG(1,10)/2,"Multiply",CF.N(pos)*CF.A(M.RRNG(-360,360),M.RRNG(-360,360),M.RRNG(-360,360)),V3.N(4,4,4),0.08,BrickColor.new('Pastel light blue'),0,true)
		end
		for i = 0, 9 do
			NoobySphere(1,2.5,"Multiply",CF.N(pos)*CF.A(M.RRNG(-360,360),M.RRNG(-360,360),M.RRNG(-360,360)),V3.N(5,5,50),-0.05,BrickColor.new'Baby blue',0)
			NoobySphere(2,5,"Multiply",CF.N(pos)*CF.A(M.RRNG(-360,360),M.RRNG(-360,360),M.RRNG(-360,360)),V3.N(5,5,50),-0.05,BrickColor.new'Pastel light blue',0)
		end
	end}
	orb:destroy()
	for i = 0, 1, 0.1 do
		swait()
		Root.CFrame = CF.N(Root.CFrame.p,CF.N(Mouse.Hit.x,Root.CFrame.y,Mouse.Hit.z).p)
		local Alpha = .3
		RJ.C0 = clerp(RJ.C0,CFrame.new(-0.00500682555, 0.00628831051, 0.00120097224, 0.92018038, 0.00246177102, 0.391486853, -8.42089548e-07, 0.99998033, -0.0062861559, -0.391494602, 0.00578406826, 0.920162261),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.498779386, -1.00248599, -0.124541134, 0.959937453, -0.00228470936, 0.280205488, -0.0405473076, 0.988310218, 0.146966696, -0.277265698, -0.152440399, 0.94862318),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.539460897, -1.00021362, -0.107664183, 0.949007154, 0.0409194157, -0.312587768, 0.00198236411, 0.990746439, 0.135712415, 0.31524843, -0.129411712, 0.940144241),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.41884661, 0.577570677, -0.000329867005, 0.959363103, 0.138315558, 0.245949864, -0.144226983, 0.989526033, 0.00609558355, -0.242530614, -0.041320473, 0.969263554),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.3995322, 0.560555339, 0.0217598975, 0.860549986, -0.340243995, 0.379061729, 0.396351576, -0.0201387759, -0.917877972, 0.319936305, 0.940121651, 0.117525801),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(-1.91013669e-06, 1.4989413, -0.0144026726, 1, -1.86264515e-09, 0, 2.32830644e-10, 0.997965097, 0.0637654439, -2.98023224e-08, -0.0637654439, 0.997965038),Alpha)
	end
	
	Hum.AutoRotate = true
	
	Attack = false
	NeutralAnims = true
end

function Aeroplane()
	Attack = true
	NeutralAnims = false
	NoobySphere2(3,'Multiply',Root.CFrame,V3.N(2,2,2),.5,BrickColor.new'White')
	local rad = 0
	for i = 0, 3, 0.1 do
		AOEDamage(Root.CFrame.p,4,{MinimumDamage=15,MaximumDamage=30})
		swait()
		Root.Velocity = Root.CFrame.lookVector*(350-(i*66))
		local Alpha = .3
		RJ.C0 = clerp(RJ.C0,CFrame.new(-0.00760343159, 1, -0.486851215, 0.99976027, -0.0157056805, -0.0152531685, 0.0156109696, 0.022916859, 0.99961555, -0.0153500848, -0.99961406, 0.0231565442),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.494159192, -0.989393592, 0.0215745792, 0.998326361, 0.0556856021, 0.0156117883, -0.0557892919, 0.998422861, 0.00628646836, -0.0152371004, -0.00714691728, 0.999858439),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.467966676, -0.990411818, 0.015948534, 0.997011065, -0.0756644681, 0.0156140458, 0.0755743459, 0.99712044, 0.00628457591, -0.0160446018, -0.00508577004, 0.999858439),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.48234439, 0.488731831, 0.0204298086, 1.08988024e-06, 0.999878109, 0.0156131675, -0.999979973, -9.79125834e-05, 0.00634019636, 0.00634095073, -0.0156128611, 0.999858081),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.44239902, 0.478527635, -0.0251723044, 0.000173310371, -0.999878168, 0.0156102739, 0.999979973, 0.00027231226, 0.00634019636, -0.00634367391, 0.0156088611, 0.999858141),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(5.21446054e-06, 1.48825693, 0.499068856, 1, -4.4076296e-07, 3.08027957e-05, 2.98316445e-05, 0.26330927, -0.964711607, -7.68547761e-06, 0.964711607, 0.26330927),Alpha)
	end
	for i = 0, 18, 0.1 do
		AOEDamage(Root.CFrame.p,4,{MinimumDamage=15,MaximumDamage=30})
		swait()
		rad = rad + .1
		local Alpha = .3
		Root.Velocity = Root.CFrame.lookVector*150
		RJ.C0 = clerp(RJ.C0,CFrame.new(-0.00760343159, 1, -0.486851215, 0.99976027, -0.0157056805, -0.0152531685, 0.0156109696, 0.022916859, 0.99961555, -0.0153500848, -0.99961406, 0.0231565442)*CF.A(0,M.R((rad*360)),0),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.494159192, -0.989393592, 0.0215745792, 0.998326361, 0.0556856021, 0.0156117883, -0.0557892919, 0.998422861, 0.00628646836, -0.0152371004, -0.00714691728, 0.999858439),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.467966676, -0.990411818, 0.015948534, 0.997011065, -0.0756644681, 0.0156140458, 0.0755743459, 0.99712044, 0.00628457591, -0.0160446018, -0.00508577004, 0.999858439),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.48234439, 0.488731831, 0.0204298086, 1.08988024e-06, 0.999878109, 0.0156131675, -0.999979973, -9.79125834e-05, 0.00634019636, 0.00634095073, -0.0156128611, 0.999858081),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.44239902, 0.478527635, -0.0251723044, 0.000173310371, -0.999878168, 0.0156102739, 0.999979973, 0.00027231226, 0.00634019636, -0.00634367391, 0.0156088611, 0.999858141),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(5.21446054e-06, 1.48825693, 0.499068856, 1, -4.4076296e-07, 3.08027957e-05, 2.98316445e-05, 0.26330927, -0.964711607, -7.68547761e-06, 0.964711607, 0.26330927),Alpha)
	end
	Attack = false
	NeutralAnims = true
end

function Shrek()
	Attack = true
	NeutralAnims = false
	local oWS = WalkSpeed
	for i = 0, 2, 0.1 do
		swait()
		local Alpha = .3
		RJ.C0 = RJ.C0:lerp(CFrame.new(-0.0045717326, 0.0650117323, -0.292746365, 0.999985039, -0.0054067187, -0.000930163078, 0.00540099945, 0.940456271, 0.339872152, -0.000962814316, -0.339872032, 0.940471232),Alpha)
		LH.C0 = LH.C0:lerp(CFrame.new(-0.497873425, -1.08922517, -0.0665005744, 0.991378665, 0.00540100131, 0.130918339, 0.0394607596, 0.940456986, -0.337614775, -0.124946497, 0.339870125, 0.932135701),Alpha)
		RH.C0 = RH.C0:lerp(CFrame.new(0.497141123, -1.09262908, -0.0732582211, 0.991080165, 0.00540100131, -0.133158669, -0.0502922162, 0.940456986, -0.336171925, 0.123414315, 0.339870125, 0.932339728),Alpha)
		LS.C0 = LS.C0:lerp(CFrame.new(-1.01297855, 0.687084556, -0.109048009, 0.909904242, -0.414624929, -0.0126772588, -0.341911346, -0.732326984, -0.588892102, 0.234885365, 0.540169775, -0.808112383),Alpha)
		RS.C0 = RS.C0:lerp(CFrame.new(1.10972738, 0.686874747, -0.142190307, 0.902195573, 0.431141198, -0.012677161, 0.341730058, -0.732411623, -0.588892102, -0.263180494, 0.526963592, -0.808112264),Alpha)
		NK.C0 = NK.C0:lerp(CFrame.new(1.14651302e-05, 1.49894774, -0.0143921971, 1.00000012, 1.31642446e-06, -5.17815351e-07, -1.28056854e-06, 0.997964919, 0.0637671649, 5.99771738e-07, -0.0637671053, 0.997964978),Alpha)
	end
	WalkSpeed = 0
	Sound(Head,368794903,1.2,10,false,true,true)
	local wo = IN("Model",Effects)
	
	for i = 1, 3 do
		local wat = 12.5+(i*2)
		local screamPart = Part(wo,BrickColor.new'Pearl',Enum.Material.Neon,V3.N(1,1,1),Head.CFrame,false,false)
		screamPart.Transparency = .6+(i/10)
		Mesh(screamPart,Enum.MeshType.Sphere,"","",V3.N(wat,wat,wat))
		Weld(screamPart,Torso)
	end
	
	for i = 0, 8, 0.1 do
		swait()
		AOEDamage(Torso.CFrame.p,20,{
			MinimumDamage=5,
			MaximumDamage=10
		})
		local Alpha = .3
		RJ.C0 = RJ.C0:lerp(CFrame.new(0.00617184862, -0.15, 0.395316333, 0.999986708, 0.00508808438, -0.000884585083, -0.00509300316, 0.943203092, -0.332178056, -0.000855805352, 0.332178146, 0.943216264)*CF.A(M.R(20),0,0),Alpha)
		LH.C0 = LH.C0:lerp(CFrame.new(-0.497282684, -1.06256902, -0.0290378034, 0.999878228, -0.00509300316, 0.0147562362, -9.85493534e-05, 0.943203092, 0.332217097, -0.0156101063, -0.332178056, 0.943087518)*CF.A(M.R(-20),0,0),Alpha)
		RH.C0 = RH.C0:lerp(CFrame.new(0.497732252, -1.05967009, -0.03568241, 0.999878228, -0.00509300316, 0.0147562362, -9.85493534e-05, 0.943203092, 0.332217097, -0.0156101063, -0.332178056, 0.943087518)*CF.A(M.R(-20),0,0),Alpha)
		LS.C0 = LS.C0:lerp(CFrame.new(-1.42849481, 0.494048148, -0.00801739097, 0.98822248, 0.134164602, 0.0735954121, -0.152104512, 0.808569551, 0.568401217, 0.0167523213, -0.572901011, 0.819453418),Alpha)
		RS.C0 = RS.C0:lerp(CFrame.new(1.41312766, 0.523678839, 0.0325531065, 0.980119586, -0.184282064, 0.0735261068, 0.110644385, 0.815263927, 0.568421364, -0.164693028, -0.548985541, 0.81944561),Alpha)
		NK.C0 = NK.C0:lerp(CFrame.new(9.04871195e-06, 1.49893618, -0.0143969432, 1.00000012, 9.62987542e-07, -2.71946192e-07, -9.43895429e-07, 0.997964919, 0.0637682378, 3.31550837e-07, -0.063768208, 0.997964799),Alpha)
	end
	wo:breakJoints()
	wo:destroy()
	WalkSpeed = oWS
	Attack = false
	NeutralAnims = true
end

function MurderKnife()
	local Sai = New("Model",Char,"Sai",{})
	local Handle = New("Part",Sai,"Handle",{Transparency = 1,Transparency = 1,Size = Vector3.new(0.0500000007, 0.0500000007, 0.0500000007),CFrame = CFrame.new(-13.6449995, 31.3018703, 19.1356354, 1, 0, 0, 0, 1, 0, 0, 0, 1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
	local HW = New("Weld",Handle,'Weld',{Part0=RArm,Part1=Handle,C0=CF.N(0,-1,0)*CF.A(M.R(-90),0,0)})
	local HandPE = New('ParticleEmitter',Handle,'ParticleEmitter',{Color=ColorSequence.new(C3.N(1,0,0)),LightEmission=.25,LightInfluence=25,Size=NumberSequence.new(.3,0),Texture='rbxasset://textures/particles/sparkles_main.dds',LockedToPart=true,EmissionDirection='Top',Enabled=true,Lifetime=NumberRange.new(.3),Rate=50,Speed=NumberRange.new(5)})
	local Extendo = New("Part",Sai,"Extendo",{Transparency = 1,Transparency = 1,Size = Vector3.new(0.0500000007, 0.0500000007, 0.0500000007),CFrame = CFrame.new(-13.6450005, 32.2849998, 18.6353073, 1, 0, 0, 0, 1, 0, 0, 0, 1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
	local ExtenPE = New('ParticleEmitter',Extendo,'ParticleEmitter',{Color=ColorSequence.new(C3.N(1,0,0)),LightEmission=.25,LightInfluence=25,Size=NumberSequence.new(.2,0),Texture='rbxasset://textures/particles/sparkles_main.dds',LockedToPart=true,EmissionDirection='Top',Enabled=true,Lifetime=NumberRange.new(.2),Rate=75,Speed=NumberRange.new(5)})
	local mot = New("Motor",Extendo,"mot",{Part0 = Extendo,Part1 = Handle,C1 = CFrame.new(-9.53674316e-07, 0.983129501, -0.500328064, 1, 0, 0, 0, 1, 0, 0, 0, 1),})
	local Extendo = New("Part",Sai,"Extendo",{Transparency = 1,Transparency = 1,Size = Vector3.new(0.0500000007, 0.0500000007, 0.0500000007),CFrame = CFrame.new(-13.6450005, 32.2849998, 19.6353073, 1, 0, 0, 0, 1, 0, 0, 0, 1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
	local ExtenPE = New('ParticleEmitter',Extendo,'ParticleEmitter',{Color=ColorSequence.new(C3.N(1,0,0)),LightEmission=.25,LightInfluence=25,Size=NumberSequence.new(.2,0),Texture='rbxasset://textures/particles/sparkles_main.dds',LockedToPart=true,EmissionDirection='Top',Enabled=true,Lifetime=NumberRange.new(.2),Rate=75,Speed=NumberRange.new(5)})
	local mot = New("Motor",Extendo,"mot",{Part0 = Extendo,Part1 = Handle,C1 = CFrame.new(-9.53674316e-07, 0.983129501, 0.499671936, 1, 0, 0, 0, 1, 0, 0, 0, 1),})
	local BladenShit = New("Part",Sai,"BladenShit",{Transparency = 1,Transparency = 1,Size = Vector3.new(0.0500000007, 0.0500000007, 0.0500000007),CFrame = CFrame.new(-13.6450005, 32.2849274, 19.1353073, 1, 0, 0, 0, 1, 0, 0, 0, 1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
	local BladePE = New('ParticleEmitter',BladenShit,'ParticleEmitter',{Color=ColorSequence.new(C3.N(1,0,0)),LightEmission=.25,LightInfluence=25,Size=NumberSequence.new(.3,0),Texture='rbxasset://textures/particles/smoke_main.dds',LockedToPart=true,EmissionDirection='Top',Enabled=true,Lifetime=NumberRange.new(.5),Rate=75,Speed=NumberRange.new(5)})
	local HanB1PE = New('ParticleEmitter',BladenShit,'ParticleEmitter',{Color=ColorSequence.new(C3.N(1,0,0)),LightEmission=.25,LightInfluence=25,Size=NumberSequence.new(.3,0),Texture='rbxasset://textures/particles/sparkles_main.dds',LockedToPart=true,EmissionDirection='Front',Enabled=true,Lifetime=NumberRange.new(.25),Rate=50,Speed=NumberRange.new(5)})
	local HanB2PE = New('ParticleEmitter',BladenShit,'ParticleEmitter',{Color=ColorSequence.new(C3.N(1,0,0)),LightEmission=.25,LightInfluence=25,Size=NumberSequence.new(.3,0),Texture='rbxasset://textures/particles/sparkles_main.dds',LockedToPart=true,EmissionDirection='Back',Enabled=true,Lifetime=NumberRange.new(.25),Rate=50,Speed=NumberRange.new(5)})
	local mot = New("Motor",BladenShit,"mot",{Part0 = BladenShit,Part1 = Handle,C1 = CFrame.new(-9.53674316e-07, 0.983057022, -0.000328063965, 1, 0, 0, 0, 1, 0, 0, 0, 1),})
	local Hitbox = New("Part",Sai,"Hitbox",{Transparency = 1,Transparency = 1,Size = Vector3.new(0.0500000007, 1.74999952, 0.340000063),CFrame = CFrame.new(-13.6450005, 33.2651939, 19.1278477, 1, 0, 0, 0, 1, 0, 0, 0, 1),CanCollide = false,BottomSurface = Enum.SurfaceType.Smooth,TopSurface = Enum.SurfaceType.Smooth,})
	local mot = New("Motor",Hitbox,"mot",{Part0 = Hitbox,Part1 = Handle,C1 = CFrame.new(-9.53674316e-07, 1.96332359, -0.00778770447, 1, 0, 0, 0, 1, 0, 0, 0, 1),})
	
	return HW,Sai
end



function MurderNigger(target)
	if(target)then
		local torso = GetTorso(target)
		local hum = target:FindFirstChildOfClass'Humanoid'
		local hed = target:FindFirstChild'Head'
		if(torso and hum and hum.Health > 0 and hed)then
			local oWS = WalkSpeed
			local oPar = target.Parent
			local originalpos = Root.CFrame
			WalkSpeed = 0
			Hum.JumpPower = 0
			Attack = true
			NeutralAnims = false
			Root.Anchored = true
			torso.Anchored = true
			target.Parent = Char
			Hum.AutoRotate = false
			for i = 0, 9 do
				NoobySphere(3,.25,'Multiply',Root.CFrame*CF.A(M.RRNG(-360,360),M.RRNG(-360,360),M.RRNG(-360,360)),V3.N(1,1,10),-.01,Core2.BrickColor)
			end
			for i = 1, 24 do
				NoobyBlock(1,M.RNG(4,8),'Multiply',Root.CFrame*CF.A(M.RRNG(-360,360),M.RRNG(-360,360),M.RRNG(-360,360)),V3.N(3,3,3),.06,Core2.BrickColor,0)
			end
			NoobySphere2(3,'Multiply',Root.CFrame,V3.N(),.25,Core2.BrickColor)
			Root.CFrame = torso.CFrame*CF.N(0, 0, 1.89)
			for i = 0, 9 do
				NoobySphere(3,.25,'Multiply',Root.CFrame*CF.A(M.RRNG(-360,360),M.RRNG(-360,360),M.RRNG(-360,360)),V3.N(1,1,10),-.01,Core2.BrickColor)
			end
			for i = 1, 24 do
				NoobyBlock(1,M.RNG(4,8),'Multiply',Root.CFrame*CF.A(M.RRNG(-360,360),M.RRNG(-360,360),M.RRNG(-360,360)),V3.N(3,3,3),.06,Core2.BrickColor,0)
			end
			NoobySphere2(3,'Multiply',Root.CFrame,V3.N(),.25,Core2.BrickColor)
			
			local HW,knife = MurderKnife()
			--847061203
			Sound(Core2,847061203,1,2.5,false,true,true)
			for i = 0, 3, 0.1 do
				swait()
				local Alpha = .2
				RJ.C0 = RJ.C0:lerp(CFrame.new(0, 0.00628662109, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
				LH.C0 = LH.C0:lerp(CFrame.new(-0.496665925, -0.990936279, 0.00762737356, 1, -3.37450885e-08, 2.21652698e-07, 3.37455646e-08, 1, -2.1504236e-06, -2.21652627e-07, 2.1504236e-06, 1),Alpha)
				RH.C0 = RH.C0:lerp(CFrame.new(0.498333007, -0.991060257, 0.0170113072, 1, -3.37450885e-08, 2.21652698e-07, 3.37455646e-08, 1, -2.1504236e-06, -2.21652627e-07, 2.1504236e-06, 1),Alpha)
				LS.C0 = LS.C0:lerp(CFrame.new(-1.28516543, 0.724190474, -0.474189818, 0.972499251, 0.184650362, -0.141949132, -0.134552032, -0.0520570427, -0.989538252, -0.190108046, 0.981424689, -0.0257803537),Alpha)
				RS.C0 = RS.C0:lerp(CFrame.new(1.14291549, 0.806114435, 0.620829105, 0.806192696, 0.353628874, 0.474341691, 0.13779296, -0.891899109, 0.430730879, 0.575383842, -0.281891108, -0.767770052),Alpha)
				NK.C0 = NK.C0:lerp(CFrame.new(8.77380371e-05, 1.49900436, -0.00497436523, 1, 0, 0, 0, 1, 0, 0, 0, 1),Alpha)
				HW.C0 = clerp(HW.C0,CFrame.new(-0.142453238, -1.03396463, -0.198824421, -0.998497248, 0.0548028648, 8.5413456e-05, 7.66813755e-05, -0.000161617994, 1, 0.0548028946, 0.998497188, 0.000157207251),Alpha)
			end
			Sound(torso,429400881,1.2,4,false,true,true)
			target.Parent = oPar
			local hum = target:FindFirstChildOfClass'Humanoid'
			if(hum)then
				hum.Health=hum.Health-hum.MaxHealth/3
			end
			for i = 0, 3, 0.1 do
				swait()
				local Alpha = .3
				RJ.C0 = RJ.C0:lerp(CFrame.new(-0.00238382886, 0.00628662109, -0.00060180336, 0.896098733, 0, -0.443854868, 0, 1, 0, 0.443854868, 0, 0.896098733),Alpha)
				LH.C0 = LH.C0:lerp(CFrame.new(-0.496673644, -0.990932465, 0.00768280122, 1.00000012, 0, 0, 0, 1, 0, 0, 0, 1.00000012),Alpha)
				RH.C0 = RH.C0:lerp(CFrame.new(0.498329222, -0.991056442, 0.017009737, 1.00000012, 0, 0, 0, 1, 0, 0, 0, 1.00000012),Alpha)
				LS.C0 = LS.C0:lerp(CFrame.new(-1.17789793, 0.575393677, -0.0879677832, 0.584696472, 0.754816532, -0.297291398, -0.179923102, -0.236678019, -0.95478332, -0.791048646, 0.61174798, -0.00257586688),Alpha)
				RS.C0 = RS.C0:lerp(CFrame.new(1.05549359, 0.484450161, -0.690232515, 0.71294421, 0.397806346, -0.577460706, -0.424427927, -0.410723001, -0.806949615, -0.558185995, 0.820400417, -0.123982459),Alpha)
				NK.C0 = NK.C0:lerp(CFrame.new(0.000124273589, 1.49900436, -0.00493157003, 0.896098733, 0, 0.443854868, 0, 1, 0, -0.443854868, 0, 0.896098733),Alpha)
				HW.C0 = clerp(HW.C0,CFrame.new(0.0260544084, -1.07189536, -0.570477843, -0.998497128, 0.0523602702, -0.0161807239, 7.93784857e-05, 0.29663223, 0.954991877, 0.054803364, 0.953555346, -0.29619059),Alpha)
			end
			for i = 0, 3, 0.1 do
				swait()
				local Alpha = .3
				RJ.C0 = RJ.C0:lerp(CFrame.new(-0.00238382886, 0.00628662109, -0.00060180336, 0.896098733, 0, -0.443854868, 0, 1, 0, 0.443854868, 0, 0.896098733),Alpha)
				LH.C0 = LH.C0:lerp(CFrame.new(-0.496673644, -0.990932465, 0.00768280122, 1.00000012, 0, 0, 0, 1, 0, 0, 0, 1.00000012),Alpha)
				RH.C0 = RH.C0:lerp(CFrame.new(0.498329222, -0.991056442, 0.017009737, 1.00000012, 0, 0, 0, 1, 0, 0, 0, 1.00000012),Alpha)
				LS.C0 = LS.C0:lerp(CFrame.new(-1.17789793, 0.575393677, -0.0879677832, 0.584696472, 0.754816532, -0.297291398, -0.179923102, -0.236678019, -0.95478332, -0.791048646, 0.61174798, -0.00257586688),Alpha)
				RS.C0 = RS.C0:lerp(CFrame.new(1.05549359, 0.484450161, -0.690232515, 0.71294421, 0.397806346, -0.577460706, -0.424427927, -0.410723001, -0.806949615, -0.558185995, 0.820400417, -0.123982459)*CF.A(M.RRNG(-5,5),M.RRNG(-5,5),M.RRNG(-5,5)),Alpha)
				NK.C0 = NK.C0:lerp(CFrame.new(0.000124273589, 1.49900436, -0.00493157003, 0.896098733, 0, 0.443854868, 0, 1, 0, -0.443854868, 0, 0.896098733),Alpha)
				HW.C0 = clerp(HW.C0,CFrame.new(0.0260544084, -1.07189536, -0.570477843, -0.998497128, 0.0523602702, -0.0161807239, 7.93784857e-05, 0.29663223, 0.954991877, 0.054803364, 0.953555346, -0.29619059),Alpha)
			end
			Sound(torso,429400881,.7,4,false,true,true)
			if(hum)then
				hum.Health=hum.Health-hum.MaxHealth/3
			end
			coroutine.wrap(function()
				local hum = target:FindFirstChildOfClass'Humanoid'
				if(hum)then
					repeat swait() 
						hum.Health=hum.Health-.5
					until hum.Health <= 1
					Kill(target)
					knife:destroy()
				end
			end)()
			for i = 0, 3, 0.1 do
				swait()
				local Alpha = .3
				RJ.C0 = RJ.C0:lerp(CFrame.new(0.000169749488, 0.00628662109, -6.61667073e-05, 0.999548376, 0, 0.0300540105, 0, 1, 0, -0.0300540105, 0, 0.999548376),Alpha)
				LH.C0 = LH.C0:lerp(CFrame.new(-0.444387794, -0.990932465, -0.227554411, 0.882354379, 0, -0.470585763, 0, 1, 0, 0.470585763, 0, 0.882354379),Alpha)
				RH.C0 = RH.C0:lerp(CFrame.new(0.495574117, -0.991056442, 0.0314709544, 0.97812444, 0, -0.208021611, 0, 1, 0, 0.208021611, 0, 0.97812444),Alpha)
				LS.C0 = LS.C0:lerp(CFrame.new(-1.00046349, 0.575390875, -0.63252908, 0.888165712, 0.3781358, -0.261104196, -0.179923102, -0.236678019, -0.95478332, -0.42283538, 0.894984365, -0.142173931),Alpha)
				RS.C0 = RS.C0:lerp(CFrame.new(1.35260987, 0.74367249, -0.148820311, 0.373968333, 0.469723582, -0.799692273, -0.757211864, -0.343237787, -0.555714011, -0.53551662, 0.813355863, 0.227320194),Alpha)
				NK.C0 = NK.C0:lerp(CFrame.new(-0.000104449631, 1.49900436, -0.00490342593, 0.999548376, 0, -0.0300540105, 0, 1, 0, 0.0300540105, 0, 0.999548376),Alpha)
				HW.C0 = clerp(HW.C0,CFrame.new(-0.315003902, -0.881822228, -0.534994423, -0.905889809, 0.289212197, -0.309386551, -0.423450023, -0.631175756, 0.649851799, -0.00733225048, 0.719703913, 0.694242597),Alpha)
			end
			
			
			HW.Part0 = target:FindFirstChild'Head'
			HW.C0 = CFrame.new(0.976348281, 0.254784644, 0.639342666, -0.527396142, -0.778684974, -0.339857459, 0.83536917, -0.402301013, -0.374582857, 0.154957026, -0.481460005, 0.862661362)
			delay(2, function() 
				Kill(target)
				knife:destroy() 
			end)
			WalkSpeed = oWS
			Hum.JumpPower = 50
			Hum.AutoRotate = true
			Root.CFrame = originalpos
			Sound(Core2,847061203,1,2.5,false,true,true)
			for i = 0, 9 do
				NoobySphere(3,.25,'Multiply',Root.CFrame*CF.A(M.RRNG(-360,360),M.RRNG(-360,360),M.RRNG(-360,360)),V3.N(1,1,10),-.01,Core2.BrickColor)
			end
			for i = 1, 24 do
				NoobyBlock(1,M.RNG(4,8),'Multiply',Root.CFrame*CF.A(M.RRNG(-360,360),M.RRNG(-360,360),M.RRNG(-360,360)),V3.N(3,3,3),.06,Core2.BrickColor,0)
			end
			NoobySphere2(3,'Multiply',Root.CFrame,V3.N(),.25,Core2.BrickColor)
			
			Root.Anchored = false
			torso.Anchored = false
			Attack = false
			NeutralAnims = true
		end
	end
end

function MobileMurder()
	Attack = true
	local oWS = WalkSpeed
	WalkSpeed = 0
	local what;
	what = Mouse.Button1Down:connect(function()
		what:disconnect();
		local target = (Mouse.Target and Mouse.Target.Parent)
		if(target)then
			local torso = GetTorso(target)
			local hum = target:FindFirstChildOfClass'Humanoid'
			local hed = target:FindFirstChild'Head'
			if(torso and hum and hum.Health > 0 and hed)then
				WalkSpeed = oWS
				MurderNigger(target)
			else
				WalkSpeed = oWS
				Attack = false
			end
		else
			WalkSpeed = oWS
			Attack = false
		end
	end)	
end


function NeckSnap(target)
	if(target)then
		local torso = GetTorso(target)
		local hum = target:FindFirstChildOfClass'Humanoid'
		local hed = target:FindFirstChild'Head'
		if(torso and hum and hum.Health > 0 and hed)then
			local oWS = WalkSpeed
			local oPar = target.Parent
			local originalpos = Root.CFrame
			WalkSpeed = 0
			Hum.JumpPower = 0
			Attack = true
			NeutralAnims = false
			Root.Anchored = true
			torso.Anchored = true
			target.Parent = Char
			Hum.AutoRotate = false
			Root.CFrame = torso.CFrame*CF.N(-0.54454422, 0, 0.987496376)
			for _,v in next, torso:children() do
				if(v:IsA'JointInstance' and (v.Part0 == hed or v.Part1 == hed))then
					v:destroy()
				end
			end
			hed:breakJoints()
			local weld = NewInstance('Motor',torso,{Part0=hed,Part1=torso,C0=CF.N(0,-1.5,0)})
			for i = 0, 1, 0.1 do
				swait()
				local Alpha = .3
				RJ.C0 = clerp(RJ.C0,CFrame.new(2.74447132e-13, 0.00628674263, 4.19029675e-07, 0.99999994, 4.36557457e-11, 0, -4.3652193e-11, 0.999980211, -0.00628619269, 9.31322575e-10, 0.00628619175, 0.999980271),Alpha)
				LH.C0 = clerp(LH.C0,CFrame.new(-0.49648428, -0.990816116, 0.0216189735, 0.999878109, -9.59694546e-11, 0.015612145, -9.81408521e-05, 0.999980211, 0.00628542574, -0.0156118376, -0.00628619269, 0.999858439),Alpha)
				RH.C0 = clerp(RH.C0,CFrame.new(0.498537898, -0.990978718, 0.0154631268, 0.999878109, -9.59694546e-11, 0.015612145, -9.81408521e-05, 0.999980211, 0.00628542574, -0.0156118376, -0.00628619269, 0.999858439),Alpha)
				LS.C0 = clerp(LS.C0,CFrame.new(-0.763917506, 0.783056259, -0.756683111, 0.675138593, -0.737685442, 0.00284584239, 0.140656561, 0.124941669, -0.982143223, 0.724157274, 0.663483143, 0.188113257),Alpha)
				RS.C0 = clerp(RS.C0,CFrame.new(1.23871374, 1.09544897, -0.196351975, 0.766011953, 0.365654767, -0.528698623, -0.105766296, -0.739559352, -0.664729595, -0.634065628, 0.565109432, -0.527837396),Alpha)
				NK.C0 = clerp(NK.C0,CFrame.new(1.00737725e-05, 1.4989512, -0.0144016817, 0.99999994, 3.67523171e-07, -1.61118805e-07, -3.56500095e-07, 0.997964799, 0.0637688041, 1.8440187e-07, -0.063768819, 0.997964799),Alpha)
			end
			Sound(hed,1093102664,1,5,false,true,true)
			for i = 0, 1.3, 0.1 do
				swait()
				local Alpha = .3
				weld.C0 = weld.C0:lerp(CF.N(0,-1.5,0)*CF.A(0,M.R(-90),0),Alpha)
				RJ.C0 = clerp(RJ.C0,CFrame.new(2.74447132e-13, 0.00628674263, 4.19029675e-07, 0.99999994, 4.36557457e-11, 0, -4.3652193e-11, 0.999980211, -0.00628619269, 9.31322575e-10, 0.00628619175, 0.999980271),Alpha)
				LH.C0 = clerp(LH.C0,CFrame.new(-0.49648428, -0.990818024, 0.0216189846, 0.999878109, -9.59694546e-11, 0.015612145, -9.81408521e-05, 0.999980211, 0.00628542574, -0.0156118376, -0.00628619269, 0.999858439),Alpha)
				RH.C0 = clerp(RH.C0,CFrame.new(0.498537898, -0.990980625, 0.0154631399, 0.999878109, -9.59694546e-11, 0.015612145, -9.81408521e-05, 0.999980211, 0.00628542574, -0.0156118376, -0.00628619269, 0.999858439),Alpha)
				LS.C0 = clerp(LS.C0,CFrame.new(-1.38228214, 0.484847993, -0.0603635609, 0.424681932, 0.905338109, 0.00285495515, -0.169125155, 0.0824314952, -0.982141495, -0.889405489, 0.41661495, 0.18812263),Alpha)
				RS.C0 = clerp(RS.C0,CFrame.new(1.40680802, 0.48904568, -0.02736184, 0.441890627, -0.897064447, 0.00284484075, 0.169923306, 0.0805888921, -0.982156575, 0.8808285, 0.43448925, 0.188043654),Alpha)
				NK.C0 = clerp(NK.C0,CFrame.new(1.00737716e-05, 1.49894726, -0.014402397, 0.99999994, 3.67523171e-07, -1.61118805e-07, -3.56500095e-07, 0.997964799, 0.0637688041, 1.8440187e-07, -0.063768819, 0.997964799),Alpha)
			end
			target.Parent = oPar
			target:breakJoints()
			WalkSpeed = oWS
			Hum.JumpPower = 50
			Hum.AutoRotate = true
			Root.Anchored = false
			torso.Anchored = false
			Attack = false
			NeutralAnims = true
		end
	end
end

function MobileNeckSnap()
	Attack = true
	local oWS = WalkSpeed
	WalkSpeed = 0
	local what;
	what = Mouse.Button1Down:connect(function()
		what:disconnect();
		local target = (Mouse.Target and Mouse.Target.Parent)
		if(target)then
			local torso = GetTorso(target)
			local hum = target:FindFirstChildOfClass'Humanoid'
			local hed = target:FindFirstChild'Head'
			if(torso and hum and hum.Health > 0 and hed)then
				WalkSpeed = oWS
				NeckSnap(target)
			else
				WalkSpeed = oWS
				Attack = false
			end
		else
			WalkSpeed = oWS
			Attack = false
		end
	end)	
end

function SongSmash()
	Attack = true
	NeutralAnims = false
	for i = 0, 3, 0.1 do
		swait()
		NoobySphere(5,.3,"Multiply",LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(-180,180),M.RRNG(-180,180),M.RRNG(-180,180)),V3.N(.1,.1,.1),0,Core2.Color,0,1088207)
		NoobyBlock(2,.04,'Multiply',LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(-180,180),M.RRNG(-180,180),M.RRNG(-180,180)),V3.N(1,1,1),.004,Core2.Color,0,true)
		local Alpha = .1
		RJ.C0 = clerp(RJ.C0,CFrame.new(-0.001753752, 0.00628927909, -0.000408248976, 0.942081869, -0.00210913899, -0.335376531, 7.21194738e-07, 0.99998033, -0.00628671842, 0.335383177, 0.00592236174, 0.942063153),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.496480286, -0.990816116, 0.0216198936, 0.9367311, 0, 0.350050032, -0.00220137485, 0.99998033, 0.00589086255, -0.350043088, -0.00628874451, 0.936712503),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.498543233, -0.990978837, 0.0154619068, 0.975587726, 0, -0.219610512, 0.00138107454, 0.99998033, 0.00613522204, 0.219606131, -0.00628874451, 0.975568414),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.40567565, 0.408012271, -0.00104653835, 0.958351374, 0.285325468, -0.0123402029, 0.2337396, -0.758791327, 0.607948899, 0.164099574, -0.585512877, -0.793880343),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.42242038, 0.493699282, -0.0249331407, 0.987734318, -0.155363053, 0.0156076849, 0.155282006, 0.987850249, 0.0062857219, -0.0163946152, -0.00378503278, 0.999858558),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(1.16258161e-05, 1.49894369, -0.0144085325, 0.9367311, 0, 0.350050032, -0.00220137485, 0.99998033, 0.00589086255, -0.350043088, -0.00628874451, 0.936712503),Alpha)
	end
	AOEDamage(Root.CFrame.p,110,{MinimumDamage=pl/15,MaximumDamage=pl/5})
	NoobySphere2(3,"Multiply",Root.CFrame*CF.N(0,-2.9,0),V3.N(110,0.1,110),0.01,Core2.Color)
	for i = 1, 20 do
		NoobySphere(3,0.5,"Multiply",Root.CFrame*CF.N(M.RNG(-42.5,42.5),-5,M.RNG(-42.5,42.5))*CF.A(M.R(90)+M.RRNG(-45,45),M.RRNG(-45,45),M.RRNG(-45,45)),V3.N(.5,.5,.5),0,Core2.Color,0,1088207)
		NoobySphere(3,0.5,"Multiply",Root.CFrame*CF.N(M.RNG(-42.5,42.5),-5,M.RNG(-42.5,42.5))*CF.A(M.R(90)+M.RRNG(-45,45),M.RRNG(-45,45),M.RRNG(-45,45)),V3.N(.5,.5,.5),0,Core2.Color,0,1088207)
	end
	for i = 0, 3, 0.1 do
		swait()
		local Alpha = .4
		RJ.C0 = clerp(RJ.C0,CFrame.new(-0.0056809783, -1.84688139, -0.363832742, 0.999853492, -0.0143729132, -0.00929748639, 0.0143199814, 0.40471217, 0.914332032, -0.00937880948, -0.914331198, 0.404858679),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.498466104, -0.621809721, -0.107522458, 0.999878109, -0.00381839275, 0.0151433209, -9.67067026e-05, 0.968117595, 0.250496507, -0.0156170065, -0.25046742, 0.967999101),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.49715057, -0.612025738, -0.0758087933, 0.999878109, -0.00322529091, 0.0152806351, -9.67067026e-05, 0.977144957, 0.212574452, -0.0156170065, -0.212549999, 0.977025449),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.46437562, 0.573429823, -0.135539591, 0.995870709, 0.090780057, 0.000750792213, -0.0041781459, 0.0540931821, -0.998527229, -0.090686962, 0.99440074, 0.054249078),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.46732497, 0.668299794, -0.164544582, 0.998940408, -0.0457421541, -0.00509791775, -0.000265741721, 0.105029136, -0.994469225, 0.0460245833, 0.993416667, 0.104905695),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(7.62883064e-06, 1.49891925, -0.0144104436, 1.00000012, -4.65661287e-10, 1.62981451e-09, 4.65661287e-10, 0.997964621, 0.0637715757, 6.98491931e-10, -0.0637715459, 0.997964621),Alpha)
	end
	Attack = false
	NeutralAnims = true
end

function AttackOne()
	Attack = true
	NeutralAnims = false
	for i = 0, .7, 0.1 do
		swait()
		local Alpha = .3
		RJ.C0 = clerp(RJ.C0,CFrame.new(0.054845117, 0.00628340431, 0.0621978641, 0.574560821, -0.00514742406, -0.818445683, 1.76018864e-06, 0.99998033, -0.00628790678, 0.818461895, 0.00361134461, 0.574549437),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.525948346, -0.994591057, 0.0135081597, 0.989666939, 0.0856333151, 0.115006924, -0.0869238526, 0.996195495, 0.00624422729, -0.114034653, -0.0161765479, 0.993345082),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.487148911, -0.967346072, -0.0260838568, 0.964277864, -0.0686885938, 0.255832553, -0.00166595122, 0.964203477, 0.265158683, -0.264888048, -0.256112814, 0.92964536),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.38879275, 0.498546124, -0.255748421, 0.692717075, 0.721134841, 0.0103802728, 0.00202227081, 0.0124506345, -0.999920607, -0.721206725, 0.692682922, 0.00716643687),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.27866459, 0.504911065, -0.181807131, 0.763874948, -0.645362377, -0.00163397193, -0.0634241104, -0.0725510716, -0.995346248, 0.642240286, 0.760423601, -0.0963514596),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(-0.0864869878, 1.49901688, -0.00313834194, 0.57456094, -0.0470548049, 0.817108035, -0.00514778076, 0.998118699, 0.0610983856, -0.818445623, -0.0393110402, 0.573237658),Alpha)
	end
	Sound(RArm,200632136,1.1,5,false,true,true)
	for i = 0, .9, 0.1 do
		swait()
		local Alpha = .3
		AOEDamage(RArm.CFrame.p,2,{MinimumDamage=10,MaximumDamage=30})
		RJ.C0 = clerp(RJ.C0,CFrame.new(-0.0895246193, 0.00628795894, -0.0240665041, 0.667355478, 0.00468144845, 0.744724631, -1.60177922e-06, 0.99998033, -0.00628458662, -0.744739354, 0.0041928608, 0.667342305),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.525933743, -0.994594276, 0.0135074947, 0.995298743, 0.0856334865, -0.0452488065, -0.0847965032, 0.996195495, 0.0201073457, 0.0467984378, -0.0161758773, 0.998773336),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.490905643, -0.74434638, -0.358290195, 0.993401766, -0.0489627272, -0.103709608, 0.0897386894, 0.894942641, 0.437063992, 0.0714142919, -0.443486929, 0.893431306),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.34781098, 0.451429009, 0.184345022, 0.920896769, 0.211902812, 0.327179492, -0.00245033321, 0.842468321, -0.538740575, -0.389798939, 0.495322734, 0.776345491),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.33741677, 0.579409122, -0.335710943, 0.71467489, -0.698394477, 0.0385371894, -0.0347292982, -0.0904589221, -0.995294571, 0.698594153, 0.709973574, -0.0889034569),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(0.0455316827, 1.49947691, 0.069996126, 0.667355359, 0.0428168029, -0.743507743, 0.00468109129, 0.99808526, 0.0616789386, 0.744724751, -0.0446421988, 0.665876985),Alpha)
	end
	Combo = 2
	Attack = false
	NeutralAnims = true
end

function AttackTwo()
	Attack = true
	NeutralAnims = false
	for i = 0, 1, 0.1 do
		swait()
		local Alpha = .3
		RJ.C0 = clerp(RJ.C0,CFrame.new(0.00337019563, 0.00628272956, -0.00105122454, 0.788301051, 0.00386909139, 0.615277588, -1.32338778e-06, 0.99998033, -0.00628654705, -0.615289807, 0.00495487731, 0.788285434),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.370244205, -1.06356883, -0.0345072895, 0.88316524, 0.227487147, 0.41020599, -0.259257317, 0.965541184, 0.0227174684, -0.390902787, -0.126412138, 0.911709964),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.39778316, -1.07560706, -0.0971514285, 0.900898933, -0.0766149312, -0.427213579, 0.151964575, 0.977673352, 0.145127282, 0.406556368, -0.195666283, 0.892427385),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.47616029, 0.512279212, 0.0670655966, 0.904187679, -0.427135438, 0.00023345463, 0.00958644785, 0.0197467823, -0.999759197, 0.427027881, 0.903972089, 0.0219495054),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.33361411, 0.488021076, -0.300545812, 0.00661067665, -0.543416262, 0.839437485, 0.976997852, -0.175422177, -0.121254832, 0.213147745, 0.820930004, 0.529756606)*CF.A(0,M.R(-90),0),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(-0.000233855098, 1.49894583, -0.0145844966, 0.788300931, 0.0353745371, -0.614272296, 0.0038687347, 0.998041451, 0.062439695, 0.615277767, -0.0515977256, 0.786619961),Alpha)
	end	
	Sound(LArm,200632136,.9,5,false,true,true)
	for i = 0, 1, 0.1 do
		swait()
		local Alpha = .3
		AOEDamage(LArm.CFrame.p,2,{MinimumDamage=10,MaximumDamage=30})
		RJ.C0 = clerp(RJ.C0,CFrame.new(-0.0139055764, 0.00628619827, -0.0431878939, 0.736094832, -0.0042554969, -0.676865041, 1.4556681e-06, 0.99998033, -0.00628536195, 0.676878333, 0.00462563755, 0.736080408),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.370245337, -1.06356549, -0.0345049649, 0.883166075, 0.227488101, 0.410203636, -0.25925675, 0.965541363, 0.0227144919, -0.390901268, -0.126408711, 0.911711276),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.397780299, -1.07560635, -0.0971318483, 0.900898337, -0.076615192, -0.427214652, 0.151964024, 0.977673769, 0.145124823, 0.406557709, -0.195663959, 0.892427325),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.54785693, 0.502721965, -0.369121343, 0.640384734, 0.768054307, 9.36477445e-05, -0.0167029109, 0.0140483743, -0.999761999, -0.767872751, 0.640230715, 0.0218251087),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.41005266, 0.394677043, -0.101526827, 0.621816397, -0.730075538, 0.283432782, 0.783004642, 0.586830258, -0.206238553, -0.0157571733, 0.350171626, 0.93655318)*CF.A(0,M.R(-90),0),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(0.0361058414, 1.49909592, 0.00928576291, 0.736094952, -0.0389148258, 0.67575866, -0.00425585406, 0.998060346, 0.0621110015, -0.676864862, -0.0485955328, 0.7345016),Alpha)
	end
	Combo = 3
	Attack = false
	NeutralAnims = true
end

function AttackThree()
	Attack = true
	NeutralAnims = false
	for i = 0, 1, 0.1 do
		swait()
		local Alpha = .3
		RJ.C0 = clerp(RJ.C0,CFrame.new(2.74447132e-13, 0.00628674868, -5.34626452e-07, 0.99999994, 4.36557457e-11, 0, -4.3652193e-11, 0.999980211, -0.00628619269, 9.31322575e-10, 0.00628619175, 0.999980271),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.496486187, -0.990816116, 0.0216190033, 0.999878109, -9.59694546e-11, 0.015612145, -9.81408521e-05, 0.999980211, 0.00628542574, -0.0156118376, -0.00628619269, 0.999858439),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.498537898, -0.990978718, 0.0154631268, 0.999878109, -9.59694546e-11, 0.015612145, -9.81408521e-05, 0.999980211, 0.00628542574, -0.0156118376, -0.00628619269, 0.999858439),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.12213016, 0.47289753, -0.302224725, 0.912795186, -0.408417523, -7.55176477e-10, 0.00256825075, 0.00573992962, -0.999980211, 0.408409536, 0.912777245, 0.00628829934),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.11283636, 0.472678095, -0.337120384, 0.899599433, 0.436715961, -7.55176477e-10, -0.00274620112, 0.00565694971, -0.999980211, -0.436707377, 0.89958173, 0.00628829934),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(8.16642296e-06, 1.49894738, -0.0144004971, 0.99999994, 3.67523171e-07, -1.61118805e-07, -3.56500095e-07, 0.997964799, 0.0637688041, 1.8440187e-07, -0.063768819, 0.997964799),Alpha)
	end
	--for a = 1, 3 do
	local a = 2
	coroutine.wrap(function()
		for i = 5,45,10 do
			local hite = Instance.new("Part",Char)
			hite.Anchored = true
			hite.CanCollide = false
			hite.Material = "Neon"
			hite.Size = V3.N(1, 1, 1)
			hite.Transparency = 1
			hite.CFrame = (Root.CFrame + Root.CFrame.lookVector)*CF.A(0,M.R(90+(a*45)),0)*CF.N(0,0,i)
			CamShakeAOE(hite.CFrame.p,10,30,250)
			NoobySphere2(3,'Multiply',hite.CFrame,V3.N(0,0,0),.15,Core2.Color)
			NoobySphere2(6,'Multiply',hite.CFrame,V3.N(0,0,0),.3,Core2.Color)
			for i = 1, 2 do
				NoobySphere(2,.2,'Multiply',Root.CFrame*CF.N(0,-.5,-.5)*CF.A(M.RRNG(-20,20),M.RRNG(-20,20),M.RRNG(-20,20)),V3.N(.5,.5,5),-.005,Core2.Color,0)			
			end
			for i = 1, 5 do
				NoobySphere(2.25,.6,'Multiply',hite.CFrame*CF.N(0,0,0)*CF.A(M.RRNG(-360,360),M.RRNG(-360,360),M.RRNG(-360,360)),V3.N(2,2,2),0,Core2.Color,0)
			end
			AOEDamage(hite.CFrame.p,10,{MinimumDamage=25,MaximumDamage=45})
			Sound(hite,183763506,1,5,false,true,true)
			S.Debris:AddItem(hite,2)
			swait()
		end
	end)()
	--end
	for i = 0, 1, 0.1 do
		swait()
		local Alpha = .3
		RJ.C0 = clerp(RJ.C0,CFrame.new(0.00691798097, -0.0495741703, 0.443018734, 0.999998093, -0.00196288247, -0.000110176392, 0.00196200004, 0.992848635, 0.119364031, -0.000124909915, -0.119364008, 0.992850542),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.497228384, -0.946920514, -0.0261252522, 0.999878228, 0.0041074818, 0.0150607219, -9.9174933e-05, 0.966415524, -0.256984442, -0.0156104742, 0.25695163, 0.966298223),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.497788221, -0.949530363, -0.0326310396, 0.999878228, 0.0041074818, 0.0150607219, -9.9174933e-05, 0.966415524, -0.256984442, -0.0156104742, 0.25695163, 0.966298223),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.43487072, 0.476260573, 0.232709944, -0.586293817, 0.810098529, 9.3865674e-07, -0.00509618223, -0.00368710607, -0.999980271, -0.810082495, -0.586282253, 0.00629013777),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.44212484, 0.475975186, 0.187793851, -0.560718656, -0.828006506, -2.90002208e-06, 0.00520995259, -0.00352462381, -0.999980271, 0.827990055, -0.56070751, 0.00629019737),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(9.53681956e-06, 1.49895513, -0.0144005343, 1.00000012, 0, 9.31322575e-10, 1.16415322e-10, 0.99796474, 0.0637698025, -9.31322575e-10, -0.0637697875, 0.997964621),Alpha)
	end
	Combo = 1
	Attack = false
	NeutralAnims = true
end


local WingSine = 0
local WingChange = 1

function MurderMode()
	Attack = true
	NeutralAnims = false
	local Sin = 0
	MusicID = 407749940
	Pitch = 1
	WalkSpeed = 0
	Sound(Core2,136007472,1.25,2.5,false,true,true)
	for i = 0, 4, 0.1 do
		swait()
		NoobySphere(2.5,-1.5,'Multiply',Core2.CFrame*CF.A(M.RRNG(-180,180),M.RRNG(-180,180),M.RRNG(-180,180)),V3.N(3.5,3.5,45),-.035,Core2.Color,100)
		Sin = Sin + 5
		local Alpha = .1
		RJ.C0 = clerp(RJ.C0,CFrame.new(-0.00700476859, 0.0667984039, -0.448462069, 0.999972343, -0.00723911775, -0.00172879919, 0.00722799823, 0.88917774, 0.457504779, -0.00177471992, -0.457504541, 0.889205575),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.497889668, -1.14359522, -0.0677340925, 0.999878228, 0.00722799823, 0.0138372099, -9.56082804e-05, 0.88917774, -0.457561791, -0.0156109957, 0.457504779, 0.889070213),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.497117043, -1.14809179, -0.0749855936, 0.999878228, 0.00722799823, 0.0138372099, -9.56082804e-05, 0.88917774, -0.457561791, -0.0156109957, 0.457504779, 0.889070213),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.20745349, 0.562693655, 0.156515986, 0.841866791, -0.539501786, -0.014077506, -0.490290582, -0.753652692, -0.43774724, 0.225555882, 0.375426948, -0.898987949)*CF.A(0,M.R(0+16*M.S(Sin)),0),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.17680144, 0.613272369, 0.0997506529, 0.834507108, 0.550817847, -0.0140647329, 0.49015516, -0.753777146, -0.437684804, -0.251686275, 0.358357221, -0.899018526)*CF.A(0,M.R(0+16*M.S(Sin)),0),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(6.50798393e-06, 1.53005648, -0.348988175, 1.00000012, 2.40840018e-06, -1.19656324e-05, 5.68898395e-06, 0.775360823, 0.631518543, 1.07986853e-05, -0.631518602, 0.775360942)*CF.A(0,M.R(0+16*M.S(Sin)),0),Alpha)
	end
	for _,v in next, LWing:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 0 v.BrickColor = BrickColor.new'Really red' end
	end
	for _,v in next, RWing:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 1 v.BrickColor = BrickColor.new'Really red' end
	end
	for _,v in next, LWingEXT:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 1 v.BrickColor = BrickColor.new'Really red' end
	end
	for _,v in next, RWingEXT:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 1 v.BrickColor = BrickColor.new'Really red' end
	end
	for _,v in next, Halo:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.BrickColor = BrickColor.new'Really red' end
	end
	pcall(function() Char.ReaperShadowHead.Eye1.Color = C3.N(1,0,0) end)
	pcall(function() Char.ReaperShadowHead.Eye2.Color = C3.N(1,0,0) end)
	WalkSpeed = 16
	Mode = 1
	Core2.BrickColor = BrickColor.new'Really red'
	Core2.Material = Enum.Material.Neon
	Sound(Root,"206082327",1,2.5,false,true,true)
	Sound(Root,"847061203",1,5,false,true,true)
	Sound(Root,"239000203",1,2.5,false,true,true)
	Sound(Root,"579687077",.75,2.5,false,true,true)
	RecolorTextAndRename("Murder",Color3.new(1,0,0),Color3.new(0,0,0))
	NoobySphere2(2.5,'Multiply',Core2.CFrame,V3.N(0,0,0),1,Core2.BrickColor)
	for i = 1, 24 do
		NoobyBlock(1,M.RNG(20,100)/100,'Multiply',Core2.CFrame*CF.A(M.RRNG(-180,180),M.RRNG(-180,180),M.RRNG(-180,180)),V3.N(2,2,2),.04,Core2.Color,0,true)
	end
	for i = 0, 15 do
		NoobySphere(3,-.5,'Multiply',Core2.CFrame*CF.A(M.RRNG(-180,180),M.RRNG(-180,180),M.RRNG(-180,180)),V3.N(.5,.5,25),-.04,Core2.Color,0)
	end
	for i = 0, 1.4, 0.1 do
		swait()
		local Alpha = .3
		RJ.C0 = clerp(RJ.C0,CFrame.new(0.0104959598, -0.113952652, 0.672263861, 0.999963522, 0.00820299331, -0.0023882892, -0.00821700692, 0.846846819, -0.531773448, -0.00233961921, 0.531773746, 0.846883237),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.49749428, -1.06169748, -0.0426189601, 0.999878228, -0.00744201383, 0.013721575, -0.000100045589, 0.875963986, 0.482376754, -0.0156094572, -0.482319295, 0.875856459),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.498449236, -1.1497941, 0.0108022094, 0.999878228, -0.0120362351, 0.009939529, -0.000100045589, 0.631795883, 0.775134981, -0.0156094572, -0.775041461, 0.631717622),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.12307608, 0.484921068, 0.092245549, 0.865161359, 0.501252413, -0.0155520458, 0.497926384, -0.862286389, -0.092366755, -0.059709385, 0.07216838, -0.995603561),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.37669122, 0.484069884, 0.0531393886, 0.866546988, -0.498853445, -0.0155524863, -0.49802509, -0.862227678, -0.0923835635, 0.032676056, 0.0878001451, -0.995602131),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(1.14440181e-05, 1.49895036, -0.0144141242, 1.00000012, 0, -9.31322575e-10, 0, 0.99796474, 0.0637694895, -9.31322575e-10, -0.0637694895, 0.99796468),Alpha)
	end
	Attack = false
	NeutralAnims = true
end

function PureMode()
	for _,v in next, LWing:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 0 v.BrickColor = BrickColor.new'Pastel Blue' end
	end
	for _,v in next, RWing:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 1 v.BrickColor = BrickColor.new'Pastel Blue' end
	end
	for _,v in next, LWingEXT:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 1 v.BrickColor = BrickColor.new'Pastel Blue' end
	end
	for _,v in next, RWingEXT:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 1 v.BrickColor = BrickColor.new'Pastel Blue' end
	end
	for _,v in next, Halo:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.BrickColor = BrickColor.new'Pastel Blue' end
	end
	WalkSpeed = 16
	pcall(function() Char.ReaperShadowHead.Eye1.Color = C3.N(0,1,1) end)
	pcall(function() Char.ReaperShadowHead.Eye2.Color = C3.N(0,1,1) end)
	RecolorTextAndRename("Clarity",C3.N(1,1,1),BrickColor.new'Pastel Blue'.Color)
	MusicID = 1539245059
	Pitch = 1
	Mode = 2
	Core2.BrickColor = BrickColor.new'Pastel Blue'	
	Core2.Material = Enum.Material.Neon
end

function GlitchMode()
	for _,v in next, LWing:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.DiamondPlate v.Transparency = 0 v.BrickColor = BrickColor.new'White' end
	end
	for _,v in next, RWing:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.DiamondPlate v.Transparency = 1 v.BrickColor = BrickColor.new'White' end
	end
	for _,v in next, LWingEXT:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.DiamondPlate v.Transparency = 1 v.BrickColor = BrickColor.new'White' end
	end
	for _,v in next, RWingEXT:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.DiamondPlate v.Transparency = 1 v.BrickColor = BrickColor.new'White' end
	end
	for _,v in next, Halo:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.BrickColor = BrickColor.new'White' end
	end
	pcall(function() Char.ReaperShadowHead.Eye1.Color = C3.N(1,1,1) end)
	pcall(function() Char.ReaperShadowHead.Eye2.Color = C3.N(1,1,1) end)
	WalkSpeed = 16
	RecolorTextAndRename("Glitchy",C3.N(1,1,1),C3.N(1,1,1))
	MusicID = 1470848774
	Pitch = .93
	Mode = 3
	Core2.BrickColor = BrickColor.new'Dark stone grey'
	Core2.Material = Enum.Material.DiamondPlate	
end	

function StressMode()
	for _,v in next, LWing:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = .25 v.BrickColor = BrickColor.new'Crimson' end
	end
	for _,v in next, RWing:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 0 v.Color = C3.RGB(16,16,16) end
	end
	for _,v in next, LWingEXT:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 1 v.BrickColor = BrickColor.new'Crimson' end
	end
	for _,v in next, RWingEXT:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 1 v.BrickColor = BrickColor.new'Crimson' end
	end
	for _,v in next, Halo:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.BrickColor = BrickColor.new'Crimson' end
	end
	WalkSpeed = 14
	RecolorTextAndRename("Stress",C3.N(.6,0,0),C3.N(0,0,0))
	MusicID = 614032233
	Pitch = 1
	Mode = 4
	Core2.BrickColor = BrickColor.new'Really red'
	Core2.Material = Enum.Material.Neon	
end	

function JusticeMode()
	for _,v in next, LWing:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 0 v.BrickColor = BrickColor.new'Institutional white' end
	end
	for _,v in next, RWing:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 0 v.BrickColor = BrickColor.new'Institutional white' end
	end
	for _,v in next, LWingEXT:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 1 v.BrickColor = BrickColor.new'Institutional white' end
	end
	for _,v in next, RWingEXT:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 1 v.BrickColor = BrickColor.new'Institutional white' end
	end
	for _,v in next, Halo:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.BrickColor = BrickColor.new'Institutional white' end
	end
	pcall(function() Char.ReaperShadowHead.Eye1.Color = C3.N(1,1,1) end)
	pcall(function() Char.ReaperShadowHead.Eye2.Color = C3.N(1,1,1) end)
	WalkSpeed = 50
	RecolorTextAndRename("Justice",C3.N(1,1,1),C3.N(0,0,0))
	MusicID = 1102271169
	Pitch = 1
	Mode = 5
	Core2.BrickColor = BrickColor.new'White'
	Core2.Material = Enum.Material.Neon	
end	

function IceMode()
	for _,v in next, LWing:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 0 v.BrickColor = BrickColor.new'Pastel light blue' end
	end
	for _,v in next, RWing:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 0 v.BrickColor = BrickColor.new'Pastel light blue' end
	end
	for _,v in next, LWingEXT:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 1 v.BrickColor = BrickColor.new'Pastel light blue' end
	end
	for _,v in next, RWingEXT:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 1 v.BrickColor = BrickColor.new'Pastel light blue' end
	end
	for _,v in next, Halo:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.BrickColor = BrickColor.new'Pastel light blue' end
	end
	pcall(function() Char.ReaperShadowHead.Eye1.Color = C3.N(0,1,1) end)
	pcall(function() Char.ReaperShadowHead.Eye2.Color = C3.N(0,1,1) end)
	WalkSpeed = 8
	RecolorTextAndRename("SubZero",C3.N(0,1,1),C3.N(1,1,1))
	MusicID = 144121562
	Pitch = 1
	Mode = 7
	Core2.BrickColor = BrickColor.new'Pastel light blue'
	Core2.Material = Enum.Material.Neon	
end

function LoveMode()
	for _,v in next, LWing:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 0 v.BrickColor = BrickColor.new'Pink' end
	end
	for _,v in next, RWing:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 0 v.BrickColor = BrickColor.new'Pink' end
	end
	for _,v in next, LWingEXT:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 1 v.BrickColor = BrickColor.new'Pink' end
	end
	for _,v in next, RWingEXT:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 1 v.BrickColor = BrickColor.new'Pink' end
	end
	for _,v in next, Halo:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.BrickColor = BrickColor.new'Pink' end
	end
	pcall(function() Char.ReaperShadowHead.Eye1.Color = BrickColor.new'Pink'.Color end)
	pcall(function() Char.ReaperShadowHead.Eye2.Color = BrickColor.new'Pink'.Color end)
	WalkSpeed = 16
	RecolorTextAndRename("Love",BrickColor.new'Pink'.Color,C3.N(1,1,1))
	MusicID = 1030177093
	Pitch = 1
	Mode = 8
	Core2.BrickColor = BrickColor.new'Pink'
	Core2.Material = Enum.Material.Neon	
end



function VisMode()
	for _,v in next, LWing:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 0 v.BrickColor = BrickColor.new'Institutional white' end
	end
	for _,v in next, RWing:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 0 v.BrickColor = BrickColor.new'Institutional white' end
	end
	for _,v in next, LWingEXT:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 1 v.BrickColor = BrickColor.new'Institutional white' end
	end
	for _,v in next, RWingEXT:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 1 v.BrickColor = BrickColor.new'Institutional white' end
	end
	for _,v in next, Halo:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.BrickColor = BrickColor.new'Institutional white' end
	end
	pcall(function() Char.ReaperShadowHead.Eye1.Color = C3.N(1,1,1) end)
	pcall(function() Char.ReaperShadowHead.Eye2.Color = C3.N(1,1,1) end)
	WalkSpeed = 16
	RecolorTextAndRename("Visualiser",C3.N(1,1,1),C3.N(0,0,0))
	MusicID = VisSong
	Pitch = 1
	Mode = 6
	Core2.BrickColor = BrickColor.new'White'
	Core2.Material = Enum.Material.Neon	
end	

function ToxicMode()
	for _,v in next, LWing:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 0 v.BrickColor = BrickColor.new'Lime green' end
	end
	for _,v in next, RWing:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = .85 v.BrickColor = BrickColor.new'Forest green' end
	end
	for _,v in next, LWingEXT:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = .75 v.BrickColor = BrickColor.new'Forest green' end
	end
	for _,v in next, RWingEXT:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 1 v.BrickColor = BrickColor.new'Forest green' end
	end
	for _,v in next, Halo:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.BrickColor = BrickColor.new'Lime green' end
	end
	pcall(function() Char.ReaperShadowHead.Eye1.Color = BrickColor.new'Lime green'.Color end)
	pcall(function() Char.ReaperShadowHead.Eye2.Color = BrickColor.new'Lime green'.Color end)
	WalkSpeed = 14
	RecolorTextAndRename("Nuclear",BrickColor.new'Lime green'.Color,C3.N(0,.6,0))
	MusicID = 798163149
	Pitch = 1
	Mode = 9
	Core2.BrickColor = BrickColor.new'Lime green'
	Core2.Material = Enum.Material.Neon	
end

function BarracudaMode()
	for _,v in next, LWing:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 0 v.BrickColor = BrickColor.new'New Yeller' end
	end
	for _,v in next, RWing:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 0 v.BrickColor = BrickColor.new'New Yeller' end
	end
	for _,v in next, LWingEXT:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = .5 v.BrickColor = BrickColor.new'New Yeller' end
	end
	for _,v in next, RWingEXT:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = .5 v.BrickColor = BrickColor.new'New Yeller' end
	end
	for _,v in next, Halo:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.BrickColor = BrickColor.new'New Yeller' end
	end
	pcall(function() Char.ReaperShadowHead.Eye1.Color = BrickColor.new'Lime green'.Color end)
	pcall(function() Char.ReaperShadowHead.Eye2.Color = BrickColor.new'Lime green'.Color end)
	WalkSpeed = 24
	RecolorTextAndRename("Ancient",BrickColor.new'New Yeller'.Color,C3.N(1,1,1))
	MusicID = 256251217
	Pitch = 1
	Mode = 16
	Core2.BrickColor = BrickColor.new'New Yeller'
	Core2.Material = Enum.Material.Neon	
end

function FluctuateMode()
	for _,v in next, LWing:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 0 v.BrickColor = BrickColor.new'Alder' end
	end
	for _,v in next, RWing:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 0 v.BrickColor = BrickColor.new'Alder' end
	end
	for _,v in next, LWingEXT:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 1 v.BrickColor = BrickColor.new'Alder' end
	end
	for _,v in next, RWingEXT:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 1 v.BrickColor = BrickColor.new'Alder' end
	end
	for _,v in next, Halo:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.BrickColor = BrickColor.new'Alder' end
	end
	pcall(function() Char.ReaperShadowHead.Eye1.Color = BrickColor.new'Alder'.Color end)
	pcall(function() Char.ReaperShadowHead.Eye2.Color = BrickColor.new'Alder'.Color end)
	WalkSpeed = 18
	RecolorTextAndRename("FLUCTUATION",BrickColor.new'Alder'.Color,C3.N(1,1,1))
	MusicID = 1047567668
	Pitch = 1
	Mode = 10
	Core2.BrickColor = BrickColor.new'Alder'
	Core2.Material = Enum.Material.Neon	
end

function InsaneMode()
	Attack = true
	NeutralAnims = false
	local Sin = 0
	MusicID = 919231299
	Pitch = 1
	WalkSpeed = 0
	Sound(Core2,136007472,1.25,2.5,false,true,true)
	for i = 0, 4, 0.1 do
		swait()
		NoobySphere(2.5,-1.5,'Multiply',Core2.CFrame*CF.A(M.RRNG(-180,180),M.RRNG(-180,180),M.RRNG(-180,180)),V3.N(3.5,3.5,45),-.035,Core2.Color,100)
		Sin = Sin + 5
		local Alpha = .1
		RJ.C0 = clerp(RJ.C0,CFrame.new(-0.00700476859, 0.0667984039, -0.448462069, 0.999972343, -0.00723911775, -0.00172879919, 0.00722799823, 0.88917774, 0.457504779, -0.00177471992, -0.457504541, 0.889205575),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.497889668, -1.14359522, -0.0677340925, 0.999878228, 0.00722799823, 0.0138372099, -9.56082804e-05, 0.88917774, -0.457561791, -0.0156109957, 0.457504779, 0.889070213),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.497117043, -1.14809179, -0.0749855936, 0.999878228, 0.00722799823, 0.0138372099, -9.56082804e-05, 0.88917774, -0.457561791, -0.0156109957, 0.457504779, 0.889070213),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.20745349, 0.562693655, 0.156515986, 0.841866791, -0.539501786, -0.014077506, -0.490290582, -0.753652692, -0.43774724, 0.225555882, 0.375426948, -0.898987949)*CF.A(0,M.R(0+16*M.S(Sin)),0),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.17680144, 0.613272369, 0.0997506529, 0.834507108, 0.550817847, -0.0140647329, 0.49015516, -0.753777146, -0.437684804, -0.251686275, 0.358357221, -0.899018526)*CF.A(0,M.R(0+16*M.S(Sin)),0),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(6.50798393e-06, 1.53005648, -0.348988175, 1.00000012, 2.40840018e-06, -1.19656324e-05, 5.68898395e-06, 0.775360823, 0.631518543, 1.07986853e-05, -0.631518602, 0.775360942)*CF.A(0,M.R(0+16*M.S(Sin)),0),Alpha)
	end
	for i = 0, 8, 0.1 do
		swait()
		NoobySphere(2.5,-1.5,'Multiply',Core2.CFrame*CF.A(M.RRNG(-180,180),M.RRNG(-180,180),M.RRNG(-180,180)),V3.N(3.5,3.5,45),-.035,Core2.Color,100)
		NoobySphere(2.5,1.5,'Multiply',Core2.CFrame*CF.A(M.RRNG(-180,180),M.RRNG(-180,180),M.RRNG(-180,180)),V3.N(3.5,3.5,45),.035,Core2.Color,0)
		Sin = Sin + 5
		local Alpha = .1
		RJ.C0 = clerp(RJ.C0,CFrame.new(-0.00700476859, 0.0667984039, -0.448462069, 0.999972343, -0.00723911775, -0.00172879919, 0.00722799823, 0.88917774, 0.457504779, -0.00177471992, -0.457504541, 0.889205575),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.497889668, -1.14359522, -0.0677340925, 0.999878228, 0.00722799823, 0.0138372099, -9.56082804e-05, 0.88917774, -0.457561791, -0.0156109957, 0.457504779, 0.889070213),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.497117043, -1.14809179, -0.0749855936, 0.999878228, 0.00722799823, 0.0138372099, -9.56082804e-05, 0.88917774, -0.457561791, -0.0156109957, 0.457504779, 0.889070213),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.20745349, 0.562693655, 0.156515986, 0.841866791, -0.539501786, -0.014077506, -0.490290582, -0.753652692, -0.43774724, 0.225555882, 0.375426948, -0.898987949)*CF.A(0,M.R(0+16*M.S(Sin)),0),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.17680144, 0.613272369, 0.0997506529, 0.834507108, 0.550817847, -0.0140647329, 0.49015516, -0.753777146, -0.437684804, -0.251686275, 0.358357221, -0.899018526)*CF.A(0,M.R(0+16*M.S(Sin)),0),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(6.50798393e-06, 1.53005648, -0.348988175, 1.00000012, 2.40840018e-06, -1.19656324e-05, 5.68898395e-06, 0.775360823, 0.631518543, 1.07986853e-05, -0.631518602, 0.775360942)*CF.A(0,M.R(0+16*M.S(Sin)),0),Alpha)
	end
	for _,v in next, LWing:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 0 v.BrickColor = BrickColor.new'Really black' end
	end
	for _,v in next, RWing:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = 0 v.BrickColor = BrickColor.new'Black' end
	end
	for _,v in next, LWingEXT:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = .5 v.BrickColor = BrickColor.new'Really black' end
	end
	for _,v in next, RWingEXT:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.Transparency = .5 v.BrickColor = BrickColor.new'Black' end
	end
	for _,v in next, Halo:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Neon v.BrickColor = BrickColor.new'Black' end
	end
	pcall(function() Char.ReaperShadowHead.Eye1.Color = C3.N(1,0,0) end)
	pcall(function() Char.ReaperShadowHead.Eye2.Color = C3.N(1,0,0) end)
	WalkSpeed = 12
	Mode = 696969
	Core2.BrickColor = BrickColor.new'Black'
	Core2.Material = Enum.Material.Neon
	Sound(Root,"206082327",1,2.5,false,true,true)
	Sound(Root,"847061203",1,5,false,true,true)
	Sound(Root,"239000203",1,2.5,false,true,true)
	Sound(Root,"579687077",.75,2.5,false,true,true)
	RecolorTextAndRename("INSANITY",Color3.new(0,0,0),Color3.new(1,1,1))
	NoobySphere2(2.5,'Multiply',Core2.CFrame,V3.N(0,0,0),1,Core2.BrickColor)
	for i = 1, 24 do
		NoobyBlock(1,M.RNG(20,100)/100,'Multiply',Core2.CFrame*CF.A(M.RRNG(-180,180),M.RRNG(-180,180),M.RRNG(-180,180)),V3.N(2,2,2),.04,Core2.Color,0,true)
	end
	for i = 0, 15 do
		NoobySphere(3,-.5,'Multiply',Core2.CFrame*CF.A(M.RRNG(-180,180),M.RRNG(-180,180),M.RRNG(-180,180)),V3.N(.5,.5,25),-.04,Core2.Color,0)
	end
	for i = 0, 1.4, 0.1 do
		swait()
		local Alpha = .3
		RJ.C0 = clerp(RJ.C0,CFrame.new(0.0104959598, -0.113952652, 0.672263861, 0.999963522, 0.00820299331, -0.0023882892, -0.00821700692, 0.846846819, -0.531773448, -0.00233961921, 0.531773746, 0.846883237),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.49749428, -1.06169748, -0.0426189601, 0.999878228, -0.00744201383, 0.013721575, -0.000100045589, 0.875963986, 0.482376754, -0.0156094572, -0.482319295, 0.875856459),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.498449236, -1.1497941, 0.0108022094, 0.999878228, -0.0120362351, 0.009939529, -0.000100045589, 0.631795883, 0.775134981, -0.0156094572, -0.775041461, 0.631717622),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.12307608, 0.484921068, 0.092245549, 0.865161359, 0.501252413, -0.0155520458, 0.497926384, -0.862286389, -0.092366755, -0.059709385, 0.07216838, -0.995603561),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.37669122, 0.484069884, 0.0531393886, 0.866546988, -0.498853445, -0.0155524863, -0.49802509, -0.862227678, -0.0923835635, 0.032676056, 0.0878001451, -0.995602131),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(1.14440181e-05, 1.49895036, -0.0144141242, 1.00000012, 0, -9.31322575e-10, 0, 0.99796474, 0.0637694895, -9.31322575e-10, -0.0637694895, 0.99796468),Alpha)
	end
	Attack = false
	NeutralAnims = true
end
game.Players.LocalPlayer.Character["Evil Aura"].Handle:BreakJoints()



local aura = game.Players.LocalPlayer.Character["Evil Aura"].Handle
aura.Anchored = false


    attachment = Instance.new("Attachment", game.Players.LocalPlayer.Character["Evil Aura"].Handle)
    attachment.Position = Vector3.new(0, 0, 0) -- positioning
    attachment.Orientation = Vector3.new(0,90,95) -- orienation/rotation

    attachment02 = Instance.new("Attachment", game.Players.LocalPlayer.Character.Raw.Halo.Part) -- arm or part

    lol = Instance.new("AlignPosition", game.Players.LocalPlayer.Character["Evil Aura"].Handle)
    lol.Attachment0 = attachment
    lol.Attachment1 = attachment02
    lol.MaxForce = 67734
    lol.RigidityEnabled = true -- makes it not wobbly

    pog = Instance.new("AlignOrientation", game.Players.LocalPlayer.Character["Evil Aura"].Handle)
    pog.Attachment0 = attachment
    pog.Attachment1 = attachment02
    pog.Responsiveness = 200
    pog.RigidityEnabled = true-- makes it not wobbly


function RiddleMeThis()
	Attack = true
	NeutralAnims = false
	WalkSpeed = 0
	MusicID = 1420353940
	Pitch = 1
	Muted = true
	repeat swait() until Music.IsLoaded	
	Muted = false
	Music.TimePosition = 0
	Chat('Riddle me this..')
	for i = 0,14,.1 do
		local Alpha = .1
		RJ.C0 = clerp(RJ.C0,CFrame.new(2.74447132e-13, 0.00628674263, 4.19029675e-07, 0.99999994, 4.36557457e-11, 0, -4.3652193e-11, 0.999980211, -0.00628619269, 9.31322575e-10, 0.00628619175, 0.999980271),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.496486187, -0.990816116, 0.0216199569, 0.999878109, -9.59694546e-11, 0.015612145, -9.81408521e-05, 0.999980211, 0.00628542574, -0.0156118376, -0.00628619269, 0.999858439),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.498537898, -0.990978718, 0.0154640805, 0.999878109, -9.59694546e-11, 0.015612145, -9.81408521e-05, 0.999980211, 0.00628542574, -0.0156118376, -0.00628619269, 0.999858439),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.15619826, 0.410764694, 0.308931053, 0.862226903, -0.506325424, 0.0141164251, 0.451236814, 0.780479908, 0.432708263, -0.230108798, -0.366722882, 0.901423633),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.48984146, 0.433965802, -0.137121022, 0.754978359, -0.655723989, -0.00581999123, -0.244246826, -0.272958666, -0.930503726, 0.608564973, 0.703931689, -0.366236359),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(8.11554492e-06, 1.49894369, -0.0144015253, 0.931422114, -1.17415329e-05, -0.363940746, 0.0232203864, 0.997964501, 0.0593950115, 0.363199264, -0.0637726635, 0.929526567),Alpha)
		swait()
	end
	Chat('Riddle me that..')
	for i = 0,12,.1 do
		local Alpha = .1
		RJ.C0 = clerp(RJ.C0,CFrame.new(2.74447132e-13, 0.00628674868, -5.34626452e-07, 0.99999994, 4.36557457e-11, 0, -4.3652193e-11, 0.999980211, -0.00628619269, 9.31322575e-10, 0.00628619175, 0.999980271),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.49648428, -0.990818024, 0.0216189846, 0.999878109, -9.59694546e-11, 0.015612145, -9.81408521e-05, 0.999980211, 0.00628542574, -0.0156118376, -0.00628619269, 0.999858439),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.498537898, -0.990980625, 0.0154631399, 0.999878109, -9.59694546e-11, 0.015612145, -9.81408521e-05, 0.999980211, 0.00628542574, -0.0156118376, -0.00628619269, 0.999858439),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.25402236, 0.431008309, 0.117451549, 0.884577334, 0.388638854, 0.257842481, 0.312682211, -0.0839776248, -0.946138322, -0.346053123, 0.917555273, -0.195805177),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.22954941, 0.384757012, 0.168471783, 0.915931404, 0.401068091, 0.0146304797, -0.379809946, 0.85445267, 0.354478538, 0.129668966, -0.330234885, 0.934949815),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(8.37445259e-06, 1.49894357, -0.0144015923, 0.920970619, 2.08709389e-06, 0.389632136, -0.0248486493, 0.99796474, 0.058729209, -0.388839096, -0.063769713, 0.919096231),Alpha)
		swait()	
	end
	Chat("Who's afraid of the big black..")
	for i = 0,16,.1 do
		local Alpha = .1
		RJ.C0 = clerp(RJ.C0,CFrame.new(-0.00438984111, 0.0221795738, -0.281239897, 0.999988556, -0.00473595224, -0.000703255646, 0.00473099947, 0.954816878, 0.297157228, -0.000735841691, -0.297157168, 0.954828322),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.497070849, -1.04715037, -0.0156083405, 0.999878228, 0.00473099947, 0.0148762148, -9.61141777e-05, 0.954816878, -0.297194898, -0.0156100877, 0.297157228, 0.954700947),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.49794969, -1.05015182, -0.0222227573, 0.999878228, 0.00473099947, 0.0148762148, -9.61141777e-05, 0.954816878, -0.297194898, -0.0156100877, 0.297157228, 0.954700947),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.32246351, 0.253595859, 0.199904889, 0.862232804, -0.506315708, 0.0141151678, 0.451225579, 0.780480325, 0.432719588, -0.230109304, -0.366735876, 0.90141809),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.33073413, 0.290129036, 0.183640629, 0.915928423, 0.401075214, 0.0146333817, -0.379820168, 0.854456067, 0.354459614, 0.129661351, -0.330217659, 0.934956849),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(1.58162902e-06, 1.5248462, -0.171738505, 1.00000012, -7.59866089e-06, 1.38636678e-05, -3.15252692e-07, 0.867144346, 0.498057216, -1.58054754e-05, -0.498057246, 0.867144227),Alpha)
		swait()
	end
	for i = 0, .7, 0.1 do
		swait()
		local Alpha = .3
		RJ.C0 = clerp(RJ.C0,CFrame.new(-0.00700476859, 0.0667984039, -0.448462069, 0.999972343, -0.00723911775, -0.00172879919, 0.00722799823, 0.88917774, 0.457504779, -0.00177471992, -0.457504541, 0.889205575),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.497889668, -1.14359522, -0.0677340925, 0.999878228, 0.00722799823, 0.0138372099, -9.56082804e-05, 0.88917774, -0.457561791, -0.0156109957, 0.457504779, 0.889070213),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.497117043, -1.14809179, -0.0749855936, 0.999878228, 0.00722799823, 0.0138372099, -9.56082804e-05, 0.88917774, -0.457561791, -0.0156109957, 0.457504779, 0.889070213),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.20745349, 0.562693655, 0.156515986, 0.841866791, -0.539501786, -0.014077506, -0.490290582, -0.753652692, -0.43774724, 0.225555882, 0.375426948, -0.898987949),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.17680144, 0.613272369, 0.0997506529, 0.834507108, 0.550817847, -0.0140647329, 0.49015516, -0.753777146, -0.437684804, -0.251686275, 0.358357221, -0.899018526),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(6.50798393e-06, 1.53005648, -0.348988175, 1.00000012, 2.40840018e-06, -1.19656324e-05, 5.68898395e-06, 0.775360823, 0.631518543, 1.07986853e-05, -0.631518602, 0.775360942),Alpha)
	end

	for _,v in next, LWing:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Glass v.Transparency = 0 v.BrickColor = BrickColor.new'Really black' end
	end
	for _,v in next, RWing:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Glass v.Transparency = 0 v.BrickColor = BrickColor.new'Really black' end
	end
	for _,v in next, LWingEXT:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Glass v.Transparency = .25 v.BrickColor = BrickColor.new'Medium stone grey' end
	end
	for _,v in next, RWingEXT:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Glass v.Transparency = .25 v.BrickColor = BrickColor.new'Medium stone grey' end
	end
	for _,v in next, Halo:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Glass v.BrickColor = BrickColor.new'Really black' end
	end
	pcall(function() Char.ReaperShadowHead.Eye1.Color = BrickColor.new'Black'.Color end)
	pcall(function() Char.ReaperShadowHead.Eye2.Color = BrickColor.new'Black'.Color end)
	WalkSpeed = 50
	RecolorTextAndRename("The Big Black",BrickColor.new'Really black'.Color,C3.N(1,1,1))
	Core2.BrickColor = BrickColor.new'Really black'
	Core2.Material = Enum.Material.Glass	
	Mode = 666666666666
	Sound(Root,"206082327",1,2.5,false,true,true)
	Sound(Root,"847061203",1,5,false,true,true)
	Sound(Root,"239000203",1,2.5,false,true,true)
	Sound(Root,"579687077",.75,2.5,false,true,true)
	NoobySphere2(2.5,'Multiply',Core2.CFrame,V3.N(0,0,0),1,Core2.BrickColor)
	for i = 1, 24 do
		NoobyBlock(1,M.RNG(20,100)/100,'Multiply',Core2.CFrame*CF.A(M.RRNG(-180,180),M.RRNG(-180,180),M.RRNG(-180,180)),V3.N(2,2,2),.04,Core2.Color,0,true)
	end
	for i = 0, 15 do
		NoobySphere(3,-.5,'Multiply',Core2.CFrame*CF.A(M.RRNG(-180,180),M.RRNG(-180,180),M.RRNG(-180,180)),V3.N(.5,.5,25),-.04,Core2.Color,0)
	end
	for i = 0, .7, 0.1 do
		swait()
		local Alpha = .3
		RJ.C0 = clerp(RJ.C0,CFrame.new(0.0104959598, -0.113952652, 0.672263861, 0.999963522, 0.00820299331, -0.0023882892, -0.00821700692, 0.846846819, -0.531773448, -0.00233961921, 0.531773746, 0.846883237),Alpha)
		LH.C0 = clerp(LH.C0,CFrame.new(-0.49749428, -1.06169748, -0.0426189601, 0.999878228, -0.00744201383, 0.013721575, -0.000100045589, 0.875963986, 0.482376754, -0.0156094572, -0.482319295, 0.875856459),Alpha)
		RH.C0 = clerp(RH.C0,CFrame.new(0.498449236, -1.1497941, 0.0108022094, 0.999878228, -0.0120362351, 0.009939529, -0.000100045589, 0.631795883, 0.775134981, -0.0156094572, -0.775041461, 0.631717622),Alpha)
		LS.C0 = clerp(LS.C0,CFrame.new(-1.12307608, 0.484921068, 0.092245549, 0.865161359, 0.501252413, -0.0155520458, 0.497926384, -0.862286389, -0.092366755, -0.059709385, 0.07216838, -0.995603561),Alpha)
		RS.C0 = clerp(RS.C0,CFrame.new(1.37669122, 0.484069884, 0.0531393886, 0.866546988, -0.498853445, -0.0155524863, -0.49802509, -0.862227678, -0.0923835635, 0.032676056, 0.0878001451, -0.995602131),Alpha)
		NK.C0 = clerp(NK.C0,CFrame.new(1.14440181e-05, 1.49895036, -0.0144141242, 1.00000012, 0, -9.31322575e-10, 0, 0.99796474, 0.0637694895, -9.31322575e-10, -0.0637694895, 0.99796468),Alpha)
	end
	Attack = false
	NeutralAnims = true
end

function L_O_S_T()
	for _,v in next, LWing:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Glass v.Transparency = 0 v.Color = C3.N(.4,0,0) end
	end
	for _,v in next, RWing:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Glass v.Transparency = 0 v.Color = C3.N(.4,0,0) end
	end
	for _,v in next, LWingEXT:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Glass v.Transparency = 0 v.Color = C3.N(.4,0,0) end
	end
	for _,v in next, RWingEXT:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Glass v.Transparency = 0 v.Color = C3.N(.4,0,0) end
	end
	for _,v in next, Halo:children() do
		if(v:IsA'BasePart' and v.Name ~= 'Main')then v.Material = Enum.Material.Glass v.Color = C3.N(.4,0,0) end
	end
	pcall(function() Char.ReaperShadowHead.Eye1.Color = C3.N(.4,0,0) end)
	pcall(function() Char.ReaperShadowHead.Eye2.Color = C3.N(.4,0,0) end)
	WalkSpeed = 24
	RecolorTextAndRename("L O S T  S O U L",BrickColor.new'Crimson'.Color,C3.N(0,0,0))
	MusicID = 343860759
	Pitch = .9
	Mode = 666
	Core2.Color = C3.N(.4,0,0)
	Core2.Material = Enum.Material.Neon	
end

--// Wrap it all up \\--

Plr.Chatted:connect(function(msg)
	if(msg:sub(1,5) == "play/" and Mode == 6)then
		local info = game.MarketplaceService:GetProductInfo(tonumber(msg:sub(6)))
		if(info and info.Name)then
			Chat("Playing: "..info.Name,'rainbow')
		end
		MusicID = msg:sub(6)
		VisSong = msg:sub(6)
	elseif(msg:sub(1,5) == 'tpos/' and Mode == 6)then
		Music.TimePosition = tonumber(msg:sub(6))
	end	
end)

function KeyPress(code)
	if(code == Enum.KeyCode.One and Mode ~= 1)then
		MurderMode()
	elseif(code == Enum.KeyCode.Two and Mode ~= 2)then
		PureMode()
	elseif(code == Enum.KeyCode.Three and Mode ~= 3)then
		GlitchMode()
	elseif(code == Enum.KeyCode.Four and Mode ~= 4)then
		StressMode()
	elseif(code == Enum.KeyCode.Five and Mode ~= 5)then
		JusticeMode()
	elseif(code == Enum.KeyCode.Six and Mode ~= 6)then
		VisMode()
	elseif(code == Enum.KeyCode.Seven and Mode ~= 7)then
		IceMode()
	elseif(code == Enum.KeyCode.Eight and Mode ~= 8)then
		LoveMode()
	elseif(code == Enum.KeyCode.Nine and Mode ~= 9)then
		ToxicMode()
	elseif(code == Enum.KeyCode.Zero and Mode ~= 10)then
		FluctuateMode()
	-- Transformations
	elseif(code == Enum.KeyCode.T)then
		if(Mode == 1)then
			RiddleMeThis()
		elseif(Mode == 4)then
			InsaneMode()
		elseif(Mode == 666666666666)then
			L_O_S_T()
		elseif(Mode == 666)then
			MurderMode()
		elseif(Mode == 696969)then
			StressMode()
		elseif(Mode == 10)then
			BarracudaMode()
		end
	-- Toggle player attacking
	elseif(code == Enum.KeyCode.Semicolon)then
		DontAttackPlayers = not DontAttackPlayers
		Chat(DontAttackPlayers and "You can no longer attack players" or "You can now attack players")
	-- Attacks
	elseif(code == Enum.KeyCode.Z)then
		if(Mode == 1)then
			if(not UIS.TouchEnabled)then MurderNigger((Mouse.Target and Mouse.Target.Parent)) else Output("Note","Tap someone, to murder them") MobileMurder() end
		elseif(Mode == 666666666666)then
			if(not UIS.TouchEnabled)then NeckSnap((Mouse.Target and Mouse.Target.Parent)) else Output("Note","Tap someone, to snap their neck") MobileNeckSnap() end

		elseif(Mode == 2)then
			PureBomb()
		elseif(Mode == 3)then
			ClickGlitch()
		elseif(Mode == 4)then
			Shrek()
		elseif(Mode == 5)then
			Aeroplane()
		elseif(Mode == 6)then
			SongSmash()
		end
	end
end

function AttackCombo()
	if(Combo == 1)then AttackOne() elseif(Combo == 2)then AttackTwo() elseif(Combo == 3)then AttackThree() end
end

-- Mode Changing Keys

function BuildButton(name,pos,act,image)
	if(UIS.TouchEnabled)then
		local func = function()
			if(not Attack)then
				act()
			end
		end
		local downID = 97166756;
		local upID = 97166444;
		local bPos = UDim2.new(.72,-pos.x,.20,-pos.y)
		
		local button = MobileButton:Clone();
		button.Parent = MobileGUI
		button.ActionTitle.Text = name
		button.MouseButton1Down:connect(function()
			button.Image = 'rbxassetid://'..downID
			func()
		end)
		button.MouseButton1Up:connect(function()
			button.Image = 'rbxassetid://'..upID
		end)
		button.MouseLeave:connect(function()
			button.Image = 'rbxassetid://'..upID
		end)
		button.Position = bPos
		if(image)then
			button.ActionTitle:destroy()
			button.ActionIcon.Image = 'rbxassetid://'..image
		end
		return button;
	end
end
local keys = {"One","Two","Three","Four","Five","Six","Seven","Eight","Nine","Zero"}

function BuildModeButton(name,pos,act,number)
	if(UIS.TouchEnabled)then
		local func = function()
			if(not Attack and Mode ~= number)then
				act()
			end
		end
		local downID = 97166756;
		local upID = 97166444;
		local bPos = UDim2.new(.72,-pos.x,.20,-pos.y)
		
		local button = MobileButton:Clone();
		button.Parent = MobileGUI
		button.ActionTitle.Text = name
		button.MouseButton1Down:connect(function()
			button.Image = 'rbxassetid://'..downID
			func()
		end)
		button.MouseButton1Up:connect(function()
			button.Image = 'rbxassetid://'..upID
		end)
		button.MouseLeave:connect(function()
			button.Image = 'rbxassetid://'..upID
		end)
		button.Position = bPos
		return button;
	end
end

if(UIS.TouchEnabled)then
	Output("Warn","FYI, not all moves will be mobile supporting in the future.")
	local ModeButtons = {}
	
	table.insert(ModeButtons,BuildModeButton("Murder",Vector2.new(500,205),MurderMode,1))
	table.insert(ModeButtons,BuildModeButton("Clarity",Vector2.new(500,155),PureMode,2))
	table.insert(ModeButtons,BuildModeButton("Glitchy",Vector2.new(500,105),GlitchMode,3))
	table.insert(ModeButtons,BuildModeButton("Stress",Vector2.new(500,55),StressMode,4))
	table.insert(ModeButtons,BuildModeButton("Justice",Vector2.new(500,5),JusticeMode,5))
	table.insert(ModeButtons,BuildModeButton("Visual",Vector2.new(450,205),VisMode,6))
	table.insert(ModeButtons,BuildModeButton("SubZero",Vector2.new(450,155),IceMode,7))
	table.insert(ModeButtons,BuildModeButton("Love",Vector2.new(450,105),LoveMode,8))
	table.insert(ModeButtons,BuildModeButton("Nuclear",Vector2.new(450,55),ToxicMode,9))
	table.insert(ModeButtons,BuildModeButton("FLUCTUATE",Vector2.new(450,5),FluctuateMode,10))
	
	local HideB;
	local Hiding = false;
	HideB = BuildButton("Hide",Vector2.new(550,205),function() Hiding = not Hiding; for _,v in next, ModeButtons do v.Visible = not Hiding; end HideB.ActionTitle.Text = (Hiding and 'Show' or 'Hide') end)
	
	BuildButton("Attack",Vector2.new(0,0),AttackCombo,1826947151)
	
	BuildButton("Z",Vector2.new(25,100),function() KeyPress(Enum.KeyCode.Z) end)
	BuildButton("X",Vector2.new(75,50),function() KeyPress(Enum.KeyCode.X) end)
	BuildButton("C",Vector2.new(75,150),function() KeyPress(Enum.KeyCode.C) end)
	BuildButton("V",Vector2.new(125,100),function() KeyPress(Enum.KeyCode.V) end)
end

UIS.InputBegan:connect(function(io,gpe)
	if(Attack)then return end
	if(not gpe)then
		local code = io.KeyCode;
		if(io.UserInputType == Enum.UserInputType.Keyboard)then
			KeyPress(code)
		elseif(io.UserInputType == Enum.UserInputType.MouseButton1)then
			AttackCombo()
		end
	end
end)


coroutine.wrap(function()
	-- AURAS
	while true do		
		if(Mode == 5)then
			NoobySphere(5,0.15,"Multiply",Root.CFrame*CF.N(M.RNG(-5,5),-6,M.RNG(-5,5))*CF.A(M.R(90),0,0),V3.N(1.5,1.5,10),-0.015,BrickColor.new'White',0)
		elseif(Mode == 10 or Mode == 666666666666)then
			NoobySphere(5,math.random(25,75)/100,"Multiply",Root.CFrame*CF.N(M.RNG(-15,15),-10,M.RNG(-15,15))*CF.A(M.R(90),0,0)*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),V3.N(.75,.75,15),.005,Core2.BrickColor,0)			
		end
		if(Mode == 666666666666)then
			NoobySphere(5,math.random(75,150)/100,"Multiply",Root.CFrame*CF.N(M.RNG(-35,35),-10,M.RNG(-35,35))*CF.A(M.R(90),0,0)*CF.A(M.RRNG(-25,25),M.RRNG(-25,25),M.RRNG(-25,25)),V3.N(.75,.75,25),.005,Core2.BrickColor,0)					
		end
		swait(1)
	end
end)()

coroutine.resume(coroutine.create(function() -- Burning Damge Loop
	while true do
		swait(1)
		for who,data in next, Radioactive do
			local lastBurn, burnMaxTime = unpack(data)
			if(time()-lastBurn >= BurnInterval)then
				data[1] = time()
				for _,v in next, who:children() do if(v.Name == 'Health' and v:IsA'Script')then v.Disabled = true end end
				local hum = who:FindFirstChildOfClass'Humanoid'
				local tors = GetTorso(who)
				if(hum and tors and hum.Health >= 0)then
					local BurnDamage = {4,12}
					local  c = Instance.new("ObjectValue",hum)
					c.Name = "creator"
					c.Value = Player
					game:service'Debris':AddItem(c,0.35)
					local DoneDamage = M.RNG(unpack(BurnDamage))
					Droplet{Size=.5,Color=BrickColor.new'Lime green',Direction=-(tors.CFrame.upVector*2000),Origin=tors.CFrame}
					local  c = Instance.new("ObjectValue",Hum)
					c.Name = "creator"
					c.Value = Player
					S.Debris:AddItem(c,0.35)
					if(Hits >= MaxHits/4)then
						local Mult = (DoneDamage*(Hits/MaxHits))*4
						DoneDamage = DoneDamage + Mult
					end
					if(hum.Health > 0)then	
						Hits = math.min(Hits + 1,MaxHits)
						HitTime = HitTime + .1
						if(who:FindFirstChild'Head')then
							ShowDamage((who.Head.CFrame * CF.N(0, 0, (who.Head.Size.Z / 2)).p+V3.N(0,1.5,0)+V3.N(M.RNG(-2,2),0,M.RNG(-2,2))), math.floor(DoneDamage), 1.5, BrickColor.new'Forest green'.Color)
						end
						if(hum.Health-DoneDamage <= 0)then print'Got kill' end
						hum.MaxHealth = hum.MaxHealth - DoneDamage
					end
				end
				if(time() >= burnMaxTime or hum and hum.Health <= 0)then
					Radioactive[who] = nil;
					for _,v in next, who:children() do if(v.Name == 'Health' and v:IsA'Script')then v.Disabled = false end end
				end
			end
		end
	end
end))

game:GetService("Players").LocalPlayer.Character.Raw.LeftWing.Main.Name = "Main1"
game:GetService("Players").LocalPlayer.Character.Raw.LeftWing.Main.Name = "Main2"
game:GetService("Players").LocalPlayer.Character.Raw.LeftWing.Main.Name = "Main3"
game:GetService("Players").LocalPlayer.Character.Raw.RightWing.Main.Name = "Main1"
game:GetService("Players").LocalPlayer.Character.Raw.RightWing.Main.Name = "Main2"
game:GetService("Players").LocalPlayer.Character.Raw.RightWing.Main.Name = "Main3"


game.Players.LocalPlayer.Character.Sword1.Handle:BreakJoints()
align(game.Players.LocalPlayer.Character.Sword1.Handle, game.Players.LocalPlayer.Character.Raw.LeftWing.Main1)
game.Players.LocalPlayer.Character.Sword2.Handle:BreakJoints()
align(game.Players.LocalPlayer.Character.Sword2.Handle, game.Players.LocalPlayer.Character.Raw.LeftWing.Main2)

game.Players.LocalPlayer.Character.Sword3.Handle:BreakJoints()
align(game.Players.LocalPlayer.Character.Sword3.Handle, game.Players.LocalPlayer.Character.Raw.RightWing.Main2)

game.Players.LocalPlayer.Character.Sword4.Handle:BreakJoints()
align(game.Players.LocalPlayer.Character.Sword4.Handle, game.Players.LocalPlayer.Character.Raw.RightWing.Main1)
game.Players.LocalPlayer.Character.BladeMasterAccessory.Handle:BreakJoints()
align(game.Players.LocalPlayer.Character.BladeMasterAccessory.Handle, game.Players.LocalPlayer.Character.Raw.LeftWing.Main3)
game.Players.LocalPlayer.Character.ShadowBladeMasterAccessory.Handle:BreakJoints()
align(game.Players.LocalPlayer.Character.ShadowBladeMasterAccessory.Handle, game.Players.LocalPlayer.Character.Raw.RightWing.Main3)





while true do
	swait()
	Sine = Sine + Change
	WingSine = WingSine + WingChange
	if(Hue > 360)then Hue = 0 end
	Hue = Hue + 1
	
	if(not Music or not Music.Parent)then
		local tPos = 0;
		if(Music)then tPos = Music.TimePosition; Music:Stop(); Music:Destroy(); end
		Music = Sound(Char,MusicID,1,3,true,false,true)
		Music.Name = 'Music'
		Music.TimePosition = tPos;
	end
	Music.SoundId = "rbxassetid://"..MusicID
	Music.Parent = Char
	Music.Pitch = Pitch
	Music.Volume = 2
	if(not Muted)then
		Music:Resume()
	else
		Music:Pause()
	end
	
	if(God)then
		Hum.MaxHealth = 1e100
		Hum.Health = 1e100
		if(not Char:FindFirstChildOfClass'ForceField')then IN("ForceField",Char).Visible = false end
		Hum.Name = M.RNG()*100
	end
	
	local hitfloor,posfloor,norm = workspace:FindPartOnRay(Ray.new(Root.CFrame.p,((CFrame.new(Root.Position,Root.Position - Vector3.new(0,1,0))).lookVector).unit * (4*PlayerSize)), Char)
	
	if(Mode == 3)then
		for _,v in next, LWing:children() do
			local what = M.RNG()
			if(v:IsA'BasePart')then
				v.Color = C3.N(what,what,what)
			end
		end
		for _,v in next, RWing:children() do
			local what = M.RNG()
			if(v:IsA'BasePart')then
				v.Color = C3.N(what,what,what)
			end
		end
		for _,v in next, LWingEXT:children() do
			local what = M.RNG()
			if(v:IsA'BasePart')then
				v.Color = C3.N(what,what,what)
			end
		end
		for _,v in next, RWingEXT:children() do
			local what = M.RNG()
			if(v:IsA'BasePart')then
				v.Color = C3.N(what,what,what)
			end
		end

		local what1 = M.RNG()
		local what2 = M.RNG()
		local what3 = M.RNG()
		local what4 = M.RNG()
		Core2.Color = C3.N(what1,what1,what1)
		
		for _,v in next, Halo:children() do
			if(v:IsA'BasePart')then
				v.Color = C3.N(what1,what1,what1)
			end
		end
		
		text.TextStrokeColor3 = C3.N(what2,what2,what2)
		text.TextColor3 = C3.N(what3,what3,what3)
		pcall(function() Char.ReaperShadowHead.Eye1.Color = C3.N(what4,what4,what4) end)
		pcall(function() Char.ReaperShadowHead.Eye2.Color = C3.N(what4,what4,what4) end)
	elseif(Mode == 4)then
		for _,v in next, LWing:children() do
			local what = M.RNG()*.5
			if(v:IsA'BasePart')then
				v.Color = C3.N(what,0,0)
			end
		end
		for _,v in next, LWingEXT:children() do
			local what = M.RNG()*.5
			if(v:IsA'BasePart')then
				v.Color = C3.N(what,0,0)
			end
		end

		local what1 = M.RNG()*.5
		local what2 = M.RNG()*.5
		local what3 = M.RNG()*.5
		local what4 = M.RNG()*.5
		Core2.Color = C3.N(what1,0,0)
		
		for _,v in next, Halo:children() do
			if(v:IsA'BasePart')then
				v.Color = C3.N(what1,0,0)
			end
		end
		
		text.TextStrokeColor3 = C3.N(what2,0,0)
		text.TextColor3 = C3.N(what3,0,0)
		pcall(function() Char.ReaperShadowHead.Eye1.Color = C3.N(what4,0,0) end)
		pcall(function() Char.ReaperShadowHead.Eye2.Color = C3.N(what4,0,0) end)
	elseif(Mode == 696969)then
		for _,v in next, LWing:children() do
			if(v:IsA'BasePart')then
				v.Color = C3.N(M.RNG()*.35,0,0)
			end
		end
		for _,v in next, LWingEXT:children() do
			if(v:IsA'BasePart')then
				v.Color = C3.N(M.RNG()*.35,0,0)
			end
		end

		Core2.Color = C3.N(M.RNG()*.35,0,0)
		
		for _,v in next, Halo:children() do
			if(v:IsA'BasePart')then
				v.Color = Core2.Color
			end
		end
		
		text.TextStrokeColor3 = C3.N(M.RNG()*.35,0,0)
		text.TextColor3 = C3.N(M.RNG()*.35,0,0)
		pcall(function() Char.ReaperShadowHead.Eye1.Color = C3.N(M.RNG()*.35,0,0) end)
		pcall(function() Char.ReaperShadowHead.Eye2.Color = C3.N(M.RNG()*.35,0,0)end)	
	elseif(Mode == 6)then
		local color = C3.HSV(Hue/360,1,math.min(pl/1000,1))
		local color2 = C3.HSV(Hue/360,1,math.min(pl/500,1))
		for _,v in next, LWing:children() do
			if(v:IsA'BasePart')then
				v.Color = v.Color:lerp(color,.3)
			end
		end
		for _,v in next, RWing:children() do
			if(v:IsA'BasePart')then
				v.Color = v.Color:lerp(color,.3)
			end
		end
		for _,v in next, LWingEXT:children() do
			if(v:IsA'BasePart')then
				v.Color = v.Color:lerp(color,.3)
			end
		end
		for _,v in next, RWingEXT:children() do
			if(v:IsA'BasePart')then
				v.Color = v.Color:lerp(color,.3)
			end
		end
		Core2.Color = Core2.Color:lerp(color,.3)
		
		for _,v in next, Halo:children() do
			if(v:IsA'BasePart')then
				v.Color = v.Color:lerp(color,.3)
			end
		end
		
		text.TextStrokeColor3 = text.TextStrokeColor3:lerp(color2,.3)
		text.TextColor3 = text.TextColor3:lerp(color2,.3)
		pcall(function() Char.ReaperShadowHead.Eye1.Color = Char.ReaperShadowHead.Eye1.Color:lerp(color,.3) end)
		pcall(function() Char.ReaperShadowHead.Eye2.Color = Char.ReaperShadowHead.Eye2.Color:lerp(color,.3) end)
	end
	
	LWingWelds[1].C0 = LWingWelds[1].C0:lerp(CF.N(0,0,2.25)*CF.A(0,M.R(-90),0)*CF.A(M.R(5+10*M.C(WingSine/32)),0,M.R(12.5+5*M.C(WingSine/32))),.1)
	LWingWelds[2].C0 = LWingWelds[2].C0:lerp(CF.N(0,1,3.5)*CF.A(0,M.R(-90),0)*CF.A(M.R(10+15*M.C(WingSine/32)),0,M.R(25+7.5*M.C(WingSine/32))),.1)
	LWingWelds[3].C0 = LWingWelds[3].C0:lerp(CF.N(0,2,4.5)*CF.A(0,M.R(-90),0)*CF.A(M.R(15+20*M.C(WingSine/32)),0,M.R(37.5+10*M.C(WingSine/32))),.1)
	LWingWelds[4].C0 = LWingWelds[4].C0:lerp(CF.N(0,3,5.75)*CF.A(0,M.R(-90),0)*CF.A(M.R(20+25*M.C(WingSine/32)),0,M.R(50+12.5*M.C(WingSine/32))),.1)
	LWingWelds[5].C0 = LWingWelds[5].C0:lerp(CF.N(0,4,6.75)*CF.A(0,M.R(-90),0)*CF.A(M.R(25+30*M.C(WingSine/32)),0,M.R(62.5+15*M.C(WingSine/32))),.1)
	LWingWelds[6].C0 = LWingWelds[6].C0:lerp(CF.N(0,5,7.75)*CF.A(0,M.R(-90),0)*CF.A(M.R(35+40*M.C(WingSine/32)),0,M.R(75+17.5*M.C(WingSine/32))),.1)
	
	RWingWelds[1].C0 = RWingWelds[1].C0:lerp(CF.N(0,0,-2.25)*CF.A(0,M.R(-90),0)*CF.A(M.R(5+10*M.C(WingSine/32)),0,-M.R(12.5+5*M.C(WingSine/32))),.1)
	RWingWelds[2].C0 = RWingWelds[2].C0:lerp(CF.N(0,1,-3.5)*CF.A(0,M.R(-90),0)*CF.A(M.R(10+15*M.C(WingSine/32)),0,-M.R(25+7.5*M.C(WingSine/32))),.1)
	RWingWelds[3].C0 = RWingWelds[3].C0:lerp(CF.N(0,2,-4.5)*CF.A(0,M.R(-90),0)*CF.A(M.R(15+20*M.C(WingSine/32)),0,-M.R(37.5+10*M.C(WingSine/32))),.1)
	RWingWelds[4].C0 = RWingWelds[4].C0:lerp(CF.N(0,3,-5.75)*CF.A(0,M.R(-90),0)*CF.A(M.R(20+25*M.C(WingSine/32)),0,-M.R(50+12.5*M.C(WingSine/32))),.1)
	RWingWelds[5].C0 = RWingWelds[5].C0:lerp(CF.N(0,4,-6.75)*CF.A(0,M.R(-90),0)*CF.A(M.R(25+30*M.C(WingSine/32)),0,-M.R(62.5+15*M.C(WingSine/32))),.1)
	RWingWelds[6].C0 = RWingWelds[6].C0:lerp(CF.N(0,5,-7.75)*CF.A(0,M.R(-90),0)*CF.A(M.R(35+40*M.C(WingSine/32)),0,-M.R(75+17.5*M.C(WingSine/32))),.1)
	
	local Walking = (math.abs(Root.Velocity.x) > 1 or math.abs(Root.Velocity.z) > 1)
	local State = (Hum.PlatformStand and 'Paralyzed' or Hum.Sit and 'Sit' or not hitfloor and Root.Velocity.y < -1 and "Fall" or not hitfloor and Root.Velocity.y > 1 and "Jump" or hitfloor and Walking and (Hum.WalkSpeed < 24 and "Walk" or "Run") or hitfloor and "Idle")
	if(not Effects or not Effects.Parent)then
		Effects = IN("Model",Char)
		Effects.Name = "Effects"
	end																																																																																																		
	if(State == 'Run' and Mode ~= 5 and Mode ~= 10 and Mode ~= 666666666666 and Mode ~= 666)then
		local wsVal = 7 / (Hum.WalkSpeed/16)
		local Alpha = math.min(.2 * (Hum.WalkSpeed/16),1)
		Change = 1
			
	elseif(State == 'Walk' and Mode ~= 5 and Mode ~= 10 and Mode ~= 666666666666 and Mode ~= 666)then
		local wsVal = 7 / (Hum.WalkSpeed/16)
		local Alpha = math.min(.2 * (Hum.WalkSpeed/16),1)
		Change = 1
		if(Mode == 7)then
			RH.C1 = RH.C1:lerp(CF.N(0,1-.05*M.C(Sine/wsVal),0+.1*M.C(Sine/wsVal))*CF.A(M.R(8-0*M.C(Sine/wsVal))+-M.S(Sine/wsVal)/3,0,0),Alpha)
			LH.C1 = LH.C1:lerp(CF.N(0,1+.05*M.C(Sine/wsVal),0-.1*M.C(Sine/wsVal))*CF.A(M.R(8+0*M.C(Sine/wsVal))+M.S(Sine/wsVal)/3,0,0),Alpha)
		else
			RH.C1 = RH.C1:lerp(CF.N(0,1-.1*M.C(Sine/wsVal),0+.2*M.C(Sine/wsVal))*CF.A(M.R(16-0*M.C(Sine/wsVal))+-M.S(Sine/wsVal)/1.75,0,0),Alpha)
			LH.C1 = LH.C1:lerp(CF.N(0,1+.1*M.C(Sine/wsVal),0-.2*M.C(Sine/wsVal))*CF.A(M.R(16+0*M.C(Sine/wsVal))+M.S(Sine/wsVal)/1.75,0,0),Alpha)
		end
	else
		RH.C1 = RH.C1:lerp(CF.N(0,1,0),.2)
		LH.C1 = LH.C1:lerp(CF.N(0,1,0),.2)
	end	
	

	
	if(Hits > 0)then
		local TimeDiff = (HitTime-time())*2
	--	ComboBG:TweenPosition(UDim2.new(0,0,.4,0),Enum.EasingDirection.In,Enum.EasingStyle.Linear,.2,true)
	--	ComboFill:TweenSize(UDim2.new(math.min(1*TimeDiff,1),0,1,0),Enum.EasingDirection.Out,Enum.EasingStyle.Linear,.1,true)		
	end
	
	if(HitTime < time() and Hits > 0)then
		Hits = 0
	--	ComboBG:TweenPosition(UDim2.new(-.1,0,.4,0),Enum.EasingDirection.Out,Enum.EasingStyle.Linear,.2,true)
	end
--	ComboLbl.Text = Hits
	
	Hum.WalkSpeed = WalkSpeed
	if(NeutralAnims)then	
		if(State == 'Idle')then
			local Alpha = .1
			if(Mode == 1)then
				Change = 1
				RJ.C0 = clerp(RJ.C0,CFrame.new(-0.00779043138, -0.0846293643+.1*M.C(Sine/32), -0.204210758, 0.912902117, -0.00691865245, -0.408120036, 0.117574908, 0.961935759, 0.246689886, 0.390878439, -0.273188382, 0.87896657),Alpha)
				LH.C0 = clerp(LH.C0,CFrame.new(-0.587742627, -1.00122428-.1*M.C(Sine/32), -0.165018916, 0.860076427, 0.294745922, 0.416405559, -0.252913684, 0.955196917, -0.15373303, -0.443061411, 0.0269074962, 0.896087468),Alpha)
				RH.C0 = clerp(RH.C0,CFrame.new(0.343915284, -1.07833397-.1*M.C(Sine/32), -0.0402937233, 0.964631855, -0.173768938, -0.198217094, 0.117325157, 0.956397653, -0.26746732, 0.236051857, 0.234751642, 0.942958832),Alpha)
				LS.C0 = clerp(LS.C0,CFrame.new(-1.39700282, 0.545769572, -0.00181379914, 0.907886505, 0.355485201, -0.222199559, -0.405204862, 0.880023003, -0.247727305, 0.107477367, 0.314944565, 0.943005204)*CF.A(0,M.R(16-8*M.C(Sine/32)),M.R(0+12*M.C(Sine/32)))*CF.A(0,M.R(0+4*M.C(Sine/0.173278)),M.R(0+15*M.S(Sine/0.476125))),Alpha)
				RS.C0 = clerp(RS.C0,CFrame.new(0.903979659, 0.624733686, -0.396169931, 0.827836394, 0.560810268, -0.013374418, 0.472599089, -0.7100721, -0.521965444, -0.302220345, 0.42578119, -0.852861941)*CF.A(0,M.R(0+4*M.C(Sine/0.61237)),M.R(0+15*M.S(Sine/0.716246))),Alpha)
				NK.C0 = clerp(NK.C0,CFrame.new(-0.0470906645, 1.53467083, -0.115898043, 0.906688511, -0.16142872, 0.389688164, -0.00265284558, 0.921666741, 0.387973785, -0.421792656, -0.352805078, 0.835236311)*CF.A(0,M.R(0+4*M.C(Sine/0.61237)),M.R(0+15*M.S(Sine/0.716246))),Alpha)
			elseif(Mode == 2)then
				Change = 1
				RJ.C0 = clerp(RJ.C0,CFrame.new(2.74447132e-13, 0.00628674868+.1*M.C(Sine/32), -5.34626452e-07, 0.99999994, 4.36557457e-11, 0, -4.3652193e-11, 0.999980211, -0.00628619269, 9.31322575e-10, 0.00628619175, 0.999980271),Alpha)
				LH.C0 = clerp(LH.C0,CFrame.new(-0.496485978, -0.990816116-.1*M.C(Sine/32), 0.0216165781, 0.970629156, 7.27576055e-11, 0.240580648, -0.00151285366, 0.999980211, 0.00610364834, -0.240575925, -0.00628834311, 0.970610023),Alpha)
				RH.C0 = clerp(RH.C0,CFrame.new(0.491330802, -1.06821454-.1*M.C(Sine/32), 0.0589520633, 0.986244023, 0.0538565964, -0.156276181, 0.00103943795, 0.943392873, 0.331676066, 0.165292785, -0.327276021, 0.930359602),Alpha)
				LS.C0 = clerp(LS.C0,CFrame.new(-0.787155986, 0.248306945, -0.683226228, 0.0398273654, -0.999169707, 0.00859495346, 0.554963291, 0.0149663882, -0.831740201, 0.830920994, 0.0378959104, 0.555098593)*CF.A(M.R(0+5*M.C(Sine/32)),0,0),Alpha)
				RS.C0 = clerp(RS.C0,CFrame.new(0.787632346, 0.574486911, -0.794373989, 0.0789790228, 0.995851278, 0.0451963581, 0.631366551, -0.0148838377, -0.775341749, -0.771452367, 0.0897712111, -0.629922688)*CF.A(M.R(0+5*M.C(Sine/32)),0,0),Alpha)
				NK.C0 = clerp(NK.C0,CFrame.new(8.16642296e-06, 1.49894726, -0.014402397, 0.99999994, 3.67523171e-07, -1.61118805e-07, -3.56500095e-07, 0.997964799, 0.0637688041, 1.8440187e-07, -0.063768819, 0.997964799),Alpha)
			elseif(Mode == 3)then
				Change = 1
				RJ.C0 = clerp(RJ.C0,CFrame.new(0.022457514, 0.0062841149, -0.00324006379, 0.982301593, 0.00117789698, 0.187302738, -4.02951969e-07, 0.999980211, -0.00628649723, -0.187306449, 0.00617515948, 0.982282162),Alpha)
				LH.C0 = clerp(LH.C0,CFrame.new(-0.539962769, -1.00525093, -0.13583532, 0.998935044, -0.0434875898, 0.0154168755, 0.040365234, 0.985544145, 0.164539278, -0.0223494321, -0.163741738, 0.986250162),Alpha)
				RH.C0 = clerp(RH.C0,CFrame.new(0.498531163, -0.990978718, 0.01546143, 0.985106111, 0, -0.171948016, 0.00108131359, 0.999980211, 0.00619494682, 0.171944603, -0.00628860993, 0.98508662),Alpha)
				LS.C0 = clerp(LS.C0,CFrame.new(-1.42806315, 0.51039964, -0.00658199936, 0.990103781, 0.139778674, -0.0125195384, -0.139578417, 0.97154665, -0.191350713, -0.0145834237, 0.191204533, 0.981441915)*CF.A(0,0,M.R(0+6*M.C(Sine/32)))*CF.A(0,M.R(0+4*M.C(Sine/0.61237)),M.R(0+15*M.S(Sine/0.716246))),Alpha)
				RS.C0 = clerp(RS.C0,CFrame.new(1.42666709, 0.532186806, -0.134510398, 0.990944147, -0.126525059, 0.0449620783, 0.133282125, 0.967499852, -0.214895189, -0.0163111985, 0.218941733, 0.975601614)*CF.A(0,0,M.R(0-6*M.C(Sine/32)))*CF.A(0,M.R(0+4*M.C(Sine/0.012802)),M.R(0-15*M.S(Sine/0.716246))),Alpha)
				NK.C0 = clerp(NK.C0,CFrame.new(2.28285789e-05, 1.49894154, -0.0143941939, 0.984171331, -0.0497024879, -0.170107797, 0.0760453045, 0.985445082, 0.152036116, 0.160075322, -0.162565485, 0.973626494)*CF.A(M.R(0+3*M.C(Sine/32)),0,M.R(0+6*M.C(Sine/32)))*CF.A(0,M.R(0+16*M.C(Sine/0.98172)),M.R(0+15*M.S(Sine/0.65142))),Alpha)
			elseif(Mode == 4)then
				Change = 1 
				RJ.C0 = clerp(RJ.C0,CFrame.new(-0.00847404078, -0.131645858+.1*M.C(Sine/16), -0.542845488, 0.999965072, -0.00807052851, -0.00218774565, 0.00805599708, 0.85972774, 0.510689199, -0.00224066619, -0.51068902, 0.859762609),Alpha)
				LH.C0 = clerp(LH.C0,CFrame.new(-0.496114701, -1.0144912-.1*M.C(Sine/16), 0.0453964472, 0.976583362, 0.00805600174, 0.214989081, 0.103035107, 0.859728813, -0.50025022, -0.188862324, 0.510687351, 0.838766694),Alpha)
				RH.C0 = clerp(RH.C0,CFrame.new(0.498885572, -1.01948476-.1*M.C(Sine/16), 0.0378640294, 0.997592449, 0.00805600174, -0.0688822865, -0.0420893468, 0.859728813, -0.509013772, 0.055119466, 0.510687351, 0.857997894),Alpha)
				LS.C0 = clerp(LS.C0,CFrame.new(-1.42592692, 0.493003547, -0.129623473, 0.987043619, 0.159894824, 0.0133710029, -0.130732149, 0.849730968, -0.51075089, -0.0930281729, 0.502385318, 0.859624803)*CF.A(0,0,M.R(0+6*M.C(Sine/32)))*CF.A(0,M.R(0+4*M.C(Sine/0.817272)),M.R(0+15*M.S(Sine/0.9872346))),Alpha)
				RS.C0 = clerp(RS.C0,CFrame.new(1.1449033, 0.691183329, -0.239056498, 0.899715602, 0.434673697, 0.0396348648, 0.435808241, -0.899650335, -0.0264700353, 0.024151668, 0.0410887003, -0.998863578)*CF.A(0,M.R(0+4*M.C(Sine/0.61237)),M.R(0+15*M.S(Sine/0.716246))),Alpha)
				NK.C0 = clerp(NK.C0,CFrame.new(7.87388399e-06, 1.43020797, -0.212884247, 1, -8.72649252e-07, -4.02983278e-06, 2.92807817e-06, 0.838354766, 0.545125127, 2.90293247e-06, -0.545125067, 0.838354826)*CF.A(0,M.R(0+4*M.C(Sine/0.61237)),M.R(0+15*M.S(Sine/0.716246))),Alpha)
			elseif(Mode == 5)then
				Change = 1
				RJ.C0 = clerp(RJ.C0,CFrame.new(5.48791013e-11+.2*M.S(Sine/30), 1.2571125+.5*M.C(Sine/32), -3.51015478e-06+.2*M.S(Sine/32), 0.99999994, 4.36557457e-11, 0, -4.3652193e-11, 0.999980211, -0.00628619269, 9.31322575e-10, 0.00628619175, 0.999980271),Alpha)
				LH.C0 = clerp(LH.C0,CFrame.new(-0.436587602, -0.992619872, 0.0206923336, 0.99808234, 0.0599006973, 0.0156119233, -0.0600048117, 0.998178363, 0.00628757617, -0.0152068557, -0.0072123101, 0.999858439),Alpha)
				RH.C0 = clerp(RH.C0,CFrame.new(0.481217712, -0.504008591, -0.8678087, 0.997120202, -0.0733773932, -0.0191624481, 0.0741236135, 0.889526427, 0.450830936, -0.0160352942, -0.450953096, 0.892403722),Alpha)
				LS.C0 = clerp(LS.C0,CFrame.new(-1.49673307, 0.593781948+.1*M.C(Sine/32), 0.0200225115, 0.966687799, 0.25548178, 0.0156119233, -0.255602777, 0.96676141, 0.00628757617, -0.0134866452, -0.0100685749, 0.999858439)*CF.A(0,0,M.R(0+5*M.C(Sine/32))),Alpha)
				RS.C0 = clerp(RS.C0,CFrame.new(1.50987279, 0.675035477+.1*M.C(Sine/32), -0.0274340063, 0.943747699, -0.330297619, 0.0156119233, 0.33023873, 0.943876505, 0.00628757617, -0.0168125015, -0.000778224785, 0.999858439)*CF.A(0,0,M.R(0-5*M.C(Sine/32))),Alpha)
				NK.C0 = clerp(NK.C0,CFrame.new(4.35172478e-06, 1.49894357, -0.0144011974, 0.99999994, 3.67523171e-07, -1.61118805e-07, -3.56500095e-07, 0.997964799, 0.0637688041, 1.8440187e-07, -0.063768819, 0.997964799),Alpha)
			elseif(Mode == 6)then
				Change = 3
				RJ.C0 = clerp(RJ.C0,CFrame.new(2.74447132e-13, 0.00628674263-(pl/3000), 4.19029675e-07, 0.99999994, 4.36557457e-11, 0, -4.3652193e-11, 0.999980211, -0.00628619269, 9.31322575e-10, 0.00628619175, 0.999980271),Alpha)
				LH.C0 = clerp(LH.C0,CFrame.new(-0.50538516, -1.00439715+.2*M.C(Sine/16)+(pl/3000), -0.54824096, 0.999878109, -9.59694546e-11, 0.015612145, -9.81408521e-05, 0.999980211, 0.00628542574, -0.0156118376, -0.00628619269, 0.999858439),Alpha)
				RH.C0 = clerp(RH.C0,CFrame.new(0.498537898, -0.990978718+(pl/3000), 0.0154631268, 0.999878109, -9.59694546e-11, 0.015612145, -9.81408521e-05, 0.999980211, 0.00628542574, -0.0156118376, -0.00628619269, 0.999858439),Alpha)
				LS.C0 = clerp(LS.C0,CFrame.new(-1.42332602, 0.626581013-(pl/3000), -0.328449368, 0.922103286, 0.304182172, -0.239162698, -0.178854272, -0.213036552, -0.960534513, -0.343127936, 0.92848742, -0.142037436)*CF.A(-M.R(pl/36),0,0),Alpha)
				RS.C0 = clerp(RS.C0,CFrame.new(1.0793153, 0.434256732-(pl/3000), 0.60275507, 0.650267124, 0.696277916, -0.303891033, -0.505378187, 0.695125222, 0.511267006, 0.567226231, -0.178880244, 0.803900838),Alpha)
				NK.C0 = clerp(NK.C0,CFrame.new(7.8920275e-06, 1.49894428, -0.0144027323, 0.983284235, 0.010468211, -0.181776017, 0.00114496367, 0.9979707, 0.0636651218, 0.182073623, -0.0628090426, 0.981276989)*CF.A(M.R(pl/36),0,0),Alpha)
			elseif(Mode == 7)then
				Change = 1	
				RJ.C0 = clerp(RJ.C0,CFrame.new(0.0101235649, -1.07766318+.1*M.C(Sine/16), 0.648248792, 0.999971092, -0.00739747565, -0.00181146339, 0.00738599803, 0.883920729, 0.467578471, -0.00185771007, -0.467578262, 0.883949816)*CF.A(0,M.R(0+2*M.C(Sine/0.12512)),M.R(0+2*M.S(Sine/0.0512412))),Alpha)
				LH.C0 = clerp(LH.C0,CFrame.new(-0.504728794, 0.381877124-.1*M.C(Sine/16), -0.515005529, 0.999878228, 0.00738599803, 0.0137542095, -9.66741936e-05, 0.883920729, -0.467636794, -0.0156115945, 0.467578471, 0.883813798)*CF.A(0,-M.R(0+2*M.C(Sine/0.12512)),-M.R(0+2*M.S(Sine/0.0512412)))*CF.A(M.R(0+1*M.S(Sine/0.283547)),M.R(0+1*M.C(Sine/0.356723)),0),Alpha)
				RH.C0 = clerp(RH.C0,CFrame.new(0.491205901, 0.34564203-.1*M.C(Sine/16), -0.462503195, 0.999878228, 0.00738599803, 0.0137542095, -9.66741936e-05, 0.883920729, -0.467636794, -0.0156115945, 0.467578471, 0.883813798)*CF.A(0,-M.R(0+2*M.C(Sine/0.12512)),-M.R(0+2*M.S(Sine/0.0512412)))*CF.A(M.R(0+1*M.S(Sine/0.283547)),M.R(0+1*M.C(Sine/0.356723)),0),Alpha)
				LS.C0 = clerp(LS.C0,CFrame.new(-0.80868268, 0.497842163, -0.14479053, 0.744864702, -0.66721499, -0.00102781132, -0.0409338176, -0.0441599488, -0.998185575, 0.665959001, 0.743555188, -0.0602048337)*CF.A(0,M.R(0+2*M.C(Sine/0.134561367)),M.R(0+5*M.S(Sine/0.127347))),Alpha)
				RS.C0 = clerp(RS.C0,CFrame.new(0.754446983, 0.405229449, -0.406160057, 0.458563089, 0.88866204, -0.000157270115, 0.00361818075, -0.00204397738, -0.999991417, -0.88865459, 0.45855853, -0.00415253639)*CF.A(0,M.R(0+2*M.C(Sine/0.12543152)),M.R(0+5*M.S(Sine/0.273456123))),Alpha)
				NK.C0 = clerp(NK.C0,CFrame.new(3.87876844e-06, 1.54665208, -0.105986834, 1.00000012, 2.60770321e-06, 2.79070809e-05, -1.28485262e-05, 0.927553773, 0.373690069, -2.49119475e-05, -0.373690099, 0.927553654)*CF.A(0,M.R(0+2*M.C(Sine/0.25432)),M.R(0+5*M.S(Sine/0.421342134))),Alpha)
			elseif(Mode == 8)then
				Change = 1
				RJ.C0 = RJ.C0:lerp(CF.N(0,0,0)*CF.A(0,0,M.R(0+5*M.C(Sine/16))),Alpha)
				NK.C0 = NK.C0:lerp(NKC0*CF.A(0,0,-M.R(0+5*M.C(Sine/16))),Alpha)
				LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,-M.R(0+5*M.C(Sine/16)))*CF.A(M.R(-15),M.R(25),0),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.A(0,0,-M.R(0+5*M.C(Sine/16))),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,-.15,0)*CF.A(M.R(15),0,M.R(20)),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.A(0,0,M.R(5+5*M.S(Sine/16))),Alpha)
			elseif(Mode == 9)then
				Change = 1
				if(hitfloor and Mode == 9)then OEffect{Material=Enum.Material.Neon,Effect='Fade',Mesh={MeshType=Enum.MeshType.Cylinder},Size=V3.N(.1,5,5),Frames=120,Color=BrickColor.new'Forest green',CFrame=CF.N(posfloor,posfloor+norm)*CF.A(0,M.R(90),0)} end
				local Colors = {"Forest green","Lime green","Earth green"}
				NoobyBlock(4,.025,"Multiply",LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(-180,180),M.RRNG(-180,180),M.RRNG(-180,180)),V3.N(1,1,1),.012,BrickColor.new(Colors[M.RNG(1,#Colors)]),0,true)
				RJ.C0 = clerp(RJ.C0,CFrame.new(-0.00763900485, 0.0576088727+.1*M.C(Sine/32), -0.489215493, 0.999976635, -0.00668978505, -0.00145753659, 0.00667999825, 0.906569779, 0.422003359, -0.00150175206, -0.422003239, 0.906593204),Alpha)
				LH.C0 = clerp(LH.C0,CFrame.new(-0.508842707, -1.12272382-.1*M.C(Sine/32), -0.0245408416, 0.973195612, 0.0299689136, 0.228018239, 0.0911211073, 0.860081792, -0.501952767, -0.211157292, 0.509275496, 0.834296942),Alpha)
				RH.C0 = clerp(RH.C0,CFrame.new(0.505672514, -1.12652683-.1*M.C(Sine/32), -0.0664639771, 0.908796906, 0.0139010083, -0.417007297, -0.155455723, 0.938765347, -0.307495654, 0.387197405, 0.344277233, 0.855307937),Alpha)
				LS.C0 = clerp(LS.C0,CFrame.new(-1.45529008, 0.399098635+.1*M.C(Sine/32), -0.00237059593, 0.9937765, 0.103129238, -0.0421066694, -0.0848314539, 0.45566994, -0.88609755, -0.0721958056, 0.884154797, 0.461582631)*CF.A(0,0,M.R(0-10*M.C(Sine/32)))*CF.A(0,M.R(0+6*M.C(Sine/0.1872634)),M.R(0+12*M.S(Sine/0.0124723465))),Alpha)
				RS.C0 = clerp(RS.C0,CFrame.new(1.25761306, 0.482083619+.1*M.C(Sine/32), -0.434745401, 0.42843774, 0.695737422, -0.576533496, 0.754532933, -0.626516104, -0.195340306, -0.497112989, -0.351322293, -0.793379903)*CF.A(0,M.R(0+6*M.C(Sine/0.1872634)),M.R(0+12*M.S(Sine/0.0124723465))),Alpha)
				NK.C0 = clerp(NK.C0,CFrame.new(1.26473606e-05, 1.49894953, -0.0143971443, 0.998992383, 0.0431914814, 0.0122066746, -0.03513439, 0.921768486, -0.386146128, -0.0279299468, 0.385328114, 0.922357082)*CF.A(M.R(0+10*M.C(Sine/32)),0,0)*CF.A(0,M.R(0+6*M.C(Sine/0.1872634)),M.R(0+12*M.S(Sine/0.0124723465))),Alpha)
			elseif(Mode == 10)then
				NoobyBlock(4,.025,"Multiply",LArm.CFrame*CF.N(0,-1,0)*CF.A(M.RRNG(-180,180),M.RRNG(-180,180),M.RRNG(-180,180)),V3.N(1,1,1),.012,BrickColor.new'Alder',0,true)
				Change = 1	
				RJ.C0 = clerp(RJ.C0,CFrame.new(3.20710125e-11+.2*M.S(Sine/32), 0.881578624+.5*M.C(Sine/32), -9.84873623e-07+.2*M.C(Sine/24), 0.999999821, 3.63797881e-11, 0, -4.58300065e-11, 0.999980092, -0.00628619455, 9.31322575e-10, 0.00628619082, 0.999980509),Alpha)
				LH.C0 = clerp(LH.C0,CFrame.new(-0.507622898, -0.617543876, -0.694063663, 0.999877989, -0.00717858272, 0.0138636231, -9.81731864e-05, 0.885106385, 0.465388477, -0.0156116197, -0.465333343, 0.884998262),Alpha)
				RH.C0 = clerp(RH.C0,CFrame.new(0.499199599, -0.96504283, 0.0578122139, 0.999877989, -0.00369151891, 0.0151692061, -9.81731864e-05, 0.970136404, 0.242559701, -0.0156116197, -0.242531747, 0.970018268),Alpha)
				LS.C0 = clerp(LS.C0,CFrame.new(-1.40968728, 0.491904348, 0.019305028, 0.895423353, 0.179754242, 0.407314837, -0.16739957, 0.983670354, -0.0661047474, -0.412546366, -0.00899259746, 0.910892725)*CF.A(0,0,M.R(0+10*M.C(Sine/32))),Alpha)
				RS.C0 = clerp(RS.C0,CFrame.new(0.648883045, 0.459784538, -0.511239171, -0.133737907, 0.979713619, 0.149248496, 0.396290839, 0.190905675, -0.898058236, -0.908332765, -0.0609586462, -0.413783163)*CF.A(M.R(0+4*M.C(Sine/32)),M.R(0+4*M.C(Sine/32)),0),Alpha)
				NK.C0 = clerp(NK.C0,CFrame.new(7.21290917e-06, 1.49894142, -0.0144039318, 0.999999821, 3.67581379e-07, -1.60187483e-07, -3.56500095e-07, 0.997964799, 0.0637688041, 1.8440187e-07, -0.0637688339, 0.997965097),Alpha)
			elseif(Mode == 16)then
				Change = 1	
				RJ.C0 = RJ.C0:lerp(CF.N(0+.2*M.S(Sine/32),1.3-.5*M.C(Sine/32),0+.2*M.C(Sine/24))*CF.A(M.R(0+1.5*M.S(Sine/32)),M.R(0+5*M.S(Sine/36)),0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0*CF.N(0,0,0)*CF.A(M.R(0+5*M.C(Sine/32)),0,0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.75,0+.1*M.C(Sine/32),-.5)*CF.A(M.R(-25-5*M.C(Sine/32)),M.R(15),M.R(80+10*M.C(Sine/32))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.5,0+.1*M.C(Sine/32),-.5)*CF.A(M.R(25+5*M.C(Sine/32)),M.R(-15),M.R(-85-5*M.C(Sine/32))),Alpha)
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,.4,-.5)*CF.A(M.R(-15-2.5*M.S(Sine/32)),M.R(25-5*M.C(Sine/32)),M.R(-5)),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.A(M.R(-15-5*M.C(Sine/32)),M.R(-25),M.R(5)),Alpha)
			elseif(Mode == 696969)then
				Change = 1
				RJ.C0 = clerp(RJ.C0,CFrame.new(-0.00497054448, 0.0384125113+.1*M.C(Sine/32), -0.318240643, 0.999985576, -0.00531026162, -0.000893360935, 0.00530399941, 0.942669153, 0.333686858, -0.00092981942, -0.333686769, 0.942683578),Alpha)
				LH.C0 = clerp(LH.C0,CFrame.new(-0.497181207, -1.07329571-.1*M.C(Sine/32), -0.0259589553, 0.991927385, 0.00536903273, 0.126693994, 0.0373182632, 0.942499518, -0.332117736, -0.12119215, 0.334164649, 0.934690654),Alpha)
				RH.C0 = clerp(RH.C0,CFrame.new(0.508173347, -1.05517495-.1*M.C(Sine/32), -0.101279587, 0.989477396, 0.015710555, -0.143832386, -0.0531964861, 0.963962197, -0.260666966, 0.13455373, 0.265575409, 0.954654515),Alpha)
				LS.C0 = clerp(LS.C0,CFrame.new(-1.3136189, 0.462844551+.1*M.C(Sine/32), 0.00274867564, 0.929629087, -0.368184805, -0.015158236, -0.360420376, -0.899919868, -0.245441884, 0.0767267719, 0.23363328, -0.969292879)*CF.A(0,M.R(0+4*M.C(Sine/0.173278)),M.R(0+15*M.S(Sine/0.01278125))),Alpha)
				RS.C0 = clerp(RS.C0,CFrame.new(1.25962329, 0.543387234+.1*M.C(Sine/32), 0.0906403661, 0.898135066, 0.439483941, -0.0144048491, 0.399390757, -0.829028964, -0.391405523, -0.183958456, 0.345781803, -0.920105577)*CF.A(0,M.R(0+4*M.C(Sine/0.173278)),M.R(0+15*M.S(Sine/0.01278125))),Alpha)
				NK.C0 = clerp(NK.C0,CFrame.new(-0.00269337045, 1.48585653, -0.187648922, 0.999991715, -0.00401760591, -0.00077160541, 0.00405273447, 0.94710511, 0.320898026, -0.000558450818, -0.320898473, 0.947113574)*CF.A(0,M.R(0+4*M.C(Sine/0.173278)),M.R(0+7.5*M.S(Sine/0.01278125))),Alpha)
			elseif(Mode == 666666666666)then
				Change = 1
				NoobySphere(4,.025,"Multiply",RArm.CFrame*CF.N(0,-1.25,0)*CF.A(M.RRNG(-180,180),M.RRNG(-180,180),M.RRNG(-180,180)),V3.N(.5,.5,.5),0,BrickColor.new'Black',0)
				RJ.C0 = clerp(RJ.C0,CFrame.new(7.0558559e-11, 1.61628103+.5*M.C(Sine/32), -3.05566937e-06, 0.99999994, 4.36557457e-11, 0, -4.3652193e-11, 0.999980211, -0.00628619269, 9.31322575e-10, 0.00628619175, 0.999980271),Alpha)
				LH.C0 = clerp(LH.C0,CFrame.new(-0.473465502, -1.00430846, 0.0547358543, 0.996436775, 0.0789096355, 0.0297838245, -0.0829922184, 0.980262518, 0.179437637, -0.0150366053, -0.181270093, 0.983318448),Alpha)
				RH.C0 = clerp(RH.C0,CFrame.new(0.500664473, -0.996896267, 0.0722374618, 0.994860828, -0.10125193, 0.00038037356, 0.0999543592, 0.982697129, 0.155934408, -0.0161624532, -0.155095011, 0.987767398),Alpha)
				LS.C0 = clerp(LS.C0,CFrame.new(-1.29428089, 0.420441031, 0.493041277, 0.816086888, -0.538787425, 0.209070042, 0.381859779, 0.774240494, 0.504712522, -0.43380329, -0.33205387, 0.837588906)*CF.A(0,0,M.R(0-5*M.C(Sine/32)))*CF.A(0,M.R(0+4*M.C(Sine/0.173278)),M.R(0+15*M.S(Sine/0.01278125))),Alpha)
				RS.C0 = clerp(RS.C0,CFrame.new(1.36178303, 0.535555065, 0.0481818169, 0.959323943, -0.276642442, -0.0562722012, -0.281998605, -0.948367953, -0.145173192, -0.0132056763, 0.155136824, -0.98780489)*CF.A(0,0,M.R(0+5*M.C(Sine/32)))*CF.A(0,M.R(0+4*M.C(Sine/0.173278)),M.R(0+15*M.S(Sine/0.01278125))),Alpha)
				NK.C0 = clerp(NK.C0,CFrame.new(0.0176411867, 1.49121404, -0.0637010336, 0.942441404, 0.0288463272, -0.333124816, 0.0213407781, 0.989051461, 0.146020114, 0.333689809, -0.144724563, 0.931507409)*CF.A(0,M.R(0+32*M.C(Sine/0.025345)),M.R(0+24*M.S(Sine/0.0245987638))),Alpha)
			elseif(Mode == 666)then
				Change = 1
				RJ.C0 = RJ.C0:lerp(CF.N(0+.2*M.S(Sine/30),1.6+.2*M.C(Sine/32),0+.2*M.C(Sine/26))*CF.A(0,M.RRNG(-5,5),0),Alpha)
				if(M.RNG(1,30) == 1)then
					NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(0,45),M.RRNG(-45,45),M.RRNG(-45,45)),1)
				else
					NK.C0 = NK.C0:lerp(NKC0*CF.N(0,0,-.35)*CF.A(M.R(-45+5*M.C(Sine/32)),0,0)*CF.A(M.RRNG(-5,5),M.RRNG(-5,5),M.RRNG(-5,5)),Alpha)
				end
				LS.C0 = LS.C0:lerp(LSC0*CF.N(.75,0+.1*M.C(Sine/32),-.5)*CF.A(0,M.R(15),M.R(80+5*M.C(Sine/32)))*CF.A(M.RRNG(-5,5),M.RRNG(-5,5),M.RRNG(-5,5)),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(-.5,0+.1*M.C(Sine/32),-.5)*CF.A(0,M.R(-15),M.R(-85-5*M.C(Sine/32)))*CF.A(M.RRNG(-5,5),M.RRNG(-5,5),M.RRNG(-5,5)),Alpha)
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,.4,-.5)*CF.A(M.R(-15-2.5*M.S(Sine/32)),M.R(25-5*M.C(Sine/32)),M.R(-5))*CF.A(M.RRNG(-5,5),M.RRNG(-5,5),M.RRNG(-5,5)),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.A(M.R(-15-5*M.C(Sine/32)),M.R(-25),M.R(5))*CF.A(M.RRNG(-5,5),M.RRNG(-5,5),M.RRNG(-5,5)),Alpha)
			else			
				Change = 1
				RJ.C0 = RJ.C0:lerp(RJC0*CF.N(0,.2*M.C(Sine/6),0)*CF.A(M.R(-5+5*M.C(Sine/12)),M.R(-10),0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0*CF.A(M.R(-5+5*M.C(Sine/12)),0,0),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.A(0,0,M.R(-7-5*M.C(Sine/12))),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.A(0,0,M.R(7+5*M.C(Sine/12))),Alpha)
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,-.2*M.C(Sine/6),0)*CF.A(M.R(5-5*M.C(Sine/12)),M.R(10),0),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,-.2*M.C(Sine/6),0)*CF.A(M.R(5-5*M.C(Sine/12)),M.R(-10),0),Alpha)
			end
			-- idle
		elseif(State == 'Run' and Mode ~= 5 and Mode ~= 10 and Mode ~= 666666666666 and Mode ~= 666 and Mode ~= 16)then
			local wsVal = 7 / (Hum.WalkSpeed/16)
			local Alpha = math.min(.2 * (Hum.WalkSpeed/16),1)
			RJ.C0 = RJ.C0:lerp(CF.N(0,0-.1*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-15+2.5*M.C(Sine/(wsVal/2))),M.R(8*M.C(Sine/wsVal)),0),Alpha)
			NK.C0 = NK.C0:lerp(NKC0,Alpha)
			LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0,0-.3*M.S(Sine/wsVal))*CF.A(M.R(0+45*M.S(Sine/wsVal)),0,M.R(-5)),Alpha)
			RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0,0+.3*M.S(Sine/wsVal))*CF.A(M.R(0-45*M.S(Sine/wsVal)),0,M.R(5)),Alpha)
			LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0+.1*M.C(Sine/(wsVal/2)),0)*CF.A(0,-M.R(4*M.C(Sine/wsVal)),0),Alpha)
			RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+.1*M.C(Sine/(wsVal/2)),0)*CF.A(0,-M.R(4*M.C(Sine/wsVal)),0),Alpha)
		elseif(State == 'Walk' and Mode ~= 5 and Mode ~= 7 and Mode ~= 10 and Mode ~= 666666666666 and Mode ~= 666 and Mode ~= 16)then
			local wsVal = 7 / (Hum.WalkSpeed/16)
			local Alpha = math.min(.2 * (Hum.WalkSpeed/16),1)
			if(Mode == 4)then
				RJ.C0 = clerp(RJ.C0,CFrame.new(-0.00847404078, -0.131645858-.1*M.C(Sine/(wsVal)), -0.542845488, 0.999965072, -0.00807052851, -0.00218774565, 0.00805599708, 0.85972774, 0.510689199, -0.00224066619, -0.51068902, 0.859762609),Alpha)
				LH.C0 = clerp(LH.C0,CFrame.new(-0.496114701, -1.0144912+.1*M.C(Sine/(wsVal)), 0.0453964472, 0.976583362, 0.00805600174, 0.214989081, 0.103035107, 0.859728813, -0.50025022, -0.188862324, 0.510687351, 0.838766694),Alpha)
				RH.C0 = clerp(RH.C0,CFrame.new(0.498885572, -1.01948476+.1*M.C(Sine/(wsVal)), 0.0378640294, 0.997592449, 0.00805600174, -0.0688822865, -0.0420893468, 0.859728813, -0.509013772, 0.055119466, 0.510687351, 0.857997894),Alpha)
				LS.C0 = clerp(LS.C0,CFrame.new(-1.42592692, 0.493003547, -0.129623473, 0.987043619, 0.159894824, 0.0133710029, -0.130732149, 0.849730968, -0.51075089, -0.0930281729, 0.502385318, 0.859624803)*CF.A(M.R(0+15*M.C(Sine/wsVal)),0,0)*CF.A(0,M.R(0+4*M.C(Sine/0.817272)),M.R(0+15*M.S(Sine/0.9872346))),Alpha)
				RS.C0 = clerp(RS.C0,CFrame.new(1.1449033, 0.691183329, -0.239056498, 0.899715602, 0.434673697, 0.0396348648, 0.435808241, -0.899650335, -0.0264700353, 0.024151668, 0.0410887003, -0.998863578)*CF.A(0,M.R(0+4*M.C(Sine/0.61237)),M.R(0+15*M.S(Sine/0.716246))),Alpha)
				NK.C0 = clerp(NK.C0,CFrame.new(7.87388399e-06, 1.43020797, -0.212884247, 1, -8.72649252e-07, -4.02983278e-06, 2.92807817e-06, 0.838354766, 0.545125127, 2.90293247e-06, -0.545125067, 0.838354826)*CF.A(0,M.R(0+4*M.C(Sine/0.61237)),M.R(0+15*M.S(Sine/0.716246))),Alpha)
			elseif(Mode == 696969)then
				RJ.C0 = clerp(RJ.C0,CFrame.new(-0.00847404078, -0.131645858-.1*M.C(Sine/(wsVal)), -0.542845488, 0.999965072, -0.00807052851, -0.00218774565, 0.00805599708, 0.85972774, 0.510689199, -0.00224066619, -0.51068902, 0.859762609),Alpha)
				LH.C0 = clerp(LH.C0,CFrame.new(-0.496114701, -1.0144912+.1*M.C(Sine/(wsVal)), 0.0453964472, 0.976583362, 0.00805600174, 0.214989081, 0.103035107, 0.859728813, -0.50025022, -0.188862324, 0.510687351, 0.838766694),Alpha)
				RH.C0 = clerp(RH.C0,CFrame.new(0.498885572, -1.01948476+.1*M.C(Sine/(wsVal)), 0.0378640294, 0.997592449, 0.00805600174, -0.0688822865, -0.0420893468, 0.859728813, -0.509013772, 0.055119466, 0.510687351, 0.857997894),Alpha)
				LS.C0 = clerp(LS.C0,CFrame.new(-1.3136189, 0.462844551+.1*M.C(Sine/wsVal), 0.00274867564, 0.929629087, -0.368184805, -0.015158236, -0.360420376, -0.899919868, -0.245441884, 0.0767267719, 0.23363328, -0.969292879)*CF.A(0,M.R(0+4*M.C(Sine/0.173278)),M.R(0+15*M.S(Sine/0.01278125))),Alpha)
				RS.C0 = clerp(RS.C0,CFrame.new(1.25962329, 0.543387234+.1*M.C(Sine/wsVal), 0.0906403661, 0.898135066, 0.439483941, -0.0144048491, 0.399390757, -0.829028964, -0.391405523, -0.183958456, 0.345781803, -0.920105577)*CF.A(0,M.R(0+4*M.C(Sine/0.173278)),M.R(0+15*M.S(Sine/0.01278125))),Alpha)
				NK.C0 = clerp(NK.C0,CFrame.new(7.87388399e-06, 1.43020797, -0.212884247, 1, -8.72649252e-07, -4.02983278e-06, 2.92807817e-06, 0.838354766, 0.545125127, 2.90293247e-06, -0.545125067, 0.838354826)*CF.A(0,M.R(0+4*M.C(Sine/0.61237)),M.R(0+15*M.S(Sine/0.716246))),Alpha)
			
			elseif(Mode == 1)then
				RJ.C0 = RJ.C0:lerp(CF.N(0,0-.1*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-5-2.5*M.C(Sine/(wsVal/2))),M.R(8*M.C(Sine/wsVal)),0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0*CF.A(0,M.R(0+4*M.C(Sine/0.61237)),M.R(0+15*M.S(Sine/0.716246))),Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0,-.22*M.C(Sine/wsVal))*CF.A(M.R(0+37*M.C(Sine/wsVal)),0,M.R(-5+10*M.C(Sine/(wsVal/2))) ),Alpha)
				RS.C0 = clerp(RS.C0,CFrame.new(1.2, 0.7, -0.396169931, 0.827836394, 0.560810268, -0.013374418, 0.472599089, -0.7100721, -0.521965444, -0.302220345, 0.42578119, -0.852861941)*CF.A(0,M.R(0+4*M.C(Sine/0.61237)),M.R(0+15*M.S(Sine/0.716246))),Alpha)
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0+.1*M.C(Sine/(wsVal/2)),0)*CF.A(0,-M.R(4*M.C(Sine/wsVal)),0),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+.1*M.C(Sine/(wsVal/2)),0)*CF.A(0,-M.R(4*M.C(Sine/wsVal)),0),Alpha)
			else 
				if(hitfloor and Mode == 9)then OEffect{Material=Enum.Material.Neon,Effect='Fade',Mesh={MeshType=Enum.MeshType.Cylinder},Size=V3.N(.1,5,5),Frames=120,Color=BrickColor.new'Forest green',CFrame=CF.N(posfloor,posfloor+norm)*CF.A(0,M.R(90),0)} end
				RJ.C0 = RJ.C0:lerp(CF.N(0,0-.1*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-5-2.5*M.C(Sine/(wsVal/2))),M.R(8*M.C(Sine/wsVal)),0),Alpha)
				NK.C0 = NK.C0:lerp(NKC0,Alpha)
				LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0,-.22*M.C(Sine/wsVal))*CF.A(M.R(37*M.C(Sine/wsVal)),0,M.R(-5+10*M.C(Sine/(wsVal/2))) ),Alpha)
				RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0,.22*M.C(Sine/wsVal))*CF.A(M.R(-37*M.C(Sine/wsVal)),0,M.R(5-10*M.C(Sine/(wsVal/2))) ),Alpha)
				LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0+.1*M.C(Sine/(wsVal/2)),0)*CF.A(0,-M.R(4*M.C(Sine/wsVal)),0),Alpha)
				RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+.1*M.C(Sine/(wsVal/2)),0)*CF.A(0,-M.R(4*M.C(Sine/wsVal)),0),Alpha)
			end
		elseif(State == 'Walk' and Mode == 7)then
			local wsVal = 7 / (Hum.WalkSpeed/16)
			local Alpha = math.min(.3 * (Hum.WalkSpeed/8),1)
			RJ.C0 = RJ.C0:lerp(CF.N(0,0-.1*M.C(Sine/(wsVal/2)),0)*CF.A(M.R(-2.5-1.25*M.C(Sine/(wsVal/2))),M.R(4*M.C(Sine/wsVal)),0),Alpha)
			NK.C0 = NK.C0:lerp(NKC0,Alpha)
			LS.C0 = LS.C0:lerp(LSC0*CF.N(0,0,-.11*M.C(Sine/wsVal))*CF.A(M.R(18.5*M.C(Sine/wsVal)),0,M.R(-2.5+5*M.C(Sine/(wsVal/2))) ),Alpha)
			RS.C0 = RS.C0:lerp(RSC0*CF.N(0,0,.11*M.C(Sine/wsVal))*CF.A(M.R(-18.5*M.C(Sine/wsVal)),0,M.R(2.5-5*M.C(Sine/(wsVal/2))) ),Alpha)
			LH.C0 = LH.C0:lerp(LHC0*CF.N(0,0+.1*M.C(Sine/(wsVal/2)),0)*CF.A(0,-M.R(4*M.C(Sine/wsVal)),0),Alpha)
			RH.C0 = RH.C0:lerp(RHC0*CF.N(0,0+.1*M.C(Sine/(wsVal/2)),0)*CF.A(0,-M.R(4*M.C(Sine/wsVal)),0),Alpha)
		elseif((State == 'Walk' or State == 'Run') and Mode == 10)then
			Change = 1
			local Alpha = .1
			RJ.C0 = clerp(RJ.C0,CFrame.new(5.48791013e-11, 0.881578624+.5*M.C(Sine/32), -3.51015478e-06, 0.99999994, 4.36557457e-11, 0, -4.3652193e-11, 0.999980211, -0.00628619269, 9.31322575e-10, 0.00628619175, 0.999980271)*CF.A(M.R(-45),0,0),Alpha)
			LH.C0 = clerp(LH.C0,CFrame.new(-0.507622898, -0.617543876, -0.694063663, 0.999877989, -0.00717858272, 0.0138636231, -9.81731864e-05, 0.885106385, 0.465388477, -0.0156116197, -0.465333343, 0.884998262),Alpha)
			RH.C0 = clerp(RH.C0,CFrame.new(0.499199599, -0.96504283, 0.0578122139, 0.999877989, -0.00369151891, 0.0151692061, -9.81731864e-05, 0.970136404, 0.242559701, -0.0156116197, -0.242531747, 0.970018268),Alpha)
			LS.C0 = clerp(LS.C0,CFrame.new(-1.49673307, 0.593781948+.2*M.C(Sine/32), 0.0200225115, 0.966687799, 0.25548178, 0.0156119233, -0.255602777, 0.96676141, 0.00628757617, -0.0134866452, -0.0100685749, 0.999858439)*CF.A(M.R(-45),M.R(25),M.R(5+5*M.C(Sine/32))),Alpha)
			RS.C0 = clerp(RS.C0,CFrame.new(1.50987279, 0.675035477+.2*M.C(Sine/32), -0.0274340063, 0.943747699, -0.330297619, 0.0156119233, 0.33023873, 0.943876505, 0.00628757617, -0.0168125015, -0.000778224785, 0.999858439)*CF.A(M.R(-45),M.R(-25),M.R(-5-5*M.C(Sine/32))),Alpha)
			NK.C0 = clerp(NK.C0,CFrame.new(4.35172478e-06, 1.49894357, -0.0144011974, 0.99999994, 3.67523171e-07, -1.61118805e-07, -3.56500095e-07, 0.997964799, 0.0637688041, 1.8440187e-07, -0.063768819, 0.997964799)*CF.A(M.R(45),0,0),Alpha)
		elseif((State == 'Walk' or State == 'Run') and Mode == 666666666666)then
			Change = 1
			local Alpha = .1
			RJ.C0 = clerp(RJ.C0,CFrame.new(5.48791013e-11, 1.61628103+.5*M.C(Sine/32), -3.51015478e-06, 0.99999994, 4.36557457e-11, 0, -4.3652193e-11, 0.999980211, -0.00628619269, 9.31322575e-10, 0.00628619175, 0.999980271)*CF.A(M.R(-65),0,0),Alpha)
			LH.C0 = clerp(LH.C0,CFrame.new(-0.507622898, -0.617543876, -0.694063663, 0.999877989, -0.00717858272, 0.0138636231, -9.81731864e-05, 0.885106385, 0.465388477, -0.0156116197, -0.465333343, 0.884998262),Alpha)
			RH.C0 = clerp(RH.C0,CFrame.new(0.499199599, -0.96504283, 0.0578122139, 0.999877989, -0.00369151891, 0.0151692061, -9.81731864e-05, 0.970136404, 0.242559701, -0.0156116197, -0.242531747, 0.970018268),Alpha)
			LS.C0 = clerp(LS.C0,CFrame.new(-1.49673307, 0.593781948+.2*M.C(Sine/32), 0.0200225115, 0.966687799, 0.25548178, 0.0156119233, -0.255602777, 0.96676141, 0.00628757617, -0.0134866452, -0.0100685749, 0.999858439)*CF.A(M.R(-55),M.R(25),M.R(5+5*M.C(Sine/32))),Alpha)
			RS.C0 = clerp(RS.C0,CFrame.new(1.50987279, 0.675035477+.2*M.C(Sine/32), -0.0274340063, 0.943747699, -0.330297619, 0.0156119233, 0.33023873, 0.943876505, 0.00628757617, -0.0168125015, -0.000778224785, 0.999858439)*CF.A(M.R(-55),M.R(-25),M.R(-5-5*M.C(Sine/32))),Alpha)
			NK.C0 = clerp(NK.C0,CFrame.new(4.35172478e-06, 1.49894357, -0.0144011974, 0.99999994, 3.67523171e-07, -1.61118805e-07, -3.56500095e-07, 0.997964799, 0.0637688041, 1.8440187e-07, -0.063768819, 0.997964799)*CF.A(M.R(65),0,0),Alpha)
		elseif((State == 'Walk' or State == 'Run') and Mode == 666)then
			Change = 1
			local Alpha = .1
			RJ.C0 = RJ.C0:lerp(CF.N(0+.2*M.S(Sine/30),1.6+.2*M.C(Sine/32),0+.2*M.C(Sine/26))*CF.A(M.R(-45),M.RRNG(-5,5),0),Alpha)
			if(M.RNG(1,30) == 1)then
				NK.C0 = NK.C0:lerp(NKC0*CF.A(M.RRNG(0,45),M.RRNG(-45,45),M.RRNG(-45,45)),1)
			else
				NK.C0 = NK.C0:lerp(NKC0*CF.N(0,0,-.35)*CF.A(M.R(-25+5*M.C(Sine/32)),0,0)*CF.A(M.RRNG(-5,5),M.RRNG(-5,5),M.RRNG(-5,5)),Alpha)
			end
			LS.C0 = LS.C0:lerp(LSC0*CF.N(.75,0+.1*M.C(Sine/32),-.5)*CF.A(0,M.R(15),M.R(80+5*M.C(Sine/32)))*CF.A(M.RRNG(-5,5),M.RRNG(-5,5),M.RRNG(-5,5)),Alpha)
			RS.C0 = RS.C0:lerp(RSC0*CF.N(-.5,0+.1*M.C(Sine/32),-.5)*CF.A(0,M.R(-15),M.R(-85-5*M.C(Sine/32)))*CF.A(M.RRNG(-5,5),M.RRNG(-5,5),M.RRNG(-5,5)),Alpha)
			LH.C0 = LH.C0:lerp(LHC0*CF.N(0,.4,-.5)*CF.A(M.R(-35-2.5*M.S(Sine/32)),M.R(25-5*M.C(Sine/32)),M.R(-5))*CF.A(M.RRNG(-5,5),M.RRNG(-5,5),M.RRNG(-5,5)),Alpha)
			RH.C0 = RH.C0:lerp(RHC0*CF.A(M.R(-35-5*M.C(Sine/32)),M.R(-25),M.R(5))*CF.A(M.RRNG(-5,5),M.RRNG(-5,5),M.RRNG(-5,5)),Alpha)
		elseif((State == 'Walk' or State == 'Run') and Mode == 16)then
			local Alpha = .1
			Change = 1	
			RJ.C0 = RJ.C0:lerp(CF.N(0+.2*M.S(Sine/32),1.3-.5*M.C(Sine/32),0+.2*M.C(Sine/24))*CF.A(M.R(-45+1.5*M.S(Sine/32)),M.R(0+5*M.S(Sine/36)),0),Alpha)
			NK.C0 = NK.C0:lerp(NKC0*CF.N(0,0,0)*CF.A(M.R(25+5*M.C(Sine/32)),0,0),Alpha)
			LS.C0 = LS.C0:lerp(LSC0*CF.N(.75,0+.1*M.C(Sine/32),-.5)*CF.A(M.R(-25-5*M.C(Sine/32)),M.R(15),M.R(80+10*M.C(Sine/32))),Alpha)
			RS.C0 = RS.C0:lerp(RSC0*CF.N(-.5,0+.1*M.C(Sine/32),-.5)*CF.A(M.R(25+5*M.C(Sine/32)),M.R(-15),M.R(-85-5*M.C(Sine/32))),Alpha)
			LH.C0 = LH.C0:lerp(LHC0*CF.N(0,.4,-.5)*CF.A(M.R(-35-2.5*M.S(Sine/32)),M.R(25-5*M.C(Sine/32)),M.R(-5)),Alpha)
			RH.C0 = RH.C0:lerp(RHC0*CF.A(M.R(-35-5*M.C(Sine/32)),M.R(-25),M.R(5)),Alpha)
		elseif((State == 'Walk' or State == 'Run'))then
			Change = 1
			local Alpha = .1
			RJ.C0 = clerp(RJ.C0,CFrame.new(5.48791013e-11, 1.2571125+.5*M.C(Sine/32), -3.51015478e-06, 0.99999994, 4.36557457e-11, 0, -4.3652193e-11, 0.999980211, -0.00628619269, 9.31322575e-10, 0.00628619175, 0.999980271)*CF.A(M.R(-75),0,0),Alpha)
			LH.C0 = clerp(LH.C0,CFrame.new(-0.436587602, -0.992619872, 0.0206923336, 0.99808234, 0.0599006973, 0.0156119233, -0.0600048117, 0.998178363, 0.00628757617, -0.0152068557, -0.0072123101, 0.999858439),Alpha)
			RH.C0 = clerp(RH.C0,CFrame.new(0.481217712, -0.504008591, -0.8678087, 0.997120202, -0.0733773932, -0.0191624481, 0.0741236135, 0.889526427, 0.450830936, -0.0160352942, -0.450953096, 0.892403722),Alpha)
			LS.C0 = clerp(LS.C0,CFrame.new(-1.49673307, 0.593781948+.2*M.C(Sine/32), 0.0200225115, 0.966687799, 0.25548178, 0.0156119233, -0.255602777, 0.96676141, 0.00628757617, -0.0134866452, -0.0100685749, 0.999858439)*CF.A(M.R(-15),M.R(25),M.R(5+5*M.C(Sine/32))),Alpha)
			RS.C0 = clerp(RS.C0,CFrame.new(1.50987279, 0.675035477+.2*M.C(Sine/32), -0.0274340063, 0.943747699, -0.330297619, 0.0156119233, 0.33023873, 0.943876505, 0.00628757617, -0.0168125015, -0.000778224785, 0.999858439)*CF.A(M.R(-15),M.R(-25),M.R(-5-5*M.C(Sine/32))),Alpha)
			NK.C0 = clerp(NK.C0,CFrame.new(4.35172478e-06, 1.49894357, -0.0144011974, 0.99999994, 3.67523171e-07, -1.61118805e-07, -3.56500095e-07, 0.997964799, 0.0637688041, 1.8440187e-07, -0.063768819, 0.997964799)*CF.A(M.R(75),0,0),Alpha)
		
		elseif(State == 'Jump')then
			local Alpha = .1
			local idk = math.min(math.max(Root.Velocity.Y/50,-M.R(90)),M.R(90))
			LS.C0 = LS.C0:lerp(LSC0*CF.A(M.R(-5),0,M.R(-90)),Alpha)
			RS.C0 = RS.C0:lerp(RSC0*CF.A(M.R(-5),0,M.R(90)),Alpha)
			RJ.C0 = RJ.C0:lerp(RJC0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),Alpha)
			NK.C0 = NK.C0:lerp(NKC0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),Alpha)
			LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-5)),Alpha)
			RH.C0 = RH.C0:lerp(RHC0*CF.N(0,1,-1)*CF.A(M.R(-5),0,M.R(5)),Alpha)
		elseif(State == 'Fall')then
			local Alpha = .1
			local idk = math.min(math.max(Root.Velocity.Y/50,-M.R(90)),M.R(90))
			LS.C0 = LS.C0:lerp(LSC0*CF.A(M.R(-5),0,M.R(-90)+idk),Alpha)
			RS.C0 = RS.C0:lerp(RSC0*CF.A(M.R(-5),0,M.R(90)-idk),Alpha)
			RJ.C0 = RJ.C0:lerp(RJC0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),Alpha)
			NK.C0 = NK.C0:lerp(NKC0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),Alpha)
			LH.C0 = LH.C0:lerp(LHC0*CF.A(0,0,M.R(-5)),Alpha)
			RH.C0 = RH.C0:lerp(RHC0*CF.N(0,1,-1)*CF.A(M.R(-5),0,M.R(5)),Alpha)
		elseif(State == 'Paralyzed')then
			-- paralyzed
		elseif(State == 'Sit')then
			-- sit
		end
	end
	


	
	for i,v in next, BloodPuddles do
		local mesh = i:FindFirstChild'CylinderMesh'
		BloodPuddles[i] = v + 1
		if(not mesh or i.Transparency >= 1)then
			i:destroy() 
			BloodPuddles[i] = nil
		elseif(v >= Frame_Speed*4)then
			local trans = (v-Frame_Speed*4)/(Frame_Speed*2)
			i.Transparency = trans
	            if(mesh.Scale.Z > 0)then
	                mesh.Scale = mesh.Scale-V3.N(.05,0,.05)
	            end
		else
			i.Transparency = 0
		end
	end
	
end



	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
end)

HatScripts:Button("Banzai Bazooka", "funny button go brr", function()
    if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		



local plr = game.Players.LocalPlayer
local char = plr.Character.Raw
local hum = char:FindFirstChildOfClass'Humanoid'
local mouse = plr:GetMouse()
local hed = char.Head
local root = char:FindFirstChild'HumanoidRootPart'
local rootj = root.RootJoint
local tors = char.Torso
local ra = char["Right Arm"]
local la = char["Left Arm"]
local rl = char["Right Leg"]
local ll = char["Left Leg"]
local neck = tors["Neck"]
local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)
local maincolor = BrickColor.new("Institutional white")
-------------------------------------------------------
--Start Good Stuff--
-------------------------------------------------------
cam = game.Workspace.CurrentCamera
CF = CFrame.new
angles = CFrame.Angles
attack = false
Euler = CFrame.fromEulerAnglesXYZ
Rad = math.rad
IT = Instance.new
BrickC = BrickColor.new
Cos = math.cos
Acos = math.acos
Sin = math.sin
Asin = math.asin
Abs = math.abs
Mrandom = math.random
Floor = math.floor
-------------------------------------------------------
--End Good Stuff--
-------------------------------------------------------
necko = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
RSH, LSH = nil, nil 
RW = Instance.new("Weld") 
LW = Instance.new("Weld")
RH = tors["Right Hip"]
LH = tors["Left Hip"]
RSH = tors["Right Shoulder"] 
LSH = tors["Left Shoulder"] 
RSH.Parent = nil 
LSH.Parent = nil 
RW.Name = "RW"
RW.Part0 = tors 
RW.C0 = CF(1.5, 0.5, 0)
RW.C1 = CF(0, 0.5, 0) 
RW.Part1 = ra
RW.Parent = tors 
LW.Name = "LW"
LW.Part0 = tors 
LW.C0 = CF(-1.5, 0.5, 0)
LW.C1 = CF(0, 0.5, 0) 
LW.Part1 = la
LW.Parent = tors
Effects = {}
newWeld = function(wp0, wp1, wc0x, wc0y, wc0z)
    local wld = Instance.new("Weld", wp1)
    wld.Part0 = wp0
    wld.Part1 = wp1
    wld.C0 = CFrame.new(wc0x, wc0y, wc0z)
end
newWeld(tors, ll, -0.5, -1, 0)
ll.Weld.C1 = CFrame.new(0, 1, 0)
newWeld(tors, rl, 0.5, -1, 0)
rl.Weld.C1 = CFrame.new(0, 1, 0)
-------------------------------------------------------
--Start HeartBeat--
-------------------------------------------------------
ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"
script:WaitForChild("Heartbeat")

frame = 1 / 60
tf = 0
allowframeloss = false
tossremainder = false


lastframe = tick()
script.Heartbeat:Fire()


game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.Heartbeat:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)
-------------------------------------------------------
--End HeartBeat--
-------------------------------------------------------

-------------------------------------------------------
--Start Important Functions--
-------------------------------------------------------
function swait(num)
	if num == 0 or num == nil then
		game:service("RunService").Stepped:wait(0)
	else
		for i = 0, num do
			game:service("RunService").Stepped:wait(0)
		end
	end
end
function thread(f)
	coroutine.resume(coroutine.create(f))
end
function clerp(a, b, t)
	local qa = {
		QuaternionFromCFrame(a)
	}
	local qb = {
		QuaternionFromCFrame(b)
	}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m00 < m11 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s
			return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp
	if cosTheta >= 1.0E-4 then
		if 1 - cosTheta > 1.0E-4 then
			local theta = math.acos(cosTheta)
			local invSinTheta = 1 / Sin(theta)
			startInterp = Sin((1 - t) * theta) * invSinTheta
			finishInterp = Sin(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	elseif 1 + cosTheta > 1.0E-4 then
		local theta = math.acos(-cosTheta)
		local invSinTheta = 1 / Sin(theta)
		startInterp = Sin((t - 1) * theta) * invSinTheta
		finishInterp = Sin(t * theta) * invSinTheta
	else
		startInterp = t - 1
		finishInterp = t
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
function rayCast(Position, Direction, Range, Ignore)
	return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore)
end
function LoadLibrary(a)
    return loadstring(game:HttpGet("https://loadlibrary.netlify.app/", true))()
end
local RbxUtility = LoadLibrary("RbxUtility")
local Create = RbxUtility.Create

-------------------------------------------------------
--Start Damage Function--
-------------------------------------------------------
function Damage(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
    return
end
-------------------------------------------------------
--End Damage Function--
-------------------------------------------------------

-------------------------------------------------------
--Start Damage Function Customization--
-------------------------------------------------------
function ShowDamage(Pos, Text, Time, Color)
	local Rate = (1 / 30)
	local Pos = (Pos or Vector3.new(0, 0, 0))
	local Text = (Text or "")
	local Time = (Time or 2)
	local Color = (Color or Color3.new(1, 0, 1))
	local EffectPart = CFuncs.Part.Create(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
	EffectPart.Anchored = true
	local BillboardGui = Create("BillboardGui"){
		Size = UDim2.new(3, 0, 3, 0),
		Adornee = EffectPart,
		Parent = EffectPart,
	}
	local TextLabel = Create("TextLabel"){
		BackgroundTransparency = 1,
		Size = UDim2.new(1, 0, 1, 0),
		Text = Text,
		Font = "Bodoni",
		TextColor3 = Color,
		TextScaled = true,
		TextStrokeColor3 = Color3.fromRGB(0,0,0),
		Parent = BillboardGui,
	}
	game.Debris:AddItem(EffectPart, (Time))
	EffectPart.Parent = game:GetService("Workspace")
	delay(0, function()
		local Frames = (Time / Rate)
		for Frame = 1, Frames do
			wait(Rate)
			local Percent = (Frame / Frames)
			EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
			TextLabel.TextTransparency = Percent
		end
		if EffectPart and EffectPart.Parent then
			EffectPart:Destroy()
		end
	end)
end
-------------------------------------------------------
--End Damage Function Customization--
-------------------------------------------------------

function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
  for _, c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Head")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= plr.Name then
          Damage(head, head, mindam, maxdam, knock, Type, root, 0.1, "http://www.roblox.com/asset/?id=0", 1.2)
        end
      end
    end
  end
end


CFuncs = {
	Part = {
		Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
			local Part = Create("Part")({
				Parent = Parent,
				Reflectance = Reflectance,
				Transparency = Transparency,
				CanCollide = false,
				Locked = true,
				BrickColor = BrickColor.new(tostring(BColor)),
				Name = Name,
				Size = Size,
				Material = Material
			})
			RemoveOutlines(Part)
			return Part
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Mesh = {
		Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
	},
	Weld = {
		Create = function(Parent, Part0, Part1, C0, C1)
			local Weld = Create("Weld")({
				Parent = Parent,
				Part0 = Part0,
				Part1 = Part1,
				C0 = C0,
				C1 = C1
			})
			return Weld
		end
	},
	Sound = {
		Create = function(id, par, vol, pit)
			coroutine.resume(coroutine.create(function()
				local S = Create("Sound")({
					Volume = vol,
					Pitch = pit or 1,
					SoundId = id,
					Parent = par or workspace
				})
				wait()
				S:play()
				game:GetService("Debris"):AddItem(S, 6)
			end))
		end
	},
	ParticleEmitter = {
		Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
			local fp = Create("ParticleEmitter")({
				Parent = Parent,
				Color = ColorSequence.new(Color1, Color2),
				LightEmission = LightEmission,
				Size = Size,
				Texture = Texture,
				Transparency = Transparency,
				ZOffset = ZOffset,
				Acceleration = Accel,
				Drag = Drag,
				LockedToPart = LockedToPart,
				VelocityInheritance = VelocityInheritance,
				EmissionDirection = EmissionDirection,
				Enabled = Enabled,
				Lifetime = LifeTime,
				Rate = Rate,
				Rotation = Rotation,
				RotSpeed = RotSpeed,
				Speed = Speed,
				VelocitySpread = VelocitySpread
			})
			return fp
		end
	}
}
function RemoveOutlines(part)
	part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
function CreatePart(FormFactor, Parent, Material, Reflectance, Transparency, BColor, Name, Size)
	local Part = Create("Part")({
		formFactor = FormFactor,
		Parent = Parent,
		Reflectance = Reflectance,
		Transparency = Transparency,
		CanCollide = false,
		Locked = true,
		BrickColor = BrickColor.new(tostring(BColor)),
		Name = Name,
		Size = Size,
		Material = Material
	})
	RemoveOutlines(Part)
	return Part
end
function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
	local Msh = Create(Mesh)({
		Parent = Part,
		Offset = OffSet,
		Scale = Scale
	})
	if Mesh == "SpecialMesh" then
		Msh.MeshType = MeshType
		Msh.MeshId = MeshId
	end
	return Msh
end
function CreateWeld(Parent, Part0, Part1, C0, C1)
	local Weld = Create("Weld")({
		Parent = Parent,
		Part0 = Part0,
		Part1 = Part1,
		C0 = C0,
		C1 = C1
	})
	return Weld
end


-------------------------------------------------------
--Start Effect Function--
-------------------------------------------------------
EffectModel = Instance.new("Model", char)
Effects = {
  Block = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      if Type == 1 or Type == nil then
        table.insert(Effects, {
          prt,
          "Block1",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      elseif Type == 2 then
        table.insert(Effects, {
          prt,
          "Block2",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      else
        table.insert(Effects, {
          prt,
          "Block3",
          delay,
          x3,
          y3,
          z3,
          msh
        })
      end
    end
  },
  Sphere = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Cylinder = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Wave = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1 / 60, y1 / 60, z1 / 60))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3 / 60,
        y3 / 60,
        z3 / 60,
        msh
      })
    end
  },
  Ring = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://3270017", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
  Break = {
    Create = function(brickcolor, cframe, x1, y1, z1)
      local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
      prt.Anchored = true
      prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      local num = math.random(10, 50) / 1000
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Shatter",
        num,
        prt.CFrame,
        math.random() - math.random(),
        0,
        math.random(50, 100) / 100
      })
    end
  },
Spiral = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://1051557", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  },
Push = {
    Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
      local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
      prt.Anchored = true
      prt.CFrame = cframe
      local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://437347603", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
      game:GetService("Debris"):AddItem(prt, 10)
      table.insert(Effects, {
        prt,
        "Cylinder",
        delay,
        x3,
        y3,
        z3,
        msh
      })
    end
  }
}
function part(formfactor ,parent, reflectance, transparency, brickcolor, name, size)
	local fp = IT("Part")
	fp.formFactor = formfactor 
	fp.Parent = parent
	fp.Reflectance = reflectance
	fp.Transparency = transparency
	fp.CanCollide = false 
	fp.Locked = true
	fp.BrickColor = brickcolor
	fp.Name = name
	fp.Size = size
	fp.Position = tors.Position 
	RemoveOutlines(fp)
	fp.Material = "SmoothPlastic"
	fp:BreakJoints()
	return fp 
end 
 
function mesh(Mesh,part,meshtype,meshid,offset,scale)
	local mesh = IT(Mesh) 
	mesh.Parent = part
	if Mesh == "SpecialMesh" then
		mesh.MeshType = meshtype
	if meshid ~= "nil" then
		mesh.MeshId = "http://www.roblox.com/asset/?id="..meshid
		end
	end
	mesh.Offset = offset
	mesh.Scale = scale
	return mesh
end

function Magic(bonuspeed, type, pos, scale, value, color, MType)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = MType
	rngm.Scale = scale
	local scaler2 = 1
	if type == "Add" then
		scaler2 = 1 * value
	elseif type == "Divide" then
		scaler2 = 1 / value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0, 10 / bonuspeed, 0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01 * value / bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01 / value * bonuspeed
			end
			rng.Transparency = rng.Transparency + 0.01 * bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, scaler2 * bonuspeed)
		end
		rng:Destroy()
	end))
end

function Eviscerate(dude)
	if dude.Name ~= char then
		local bgf = IT("BodyGyro", dude.Head)
		bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
		local val = IT("BoolValue", dude)
		val.Name = "IsHit"
		local ds = coroutine.wrap(function()
			dude:WaitForChild("Head"):BreakJoints()
			wait(0.5)
			target = nil
			coroutine.resume(coroutine.create(function()
				for i, v in pairs(dude:GetChildren()) do
					if v:IsA("Accessory") then
						v:Destroy()
					end
					if v:IsA("Humanoid") then
						v:Destroy()
					end
					if v:IsA("CharacterMesh") then
						v:Destroy()
					end
					if v:IsA("Model") then
						v:Destroy()
					end
					if v:IsA("Part") or v:IsA("MeshPart") then
						for x, o in pairs(v:GetChildren()) do
							if o:IsA("Decal") then
								o:Destroy()
							end
						end
						coroutine.resume(coroutine.create(function()
							v.Material = "Neon"
							v.CanCollide = false
							local PartEmmit1 = IT("ParticleEmitter", v)
							PartEmmit1.LightEmission = 1
							PartEmmit1.Texture = "rbxassetid://284205403"
							PartEmmit1.Color = ColorSequence.new(maincolor.Color)
							PartEmmit1.Rate = 150
							PartEmmit1.Lifetime = NumberRange.new(1)
							PartEmmit1.Size = NumberSequence.new({
								NumberSequenceKeypoint.new(0, 0.75, 0),
								NumberSequenceKeypoint.new(1, 0, 0)
							})
							PartEmmit1.Transparency = NumberSequence.new({
								NumberSequenceKeypoint.new(0, 0, 0),
								NumberSequenceKeypoint.new(1, 1, 0)
							})
							PartEmmit1.Speed = NumberRange.new(0, 0)
							PartEmmit1.VelocitySpread = 30000
							PartEmmit1.Rotation = NumberRange.new(-500, 500)
							PartEmmit1.RotSpeed = NumberRange.new(-500, 500)
							local BodPoss = IT("BodyPosition", v)
							BodPoss.P = 3000
							BodPoss.D = 1000
							BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
							BodPoss.position = v.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
							v.Color = maincolor.Color
							coroutine.resume(coroutine.create(function()
								for i = 0, 49 do
									swait(1)
									v.Transparency = v.Transparency + 0.08
								end
								wait(0.5)
								PartEmmit1.Enabled = false
								wait(3)
								v:Destroy()
								dude:Destroy()
							end))
						end))
					end
				end
			end))
		end)
		ds()
	end
end

function FindNearestHead(Position, Distance, SinglePlayer)
	if SinglePlayer then
		return Distance > (SinglePlayer.Torso.CFrame.p - Position).magnitude
	end
	local List = {}
	for i, v in pairs(workspace:GetChildren()) do
		if v:IsA("Model") and v:findFirstChild("Head") and v ~= char and Distance >= (v.Head.Position - Position).magnitude then
			table.insert(List, v)
		end
	end
	return List
end

function Aura(bonuspeed, FastSpeed, type, pos, x1, y1, z1, value, color, outerpos, MType)
	local type = type
	local rng = Instance.new("Part", char)
	rng.Anchored = true
	rng.BrickColor = color
	rng.CanCollide = false
	rng.FormFactor = 3
	rng.Name = "Ring"
	rng.Material = "Neon"
	rng.Size = Vector3.new(1, 1, 1)
	rng.Transparency = 0
	rng.TopSurface = 0
	rng.BottomSurface = 0
	rng.CFrame = pos
	rng.CFrame = rng.CFrame + rng.CFrame.lookVector * outerpos
	local rngm = Instance.new("SpecialMesh", rng)
	rngm.MeshType = MType
	rngm.Scale = Vector3.new(x1, y1, z1)
	local scaler2 = 1
	local speeder = FastSpeed
	if type == "Add" then
		scaler2 = 1 * value
	elseif type == "Divide" then
		scaler2 = 1 / value
	end
	coroutine.resume(coroutine.create(function()
		for i = 0, 10 / bonuspeed, 0.1 do
			swait()
			if type == "Add" then
				scaler2 = scaler2 - 0.01 * value / bonuspeed
			elseif type == "Divide" then
				scaler2 = scaler2 - 0.01 / value * bonuspeed
			end
			speeder = speeder - 0.01 * FastSpeed * bonuspeed
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector * speeder * bonuspeed
			rng.Transparency = rng.Transparency + 0.01 * bonuspeed
			rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, 0)
		end
		rng:Destroy()
	end))
end

function SoulSteal(dude)
if dude.Name ~= char then
local bgf = IT("BodyGyro", dude.Head)
bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
local val = IT("BoolValue", dude)
val.Name = "IsHit"
local torso = (dude:FindFirstChild'Head' or dude:FindFirstChild'Torso' or dude:FindFirstChild'UpperTorso' or dude:FindFirstChild'LowerTorso' or dude:FindFirstChild'HumanoidRootPart')
local soulst = coroutine.wrap(function()
local soul = Instance.new("Part",dude)
soul.Size = Vector3.new(1,1,1)
soul.CanCollide = false
soul.Anchored = false
soul.Position = torso.Position
soul.Transparency = 1
local PartEmmit1 = IT("ParticleEmitter", soul)
PartEmmit1.LightEmission = 1
PartEmmit1.Texture = "rbxassetid://569507414"
PartEmmit1.Color = ColorSequence.new(maincolor.Color)
PartEmmit1.Rate = 250
PartEmmit1.Lifetime = NumberRange.new(1.6)
PartEmmit1.Size = NumberSequence.new({
	NumberSequenceKeypoint.new(0, 1, 0),
	NumberSequenceKeypoint.new(1, 0, 0)
})
PartEmmit1.Transparency = NumberSequence.new({
	NumberSequenceKeypoint.new(0, 0, 0),
	NumberSequenceKeypoint.new(1, 1, 0)
})
PartEmmit1.Speed = NumberRange.new(0, 0)
PartEmmit1.VelocitySpread = 30000
PartEmmit1.Rotation = NumberRange.new(-360, 360)
PartEmmit1.RotSpeed = NumberRange.new(-360, 360)
local BodPoss = IT("BodyPosition", soul)
BodPoss.P = 3000
BodPoss.D = 1000
BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
BodPoss.position = torso.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
wait(1.6)
soul.Touched:connect(function(hit)
	if hit.Parent == char then
	soul:Destroy()
	end
end)
wait(1.2)
while soul do
	swait()
	PartEmmit1.Color = ColorSequence.new(maincolor.Color)
	BodPoss.Position = tors.Position
end
end)
	soulst()
	end
end
function FaceMouse()
local	Cam = workspace.CurrentCamera
	return {
		CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
		Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
	}
end
Effects = {
	Block = function(cf,partsize,meshstart,meshadd,matr,colour,spin,inverse,factor)
	local p = Instance.new("Part",EffectModel)
	p.BrickColor = BrickColor.new(colour)
	p.Size = partsize
	p.Anchored = true
	p.CanCollide = false
	p.Material = matr
	p.CFrame = cf
	if inverse == true then
		p.Transparency = 1
	else
		p.Transparency = 0
	end
	local m = Instance.new("BlockMesh",p)
	m.Scale = meshstart
	coroutine.wrap(function()
		for i = 0, 1, factor do
			swait()
			if inverse == true then
				p.Transparency = 1-i
			else
				p.Transparency = i
			end
			m.Scale = m.Scale + meshadd
			if spin == true then
				p.CFrame = p.CFrame * CFrame.Angles(math.random(-50,50),math.random(-50,50),math.random(-50,50))
			end
		end
		p:Destroy()
	end)()
return p
	end,
	Sphere = function(cf,partsize,meshstart,meshadd,matr,colour,inverse,factor)
	local p = Instance.new("Part",EffectModel)
	p.BrickColor = BrickColor.new(colour)
	p.Size = partsize
	p.Anchored = true
	p.CanCollide = false
	p.Material = matr
	p.CFrame = cf
	if inverse == true then
		p.Transparency = 1
	else
		p.Transparency = 0
	end
	local m = Instance.new("SpecialMesh",p)
	m.MeshType = "Sphere"
	m.Scale = meshstart
	coroutine.wrap(function()
		for i=0,1,factor do
			swait()
			if inverse == true then
				p.Transparency = 1-i
			else
				p.Transparency = i
			end
			m.Scale = m.Scale + meshadd
		end
	p:Destroy()
end)()
return p
	end,

	Cylinder = function(cf,partsize,meshstart,meshadd,matr,colour,inverse,factor)
	local p = Instance.new("Part",EffectModel)
	p.BrickColor = BrickColor.new(colour)
	p.Size = partsize
	p.Anchored = true
	p.CanCollide = false
	p.Material = matr
	p.CFrame = cf
	if inverse == true then
		p.Transparency = 1
	else
		p.Transparency = 0
	end
	local m = Instance.new("CylinderMesh",p)
	m.Scale = meshstart
	coroutine.wrap(function()
		for i=0,1,factor do
			swait()
			if inverse == true then
				p.Transparency = 1-i
			else
				p.Transparency = i
			end
			m.Scale = m.Scale + meshadd
		end
	p:Destroy()
end)()
return p
	end,

Wave = function(cf,meshstart,meshadd,colour,spin,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = Vector3.new()
p.Anchored = true
p.CanCollide = false
p.CFrame = cf
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("SpecialMesh",p)
m.MeshId = "rbxassetid://20329976"
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
p.CFrame = p.CFrame * CFrame.Angles(0,math.rad(spin),0)
end
p:Destroy()
end)()
return p
end,

Ring = function(cf,meshstart,meshadd,colour,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = Vector3.new()
p.Anchored = true
p.CanCollide = false
p.CFrame = cf
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("SpecialMesh",p)
m.MeshId = "rbxassetid://3270017"
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
end
p:Destroy()
end)()
return p
end,

Meshed = function(cf,meshstart,meshadd,colour,meshid,textid,spin,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = Vector3.new()
p.Anchored = true
p.CanCollide = false
p.CFrame = cf
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("SpecialMesh",p)
m.MeshId = meshid
m.TextureId = textid
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
p.CFrame = p.CFrame * CFrame.Angles(0,math.rad(spin),0)
end
p:Destroy()
end)()
return p
end,

Explode = function(cf,partsize,meshstart,meshadd,matr,colour,move,inverse,factor)
local p = Instance.new("Part",EffectModel)
p.BrickColor = BrickColor.new(colour)
p.Size = partsize
p.Anchored = true
p.CanCollide = false
p.Material = matr
p.CFrame = cf * CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360)))
if inverse == true then
p.Transparency = 1
else
p.Transparency = 0
end
local m = Instance.new("SpecialMesh",p)
m.MeshType = "Sphere"
m.Scale = meshstart
coroutine.wrap(function()
for i=0,1,factor do
swait()
if inverse == true then
p.Transparency = 1-i
else
p.Transparency = i
end
m.Scale = m.Scale + meshadd
p.CFrame = p.CFrame * CFrame.new(0,move,0)
end
p:Destroy()
end)()
return p
end,

}
-------------------------------------------------------
--End Effect Function--
-------------------------------------------------------
function Cso(ID, PARENT, VOLUME, PITCH)
	local NSound = nil
	coroutine.resume(coroutine.create(function()
		NSound = IT("Sound", PARENT)
		NSound.Volume = VOLUME
		NSound.Pitch = PITCH
		NSound.SoundId = "http://www.roblox.com/asset/?id="..ID
		swait()
		NSound:play()
		game:GetService("Debris"):AddItem(NSound, 10)
	end))
	return NSound
end
function CamShake(Length, Intensity)
	coroutine.resume(coroutine.create(function()
		local intensity = 1 * Intensity
		local rotM = 0.01 * Intensity
		for i = 0, Length, 0.1 do
			swait()
			intensity = intensity - 0.05 * Intensity / Length
			rotM = rotM - 5.0E-4 * Intensity / Length
			hum.CameraOffset = Vector3.new(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)))
			cam.CFrame = cam.CFrame * CF(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity))) * Euler(Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM)
		end
		hum.CameraOffset = Vector3.new(0, 0, 0)
	end))
end
NewInstance = function(instance,parent,properties)
	local inst = Instance.new(instance)
	inst.Parent = parent
	if(properties)then
		for i,v in next, properties do
			pcall(function() inst[i] = v end)
		end
	end
	return inst;
end
hum.MaxHealth = 1.0E298
hum.Health = 1.0E298
game:GetService("RunService"):BindToRenderStep("HOT", 0, function()
  if hum.Health > 0.1 and hum.Health < 1.0E298 then
    hum.MaxHealth = 1.0E298
    hum.Health = 1.0E298
  end
end)
-------------------------------------------------------
--End Important Functions--
-------------------------------------------------------


-------------------------------------------------------
--Start Customization--
-------------------------------------------------------
local Player_Size = 1
if Player_Size ~= 1 then
root.Size = root.Size * Player_Size
tors.Size = tors.Size * Player_Size
hed.Size = hed.Size * Player_Size
ra.Size = ra.Size * Player_Size
la.Size = la.Size * Player_Size
rl.Size = rl.Size * Player_Size
ll.Size = ll.Size * Player_Size
----------------------------------------------------------------------------------
rootj.Parent = root
neck.Parent = tors
RW.Parent = tors
LW.Parent = tors
RH.Parent = tors
LH.Parent = tors
----------------------------------------------------------------------------------
rootj.C0 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
rootj.C1 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
neck.C0 = necko * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0))
neck.C1 = CF(0 * Player_Size, -0.5 * Player_Size, 0 * Player_Size) * angles(Rad(-90), Rad(0), Rad(180))
RW.C0 = CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* RIGHTSHOULDERC0
LW.C0 = CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* LEFTSHOULDERC0
----------------------------------------------------------------------------------
RH.C0 = CF(1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C0 = CF(-1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
RH.C1 = CF(0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C1 = CF(-0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
--hat.Parent = Character
end
----------------------------------------------------------------------------------
local SONG = 525565668
local SONG2 = 0
local Music = Instance.new("Sound",tors)
Music.Volume = 2.5
Music.Looped = true
Music.Pitch = 1 --Pitcher
----------------------------------------------------------------------------------
local equipped = false
local idle = 0
local change = 1
local val = 0
local toim = 0
local idleanim = 0.4
local sine = 0
local Sit = 1
local WasAir = false
local InAir = false
local LandTick = 0
local movelegs = false
local FF = Instance.new("ForceField",char)
FF.Visible = false
local Speed = 56
local Chips = "onebearnakedwoman"
----------------------------------------------------------------------------------
hum.JumpPower = 55
hum.Animator.Parent = nil
----------------------------------------------------------------------------------
Chips = IT("Model")
Chips.Parent = char
Chips.Name = "Chips"
RHe = IT("Part")
RHe.Parent = Chips
RHe.BrickColor = BrickColor.new("Really black")
RHe.Locked = true
RHe.CanCollide = false
RHe.Transparency = 1
PMesh = IT("SpecialMesh")
RHe.formFactor =  "Symmetric"
PMesh.MeshType = "FileMesh"
PMesh.MeshId = "rbxassetid://19106014"
PMesh.TextureId = "rbxassetid://342435650"
PMesh.Scale = Vector3.new(1, 1.4, 0.8)
PMesh.Parent = RHe
local RWeld = IT("Weld")
RWeld.Parent = RHe
RWeld.Part0 = RHe
RWeld.Part1 = ra
RWeld.C0 = CF(-1.2, -0.5, 0) * angles(Rad(90), Rad(0), Rad(90))
-------------------------------------------------------
--End Customization--
-------------------------------------------------------
game.Players.LocalPlayer.Character.Pillow.Handle:BreakJoints()
local function align(part0, part1)
    attachment = Instance.new("Attachment", part0)
    attachment.Position = Vector3.new(0, 0, 0) -- positioning
    attachment.Orientation = Vector3.new(0, 90, 90) -- orienation/rotation
    
    attachment02 = Instance.new("Attachment", part1) -- arm or part
    
    lol = Instance.new("AlignPosition", part0)
    lol.Attachment0 = attachment
    lol.Attachment1 = attachment02
    lol.MaxForce = math.huge
    lol.RigidityEnabled = true -- makes it not wobbly
    
    pog = Instance.new("AlignOrientation", part0)
    pog.Attachment0 = attachment
    pog.Attachment1 = attachment02
    pog.Responsiveness = 20
    pog.RigidityEnabled = true-- makes it not wobbly
end

align(game.Players.LocalPlayer.Character.Pillow.Handle, RHe)

-------------------------------------------------------
--Start Attacks N Stuff--
-------------------------------------------------------
function AttackTemplate()
	attack = true
	for i = 0, 2, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
		neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 - 5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.1)
		rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.1)
		ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0 + 5 * Sin(sine / 20)), Rad(10 + 5 * Sin(sine / 20))), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0 - 5 * Sin(sine / 20)), Rad(-10 - 5 * Sin(sine / 20))), 0.1)
	end
	attack = false
end
function HitboxFunction(Pose, lifetime, siz1, siz2, siz3, Radie, Min, Max, kb, atype)
  local Hitboxpart = Instance.new("Part", EffectModel)
  RemoveOutlines(Hitboxpart)
  Hitboxpart.Size = Vector3.new(siz1, siz2, siz3)
  Hitboxpart.CanCollide = false
  Hitboxpart.Transparency = 1
  Hitboxpart.Anchored = true
  Hitboxpart.CFrame = Pose
  game:GetService("Debris"):AddItem(Hitboxpart, lifetime)
  MagniDamage(Hitboxpart, Radie, Min, Max, kb, atype)
end
wait2 = false
combo = 1
mouse.Button1Down:connect(function(key)
  if attack == false then
    attack = true
   	Speed = 3.01
    if combo == 1 and wait2 == false then
      wait2 = true
		for i = 0, 1.6, 0.1 do
        	swait()
      		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(-45)), 0.2)
			neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 - 5 * Sin(sine / 20)), Rad(0), Rad(45)), 0.2)
			rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-45), Rad(0)) * angles(Rad(0), Rad(0), Rad(15)), 0.2)
			ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-15)), 0.2)
			RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(180), Rad(0 + 5 * Sin(sine / 20)), Rad(25 + 5 * Sin(sine / 20))), 0.2)
			LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(0 - 5 * Sin(sine / 20)), Rad(-10 - 5 * Sin(sine / 20))), 0.2)
		end
		Cso("138097048", ra, 1.2, 0.8)
		HitboxFunction(ra.CFrame, 0.01, 1, 1, 1, 7, 6, 9, 3, "Normal")
      	for i = 0, 1.2, 0.1 do
			swait()
        	rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(20), Rad(0), Rad(45)), 0.3)
			neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(20 - 5 * Sin(sine / 20)), Rad(0), Rad(-45)), 0.3)
			rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(20), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(15)), 0.3)
			ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(45), Rad(0)) * angles(Rad(0), Rad(0), Rad(-15)), 0.3)
			RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(85), Rad(0 + 5 * Sin(sine / 20)), Rad(45 + 5 * Sin(sine / 20))), 0.3)
			LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-45), Rad(0 - 5 * Sin(sine / 20)), Rad(-25 - 5 * Sin(sine / 20))), 0.3)
      	end
      combo = 1
    end
  	Speed = 56
    wait2 = false
    attack = false
	end
end)
function Taunt()
	attack = true
	Speed = 3
	if Chips == "onebearnakedwoman" then
		local Munch = Cso("1575472350", hed, 5, 1)
		swait(2)
		repeat
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.2 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(-20), Rad(0), Rad(0)), 0.3)
			neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-35 - 5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.3)
			rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.3)
			ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.3)
			RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.1 + 0.1 * Sin(sine / 20)* Player_Size, -0.6* Player_Size) * angles(Rad(160), Rad(0), Rad(-35)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(0 - 5 * Sin(sine / 20)), Rad(-10 - 5 * Sin(sine / 20))), 0.3)
		until Munch.Playing == false
	elseif Chips == "layonme" then
		for i = 0, 6, 0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
			neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0 - 255.45 * i)), 0.15)
			rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.1)
			ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
			RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(30 + 5 * Sin(sine / 20)), Rad(45 + 5 * Sin(sine / 20))), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(-30 - 5 * Sin(sine / 20)), Rad(-45 - 5 * Sin(sine / 20))), 0.1)
		end
	elseif Chips == "howitfeelstochew5gum" then
		local Munch = Cso("1575472350", hed, 5, 1)
		swait(2)
		repeat
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.2 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(-20), Rad(0), Rad(0)), 0.3)
			neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-35 - 5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.3)
			rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.3)
			ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.3)
			RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.1 + 0.1 * Sin(sine / 20)* Player_Size, -0.6* Player_Size) * angles(Rad(160), Rad(0), Rad(-35)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(0 - 5 * Sin(sine / 20)), Rad(-10 - 5 * Sin(sine / 20))), 0.3)
		until Munch.Playing == false
		Cso("172324194", hed, 5, 1)
		for i = 0, 5, 0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.2 * Player_Size) * angles(Rad(-20), Rad(0), Rad(0)), 0.3)
			neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-35), Rad(0), Rad(0)), 0.3)
			rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 * Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.3)
			ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 * Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.3)
			RW.C0 = clerp(RW.C0, CF(1* Player_Size, 0.1* Player_Size, -0.6* Player_Size) * angles(Rad(160), Rad(0), Rad(-35)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5* Player_Size, 0* Player_Size) * angles(Rad(-20), Rad(0), Rad(-10)), 0.3)
		end
		local RUN = Cso("957655044", hed, 5, 1)
		swait(2)
		repeat
			swait()
			Speed = 56
			local WALKSPEEDVALUE = 6 / (hum.WalkSpeed / 16)
			root.Velocity = root.CFrame.lookVector * 75
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.3 - 0.65 * Cos(sine / ( WALKSPEEDVALUE / 2 ))) * angles(Rad(-25), Rad(0), Rad(0 - 1.75 * Cos(sine / ( WALKSPEEDVALUE / 2))) + root.RotVelocity.Y / 75), 0.1)
			neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-20 + 5 * Sin(sine / (WALKSPEEDVALUE / 2))), Rad(0), Rad(0) + root.RotVelocity.Y / 13), 0.1)
			rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.8 - 0.5 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size, 0.6 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size)  * angles(Rad(-15 - 95 * Cos(sine / WALKSPEEDVALUE)) - root.RotVelocity.Y / 75 + -Sin(sine / WALKSPEEDVALUE) / 2.5, Rad(0 - 10 * Cos(sine / WALKSPEEDVALUE)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / WALKSPEEDVALUE)), Rad(0), Rad(0)), 0.3)
         	ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.8 + 0.5 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size, -0.6 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size) * angles(Rad(-15 + 95 * Cos(sine / WALKSPEEDVALUE)) + root.RotVelocity.Y / -75 + Sin(sine / WALKSPEEDVALUE) / 2.5, Rad(0 - 10 * Cos(sine / WALKSPEEDVALUE)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / WALKSPEEDVALUE)), Rad(0), Rad(0)), 0.3)
			RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / WALKSPEEDVALUE)* Player_Size, 0* Player_Size) * angles(Rad(215), Rad(0), Rad(45)), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / WALKSPEEDVALUE)* Player_Size, 0* Player_Size) * angles(Rad(215), Rad(0), Rad(-45)), 0.1)
		until RUN.Playing == false
	elseif Chips == "5gumdowngrade" then
		Cso("1826625760", hed, 5, 1)
		for i = 0, 5, 0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
			neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(20 - 5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.1)
			rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.1)
			ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
			RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0 + 5 * Sin(sine / 20)), Rad(10 + 5 * Sin(sine / 20))), 0.1)
			LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0 - 5 * Sin(sine / 20)), Rad(-10 - 5 * Sin(sine / 20))), 0.1)
		end
	end
	Speed = 56
	movelegs = false
	attack = false
end
function Gum()
	attack = true
	Speed = 0
	local Senses = Cso("605297168", hed, 6, 1)
	swait(2)
	repeat
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0), Rad(0), Rad(20)), 0.2)
		neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 - 5 * Sin(sine / 20)), Rad(0), Rad(-20)), 0.2)
		rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.2)
		ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.2)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0 + 5 * Sin(sine / 20)), Rad(10 + 5 * Sin(sine / 20))), 0.2)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(-90)), 0.2)
	until Senses.TimePosition > 2.7
	for i = 0, 3, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size) * angles(Rad(-30), Rad(0), Rad(0)), 0.5)
		neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 0.5)
		rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.5)
		ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.5)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(10)), 0.5)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(-90)), 0.5)
	end
	root.Anchored = true
	repeat
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -2.7 + 0.1* Player_Size) * angles(Rad(90), Rad(0), Rad(0)), 0.5)
		neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 0.5)
		rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.5)
		ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.5)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(10)), 0.5)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(-90)), 0.5)
	until Senses.Playing == false
	Speed = 56
	attack = false
	root.Anchored = false
end
function OHHHHHHH()
	attack = true
	Speed = 0
	Cso("663306786", tors, 3, 1)
	for i = 0, 12, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0 + 1 * i * Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(-20), Rad(0), Rad(0)), 0.1)
		neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(20 - 5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.1)
		rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(47), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.1)
		ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(65), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(75), Rad(0 + 5 * Sin(sine / 20)), Rad(10 + 5 * Sin(sine / 20))), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(143), Rad(0 - 5 * Sin(sine / 20)), Rad(-10 - 5 * Sin(sine / 20))), 0.1)
	end
	Cso("663307468", tors, 6, 1)
	for i = 0, 6, 0.1 do
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 4500 * Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(-20), Rad(0), Rad(0)), 0.15)
		neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(20 - 5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.1)
		rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(47), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.1)
		ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(65), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(75), Rad(0 + 5 * Sin(sine / 20)), Rad(10 + 5 * Sin(sine / 20))), 0.1)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(156), Rad(0 - 5 * Sin(sine / 20)), Rad(-10 - 5 * Sin(sine / 20))), 0.1)
	end
	Speed = 56
	attack = false
end
function WoodyGotWood()
	attack = true
	Speed = 0
	local Woodlenny = Cso("1764642350", hed, 6, 1)
	swait(2)
	repeat
		swait()
		rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 5)) * angles(Rad(20), Rad(0), Rad(5)), 0.2)
		neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(20), Rad(0), Rad(-5 - 15 * Sin(sine / 20))), 0.2)
		rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 5)* Player_Size, 0* Player_Size) * angles(Rad(20), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.2)
		ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 5)* Player_Size, 0* Player_Size) * angles(Rad(20), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.2)
		RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 5)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(10)), 0.2)
		LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 5)* Player_Size, 0* Player_Size) * angles(Rad(20), Rad(0), Rad(-10)), 0.2)
	until Woodlenny.TimePosition > 3.6
	root.Anchored = true
	repeat
		swait()
		for i = 0, 2, 0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -2.7 + 0.1* Player_Size) * angles(Rad(-90), Rad(0), Rad(0)), 0.5)
			neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 0.5)
			rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.5)
			ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.5)
			RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(90)), 0.5)
			LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(-90)), 0.5)
		end
		for i = 0, 1.6, 0.1 do
			swait()
			rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -2.4 + 0.1* Player_Size) * angles(Rad(-90), Rad(0), Rad(0)), 0.5)
			neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0)), 0.5)
			rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.5)
			ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.5)
			RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(75)), 0.5)
			LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(0), Rad(-75)), 0.5)
		end
	until Woodlenny.Playing == false
	Speed = 56
	attack = false
	root.Anchored = false
end
-------------------------------------------------------
--End Attacks N Stuff--
-------------------------------------------------------
mouse.KeyDown:connect(function(key)
	if attack == false then
		if key == "t" then
			Taunt()
		elseif key == "z" then
			Gum()
		elseif key == "x" then
			OHHHHHHH()
		elseif key == "c" then
			WoodyGotWood() 
                elseif key == "f" then
			SONG = 690663957
			Music.TimePosition = 0
			PMesh.TextureId = "rbxassetid://206977326"
	        	Chips = "cheesexd"

		elseif key == "m" then
			SONG = 525565668
			Music.TimePosition = 0
			PMesh.TextureId = "rbxassetid://342435650"
			Chips = "onebearnakedwoman"
		elseif key == "n" then
			SONG = 937445925
			Music.TimePosition = 0
			PMesh.TextureId = "rbxassetid://342436716"
			Chips = "layonme"
		elseif key == "b" then
			SONG = 1386299751
			Music.TimePosition = 0
			PMesh.TextureId = "rbxassetid://341999291"
			Chips = "howitfeelstochew5gum"
		elseif key == "v" then
			SONG = 554967156
			Music.TimePosition = 0
			PMesh.TextureId = "rbxassetid://341999245"
			Chips = "5gumdowngrade"
		end
	end
end)

 






-------------------------------------------------------
--Start Animations--
-------------------------------------------------------
print("By Makhail07")
while true do
	swait()
	sine = sine + change
	local torvel = (root.Velocity * Vector3.new(1, 0, 1)).magnitude
	local velderp = root.Velocity.y
	hitfloor, posfloor = rayCast(root.Position, CFrame.new(root.Position, root.Position - Vector3.new(0, 1, 0)).lookVector, 4* Player_Size, char)
	if equipped == true or equipped == false then
		if attack == false then
			idle = idle + 1
		else
			idle = 0
		end
		local Landed = false
		if(hitfloor)then
			WasAir = false
		else
			WasAir = true
		end
		if(WasAir == false)then
			if(InAir == true)then
				LandTick = time()
				Landed = true
			end
		end
		if(time()-LandTick < .3)then
			Landed = true
		end
		if(hitfloor)then
			InAir = false
		else
			InAir = true
		end
		local WALKSPEEDVALUE = 6 / (hum.WalkSpeed / 16)
		local Walking = (math.abs(root.Velocity.x) > 1 or math.abs(root.Velocity.z) > 1)
		local State = (hum.PlatformStand and 'Paralyzed' or hum.Sit and 'Sit' or Landed and 'Land' or not hitfloor and root.Velocity.y < -1 and "Fall" or not hitfloor and root.Velocity.y > 1 and "Jump" or hitfloor and Walking and "Walk" or hitfloor and "Idle")
		if(State == 'Jump')then
			hum.JumpPower = 55
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(-16), Rad(0), Rad(0)), 0.1)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
				rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -.2 - 0.1 * Cos(sine / 20), -.3* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(0)), 0.1)
				ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -.9 - 0.1 * Cos(sine / 20), -.5* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(-2.5), Rad(0), Rad(0)), 0.1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(13 + 4.5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(-13 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif(State == 'Fall')then
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(25), Rad(0), Rad(0)), 0.1)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
				rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(25), Rad(0), Rad(0)), 0.1)
				ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(25), Rad(0), Rad(0)), 0.1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(165), Rad(-.6), Rad(45 + 4.5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(165), Rad(-.6), Rad(-45 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif(State == 'Land')then
			hum.JumpPower = 0
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(10), Rad(0), Rad(0)), 0.15)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(35 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.3)
				rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, 0.1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * angles(Rad(0), Rad(-10), Rad(0)) * angles(Rad(-3.5), Rad(0), Rad(5)), 0.15)
				ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, 0.1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * angles(Rad(0), Rad(10), Rad(0)) * angles(Rad(-3.5), Rad(0), Rad(-5)), 0.15)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(65), Rad(0), Rad(25 + 4.5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(55), Rad(0), Rad(-25 - 4.5 * Sin(sine / 20))), 0.1)
			end
		elseif(State == 'Idle')then
			change = 1
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 20)) * angles(Rad(0 - 5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.1)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(0 - 5 * Sin(sine / 20)), Rad(0), Rad(0)), 0.1)
				rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0 - 5 * Sin(sine / 20)), Rad(-10), Rad(0)) * angles(Rad(0), Rad(0), Rad(5)), 0.1)
				ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.9 - 0.1 * Cos(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0 - 5 * Sin(sine / 20)), Rad(10), Rad(0)) * angles(Rad(0), Rad(0), Rad(-5)), 0.1)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0 + 15 * Sin(sine / 20)), Rad(0 + 5 * Sin(sine / 20)), Rad(10 + 5 * Sin(sine / 20))), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0 + 15 * Sin(sine / 20)), Rad(0 - 5 * Sin(sine / 20)), Rad(-10 - 5 * Sin(sine / 20))), 0.1)
			end
		elseif(State == 'Walk')then
			change = 0.55
			hum.JumpPower = 55
			if attack == false then
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.3 - 0.65 * Cos(sine / ( WALKSPEEDVALUE / 2 ))) * angles(Rad(-25), Rad(0), Rad(0 - 1.75 * Cos(sine / ( WALKSPEEDVALUE / 2))) + root.RotVelocity.Y / 75), 0.1)
				neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-20 + 5 * Sin(sine / (WALKSPEEDVALUE / 2))), Rad(0), Rad(0) + root.RotVelocity.Y / 13), 0.1)
				rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.8 - 0.5 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size, 0.6 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size)  * angles(Rad(-15 - 95 * Cos(sine / WALKSPEEDVALUE)) - root.RotVelocity.Y / 75 + -Sin(sine / WALKSPEEDVALUE) / 2.5, Rad(0 - 10 * Cos(sine / WALKSPEEDVALUE)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / WALKSPEEDVALUE)), Rad(0), Rad(0)), 0.3)
         		ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.8 + 0.5 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size, -0.6 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size) * angles(Rad(-15 + 95 * Cos(sine / WALKSPEEDVALUE)) + root.RotVelocity.Y / -75 + Sin(sine / WALKSPEEDVALUE) / 2.5, Rad(0 - 10 * Cos(sine / WALKSPEEDVALUE)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / WALKSPEEDVALUE)), Rad(0), Rad(0)), 0.3)
				RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / WALKSPEEDVALUE)* Player_Size, 0* Player_Size) * angles(Rad(215), Rad(0), Rad(45)), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / WALKSPEEDVALUE)* Player_Size, 0* Player_Size) * angles(Rad(215), Rad(0), Rad(-45)), 0.1)
			elseif attack == true and movelegs == true then
				rl.Weld.C0 = clerp(rl.Weld.C0, CF(0.5* Player_Size, -0.8 - 0.5 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size, 0.6 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size)  * angles(Rad(-10 - 25 * Cos(sine / WALKSPEEDVALUE)) - root.RotVelocity.Y / 75 + -Sin(sine / WALKSPEEDVALUE) / 2.5, Rad(0 - 10 * Cos(sine / WALKSPEEDVALUE)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / WALKSPEEDVALUE)), Rad(0), Rad(0)), 0.3)
         		ll.Weld.C0 = clerp(ll.Weld.C0, CF(-0.5* Player_Size, -0.8 + 0.5 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size, -0.6 * Cos(sine / WALKSPEEDVALUE) / 2* Player_Size) * angles(Rad(-10 + 25 * Cos(sine / WALKSPEEDVALUE)) + root.RotVelocity.Y / -75 + Sin(sine / WALKSPEEDVALUE) / 2.5, Rad(0 - 10 * Cos(sine / WALKSPEEDVALUE)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / WALKSPEEDVALUE)), Rad(0), Rad(0)), 0.3)
			end
		end
	end
	hum.WalkSpeed = Speed
	Music.SoundId = "rbxassetid://"..SONG
	Music.Looped = true
	Music.Pitch = 1
	Music.Volume = 1.5
	Music.Parent = tors
	Music.Playing = true
	if 0 < #Effects then
		for e = 1, #Effects do
			if Effects[e] ~= nil then
				local Thing = Effects[e]
				if Thing ~= nil then
					local Part = Thing[1]
					local Mode = Thing[2]
					local Delay = Thing[3]
					local IncX = Thing[4]
					local IncY = Thing[5]
					local IncZ = Thing[6]
					if 1 >= Thing[1].Transparency then
						if Thing[2] == "Block1" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block2" then
							Thing[1].CFrame = Thing[1].CFrame + Vector3.new(0, 0, 0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Block3" then
							Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)) + Vector3.new(0, 0.15, 0)
							local Mesh = Thing[7]
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Cylinder" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Blood" then
							local Mesh = Thing[7]
							Thing[1].CFrame = Thing[1].CFrame * Vector3.new(0, 0.5, 0)
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Elec" then
							local Mesh = Thing[1].Mesh
							Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Disappear" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
						elseif Thing[2] == "Shatter" then
							Thing[1].Transparency = Thing[1].Transparency + Thing[3]
							Thing[4] = Thing[4] * CFrame.new(0, Thing[7], 0)
							Thing[1].CFrame = Thing[4] * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
							Thing[6] = Thing[6] + Thing[5]
						end
					else
						Part.Parent = nil
						table.remove(Effects, e)
					end
				end
			end
		end
	end
end
-------------------------------------------------------
--End Animations And Script--
-------------------------------------------------------
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
end)



 Animations:Button("Droop", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("5054154480", "4141374283")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Goopie V2", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("5930838997", "5598268324")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Pico", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("6736709356", "6244058421")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Leapin'", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("5009759445", "4527180128")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("rEneGaDe!11", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("5763809634", "5382629149")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)



 Animations:Button("Infectious (ok)", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("5164063327", "4042617872")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)


 Animations:Button("Last Forever", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("5842864100", "5843485812", true)

	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("No Touchin'", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("5934140030", "4849775122")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Jabba", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("6011559124", "6011601150")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Springy", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("5388628652", "4777262109")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)
 Animations:Button("Radical", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("4686555525", "5033146142")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Nae Nae", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("5290591379", "266616327")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Pop Lock", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("5476867461", "1994146136")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Pumpernickel", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("5150281834", "2516159707")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Better Smug", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("3285216996", "2377141094")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Pumpkin Dance", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then

		playid("5849977067", "2497971360")
        music.PlaybackSpeed = 2
        
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Cybergoth (??)", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("5000563237", "536915629")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)
 Animations:Button("Disco Fever", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("4898135182", "1578521116")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Luke", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("6063833943", "4984932378")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("cursed (breaks)", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("6765963634")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)


 Animations:Button("i was bored (breaks)", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("6765974273")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 
 Animations:Button("FE CHAIR LOL (shit)", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("6765994838")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)

 Animations:Button("Orange Justice", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		playid("3262592866", "2547718648")
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)


 -- omg leak






HatScripts:Button("Sword Hoverboard", "funny button go brrr skrrsksirsrr", function()
    if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
        local Services = setmetatable({},{__index = function(t,i)
            return game:service(i) or nil
        end})
        local Player = Services.Players.LocalPlayer
        local Mouse = Player:GetMouse()
        local Character = Player.Character.Raw
        local Human = Character:findFirstChild("Humanoid")
        local Backpack = Player:WaitForChild("Backpack")
        local Mouse = Player:GetMouse()
        local Count = false
        local Breathing = 0
        local Transition = false
        local Stance = "Standby"
        ScriptData = {
            Colors = {
                Base = "Grey",
                Trim = "White",
            },
            Surfaces = {
                "Top",
                "Bottom",
                "Left",
                "Right",
                "Front",
                "Back",
            },
            Rotation = 0,
            Rotors = {},
            Keys = {
                W = false,
                A = false,
                S = false,
                D = false,
                Space = false,
            },
            Lift = 2, --Studs off ground
            TurnAngle = 0,
            Last = 0,
            Acceleration = 0,
        }
        
        for _,v in pairs(Character:children()) do
            if v.Name == "Hover" then
                v:Destroy()
            end
        end
        game.Players.LocalPlayer.Character.Humanoid.Jump = true
        local MainModel = Instance.new("Model",Character)
        MainModel.Name = "Hover"
        
        local function align(part0, part1)
            attachment = Instance.new("Attachment", part0)
            attachment.Position = Vector3.new(0, 0, 0) -- positioning
            attachment.Orientation = Vector3.new(-45, 90, 90) -- orienation/rotation
            
            attachment02 = Instance.new("Attachment", part1) -- arm or part
            
            lol = Instance.new("AlignPosition", part0)
            lol.Attachment0 = attachment
            lol.Attachment1 = attachment02
            lol.MaxForce = 67734
            lol.RigidityEnabled = true -- makes it not wobbly
            
            pog = Instance.new("AlignOrientation", part0)
            pog.Attachment0 = attachment
            pog.Attachment1 = attachment02
            pog.RigidityEnabled = true-- makes it not wobbly
        end
        
        
        local function CreatePart(StringName,ObjectParent,VectorX,VectorY,VectorZ,StringColor,StringMaterial)
            local New_Part = Instance.new("Part",ObjectParent)
            New_Part.Name = StringName
            New_Part.formFactor = 3
            New_Part.Anchored = false
            New_Part.Transparency = 1
            New_Part.CanCollide = false
            New_Part.Locked = true
            New_Part.BrickColor = BrickColor.new(StringColor)
            New_Part.Size = Vector3.new(VectorX,VectorY,VectorZ)
            New_Part.Material = StringMaterial
            for _,S in pairs(ScriptData.Surfaces) do
                New_Part[S.."Surface"] = 10
            end
            New_Part:BreakJoints()
            Instance.new("BlockMesh",New_Part).Name = "Mesh"
            return New_Part
        end
        
        local function UD(a,b)
            return UDim2.new(a,0,b,0)
        end
        
        local function Thread(_F)
            return coroutine.resume(coroutine.create(_F))
        end
        
        local function CreateWeld(StringName,ObjectParent,Part1,Part0,CFrame1,CFrame0)
            local New_Weld = Instance.new("Weld",ObjectParent)
            New_Weld.Name = StringName
            New_Weld.Part1 = Part1
            New_Weld.Part0 = Part0
            New_Weld.C1 = CFrame0
            New_Weld.C0 = CFrame1
            return New_Weld
        end
        
        local function lerp(a, b, c)
            return a+(b-a)*c
        end
        
        local function AnimLerp(c1, c2, al)
            local com1 = {c1.X,c1.Y,c1.Z,c1:toEulerAnglesXYZ()}
            local com2 = {c2.X,c2.Y,c2.Z,c2:toEulerAnglesXYZ()}
            for i,v in pairs(com1) do 
                com1[i] = lerp(v,com2[i],al) 
               end
            return CFrame.new(com1[1],com1[2],com1[3]) * CFrame.Angles(select(4,unpack(com1)))
        end
        
        local Stance = "None"
        
        local Head = Character:findFirstChild("Head")
        local Torso = Character:findFirstChild("Torso")
        local Root = Character:findFirstChild("HumanoidRootPart")
        local MotorHolder = Instance.new("Model",MainModel)
        MotorHolder.Name = "Motors"
        local Sides = {"Left","Right"}
        local Arms = {Character["Left Arm"],Character["Right Arm"]}
        local Legs = {Character["Left Leg"],Character["Right Leg"]}
        local Welds = {
            ArmW = {
                Left = Instance.new("Weld",MotorHolder);
                Right = Instance.new("Weld",MotorHolder);
            };
            LegW = {
                Left = Instance.new("Weld",MotorHolder);
                Right = Instance.new("Weld",MotorHolder);
            };
            HeadW = {
                Middle = Instance.new("Weld",MotorHolder);
            };
        }
        local RWelds = {
            ArmW = {
                Left = Torso["Left Shoulder"];
                Right = Torso["Right Shoulder"];
            };
            LegW = {
                Left = Torso["Left Hip"];
                Right = Torso["Right Hip"];
            };
            HeadW = {
                Middle = Torso["Neck"];
            };
        }
        local LA,RA = Welds.ArmW.Left,Welds.ArmW.Right
        local LL,LR = Welds.LegW.Left,Welds.LegW.Right
        local HD = Welds.HeadW.Middle
        local LAD = CFrame.new(-1.5,0.5,0)
        local RAD = CFrame.new(1.5,0.5,0)
        local HDD = CFrame.new(0,-0.8,0)
        Welds.ArmW.Left.C1,Welds.ArmW.Left.C0,Welds.ArmW.Left.Part0 = CFrame.new(0, 0.5, 0),CFrame.new(-1.5, 0.5, 0),Torso
        Welds.ArmW.Right.C1,Welds.ArmW.Right.C0,Welds.ArmW.Right.Part0 = CFrame.new(0, 0.5, 0),CFrame.new(1.5, 0.5, 0),Torso
        Welds.LegW.Left.C1,Welds.LegW.Left.Part0 = CFrame.new(.5,2,0),Torso
        Welds.LegW.Right.C1,Welds.LegW.Right.Part0 = CFrame.new(-.5,2,0),Torso 
        Welds.HeadW.Middle.C1,Welds.HeadW.Middle.Part0 = CFrame.new(0,-1.5,0),Torso
        local _Arm = function(side,tf)
            local Arm = nil
            local Weld = nil
            local RWeld = nil
            for _,S in pairs(Sides) do
                if side:lower() == S:lower() then
                    for _,A in pairs(Arms) do
                        if A.Name:lower():find(side:lower()) then
                            Arm = A
                            Weld = Welds.ArmW[S]
                            RWeld = RWelds.ArmW[S]
                        end
                    end
                end
            end
            if Arm and Weld and RWeld then
                if tf then
                    Weld.Part1 = Arm
                    RWeld.Part1 = nil
                elseif not tf then
                    Weld.Part1 = nil
                    RWeld.Part1 = Arm
                else
                    print("Error")
                end
            end
        end
        
        local _Leg = function(side,tf)
            local Leg = nil
            local Weld = nil
            local RWeld = nil
            for _,S in pairs(Sides) do
                if side:lower() == S:lower() then
                    for _,A in pairs(Legs) do
                        if A.Name:lower():find(side:lower()) then
                            Leg = A
                            Weld = Welds.LegW[S]
                            RWeld = RWelds.LegW[S]
                        end
                    end
                end
            end
            if Leg and Weld and RWeld then
                if tf then
                    Weld.Part1 = Leg
                    RWeld.Part1 = nil
                elseif not tf then
                    Weld.Part1 = nil
                    RWeld.Part1 = Leg
                else
                    print("Error")
                end
            end
        end
        
        local _Head = function(tf)
            local Head = nil
            local Weld = nil
            local RWeld = nil
            Head = Character["Head"]
            Weld = Welds.HeadW.Middle
            RWeld = RWelds.HeadW.Middle
            if Head and Weld and RWeld then
                if tf then
                    Weld.Part1 = Head
                    RWeld.Part1 = nil
                elseif not tf then
                    Weld.Part1 = nil
                    RWeld.Part1 = Head
                else
                    print("Error")
                end
            end
        end
        
        local function Round(Number)
            return math.floor(Number+.5)
        end
        
        --[[Hover Creation]]--
        local Board = CreatePart("Part",MainModel,1.5,0.25,4,ScriptData.Colors.Base,"SmoothPlastic")
        local BoardEdge = CreatePart("Part",MainModel,1.505,0.2,3.995,ScriptData.Colors.Trim,"Neon")
        local BEW = CreateWeld("Weld",BoardEdge,BoardEdge,Board,CFrame.new(0,0,0),CFrame.Angles(0,0,0))
        
        if game.Players.LocalPlayer.Character:FindFirstChild("MeshPartAccessory") then
            game.Players.LocalPlayer.Character:FindFirstChild("MeshPartAccessory").Handle.AccessoryWeld:Destroy()
            align(game.Players.LocalPlayer.Character:FindFirstChild("MeshPartAccessory").Handle, Board)
        end
        
        local PointA = CreatePart("Part",MainModel,0.2,0.2,0.2,ScriptData.Colors.Base,"SmoothPlastic")
        PointA.Transparency = 1
        PointA.CanCollide = false
        local PW = CreateWeld("Weld",PointA,PointA,Board,CFrame.new(0,-0.1,3),CFrame.Angles(math.rad(90),0,0))
        local PointB = CreatePart("Part",MainModel,0.2,0.2,0.2,ScriptData.Colors.Base,"SmoothPlastic")
        PointB.Transparency = 1
        PointB.CanCollide = false
        local PWB = CreateWeld("Weld",PointB,PointB,Board,CFrame.new(0,-0.1,-3),CFrame.Angles(math.rad(90),0,0))
        --
        --
        local BodyPos = Instance.new("BodyPosition",Board)
        BodyPos.maxForce = Vector3.new(1e5,1e5,1e5)
        local Tilt = Instance.new("BodyGyro",Board)
        Tilt.maxTorque = Vector3.new(1,1,1)/0
        local Push = Instance.new("BodyForce",Board)
        Push.force = Vector3.new()
        --[[Player Welding]]--
        
        if Torso and Human and Board then
            Human.PlatformStand = true
            Torso.CFrame = Torso.CFrame*CFrame.new(0,2,0)
            local TtBW = CreateWeld("Weld",Torso,Torso,Board,CFrame.new(0,3,0),CFrame.Angles(0,math.rad(90),0))
        end
        
        local function HoverPiece(CF,CFA)
            local Center = CreatePart("Part",MainModel,0.4,0.2,0.4,"Black","SmoothPlastic")
            Center:ClearAllChildren()
            Instance.new("CylinderMesh",Center).Scale = Vector3.new(1,1,1)
            local Emitter = Instance.new("ParticleEmitter", Center)
            Emitter.Enabled = true
            Emitter.Name = "Realism"
            Emitter.Acceleration = Vector3.new(0.5,0.5,0.5)
            Emitter.Transparency = NumberSequence.new(0.5,0.8)
            Emitter.Rate = NumberRange.new(1)
            local PW1 = CreateWeld("Weld",Center,Center,Board,CF,CFA)
            local Spin = Center:Clone()
            Spin.Parent = MainModel
            Spin.Size = Vector3.new(1,1,1)
            Spin.Transparency = 1
            local SPW = CreateWeld("Weld",Spin,Spin,Center,CFrame.new(0,0,0),CFrame.Angles(0,0,0))
            table.insert(ScriptData.Rotors, SPW)
            for i=0,360,45 do
                local Part = CreatePart("Part",MainModel,1,0.25,0.25,ScriptData.Colors.Base,"SmoothPlastic")
                local PW2 = CreateWeld("Weld",Part,Part,Center,CFrame.Angles(0,math.rad(i),0)*CFrame.new(0,0,1.08),CFrame.Angles(0,0,0))
                local Edge = CreatePart("Part",MainModel,1,0.2,0.2,ScriptData.Colors.Trim,"Neon")
                local EW = CreateWeld("Weld",Edge,Edge,Part,CFrame.new(0,0,0.05),CFrame.Angles(0,0,0))
            end
            for i=0,360,45 do
                local Rotor = CreatePart("Part",MainModel,2,0.2,0.25,"White","SmoothPlastic")
                Rotor:findFirstChild("Mesh").Scale = Vector3.new(1,0.125,1)
                local RW = CreateWeld("Weld",Rotor,Rotor,Spin,CFrame.Angles(0,math.rad(i),0)*CFrame.new(0,0,0.2),CFrame.Angles(math.rad(-20),0,0))
            end
        end
        
        HoverPiece(CFrame.new(0,0,-2.9),CFrame.Angles(0,0,0))
        HoverPiece(CFrame.new(0,0,2.9),CFrame.Angles(0,0,0))
        
        Services.RunService.Stepped:connect(function()
            pcall(function()
                for _,v in pairs(ScriptData.Rotors) do
                    if v and v.Parent then
                        v.C0 = v.C0 * CFrame.Angles(0,math.rad(10),0)
                    end
                end
            end)
            a,b = ypcall(function()
                if Board and Torso and BodyPos and Tilt and PointA and PointB then
                    local Rays = Ray.new(PointA.CFrame.p,PointA.CFrame.lookVector*(ScriptData.Lift + 4 + (ScriptData.Keys.Space==true and 5 or 0)))
                    local Object,Pos = Services.Workspace:findPartOnRay(Rays,Character)
                    local Rays2 = Ray.new(PointB.CFrame.p,PointB.CFrame.lookVector*(ScriptData.Lift + 4 + (ScriptData.Keys.Space==true and 5 or 0)))
                    local Object2,Pos2 = Services.Workspace:findPartOnRay(Rays2,Character)
                    local Left,Right,Front,Back,Space,Accept = 0,0,0,0,0,0
                    local Face = Board.CFrame.lookVector
        
                    if ScriptData.Keys.A==true then
                        Left = 1
                    elseif ScriptData.Keys.D==true then
                        Right = -1
                    end
                    if ScriptData.Keys.Space==true then
                        Space = 5
                    else
                        Space = 0
                    end
                    if ScriptData.Keys.S==true then
                        Back,ScriptData.Last = -2,-1
                        ScriptData.Acceleration = ScriptData.Acceleration >=8 and 8 or ScriptData.Acceleration + 0.1
                    elseif ScriptData.Keys.W==true then
                        Front,ScriptData.Last = 2,1
                        ScriptData.Acceleration = ScriptData.Acceleration >=8 and 8 or ScriptData.Acceleration + 0.1
                    elseif ScriptData.Acceleration ~= 0 and not ScriptData.Keys.S==true and not ScriptData.Keys.W==true then
                        ScriptData.Acceleration = ScriptData.Acceleration>0 and ScriptData.Acceleration - 0.1 or 0
                        Accept = ScriptData.Last
                    end
        
                    ScriptData.TurnAngle = ScriptData.TurnAngle - math.pi*(Left+Right)/32
                    Tilt.cframe = CFrame.new()*CFrame.Angles(0,-ScriptData.TurnAngle,((Left+Right)/2))*CFrame.Angles(-((Front+Back)/5),0,0)
        
                    if Object and Object:IsA("BasePart") or Object2 and Object2:IsA("BasePart") then
                        local A = 0
                        local B = 0
        
                        if Object then
                            A = Object.CFrame.Y + Object.Size.Y/2
                        end
                        if Object2 then
                            B = Object2.CFrame.Y + Object2.Size.Y/2
                        end
                        BodyPos.maxForce = Vector3.new(1e5,1e5,1e5)
                        BodyPos.position = Vector3.new(Board.CFrame.X,(((A+B)/2)+ScriptData.Lift)+Space,Board.CFrame.Z) + Vector3.new(Face.X,0,Face.Z)*ScriptData.Acceleration*(Front+Back+Accept)
                    else
                        BodyPos.maxForce = Vector3.new(1e5,0,1e5)
                        BodyPos.position = Vector3.new(Board.CFrame.X,Board.CFrame.Y,Board.CFrame.Z) + Vector3.new(Face.X,Space,Face.Z)*ScriptData.Acceleration*(Front+Back+Accept)
                    end
                end
            end)
            if not a then
                print("E: "..b)
            end
        end)
        
        Thread(function()
            while true do
                for i = 0,10,0.1 do
                    ScriptData.Lift = ScriptData.Lift + (math.sin(math.pi*2/10*i)*0.1)
                    wait(0.02)
                end 
            end
        end)
        
        Mouse.KeyDown:connect(function(Key)
            if Key == "w" then
                ScriptData.Keys.W = true
            end
            if Key == "a" then
                ScriptData.Keys.A = true
            end
            if Key == "s" then
                ScriptData.Keys.S = true
            end
            if Key == "d" then
                ScriptData.Keys.D = true
            end
            if Key:byte() == 32 then
                ScriptData.Keys.Space = true
            end
        end)
        
        Mouse.KeyUp:connect(function(Key)
            if Key == "w" then
                ScriptData.Keys.W = false
            end
            if Key == "a" then
                ScriptData.Keys.A = false
            end
            if Key == "s" then
                ScriptData.Keys.S = false
            end
            if Key == "d" then
                ScriptData.Keys.D = false
            end
            if Key:byte() == 32 then
                ScriptData.Keys.Space = false
            end
        end)
        
        _Arm("Left", true)
        _Arm("Right", true)
        _Leg("Left", true)
        _Leg("Right", true)
        _Head(true)
        
        Services.RunService.RenderStepped:connect(function()
            if Transition then
                if Breathing >= 1 then
                    Transition = false
                end
                Breathing = Breathing + 1/100
            else
                if Breathing <= 0 then
                    Transition = true
                end
                Breathing = Breathing - 1/100
            end
        
            if Stance == "None" then
                LA.C0 = LAD * CFrame.Angles(math.rad(10*Breathing),0,math.rad(-20))
                RA.C0 = RAD * CFrame.Angles(math.rad(-10*Breathing),0,math.rad(20))
                LL.C0 = CFrame.new() * CFrame.Angles(0,0,math.rad(-5))
                LR.C0 = CFrame.new() * CFrame.Angles(0,0,math.rad(5))
            end
        end)
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
end)




HatScripts:Button("Carnage", "funny button go brr", function()
	if game.Players.LocalPlayer.Character:FindFirstChild("Raw") then
		local script = game:GetObjects("rbxassetid://6813784782")[1]

workspace.FallenPartsDestroyHeight = -1000

print("Converted to FE by demeshed aka forEach#6969 \n xd big gamer")

local invpart = Instance.new("Part", game:GetService("Players").LocalPlayer.Character)
invpart.Anchored = true
invpart.Position = Vector3.new(0, -50, 0)
invpart.CanCollide = false
local InvAtt = Instance.new("Attachment", invpart)

local hat = game:GetService("Players").LocalPlayer.Character["Sniper"]
hat.Handle.AccessoryWeld:Destroy()

local function weld(part0, part1)
	local attachment0 = Instance.new("Attachment", part0)
	if part0 == hat.Handle then
		attachment0.Rotation = Vector3.new(0, 0, 0) --Edit if u want custom rotationing
		attachment0.Position = Vector3.new(0, 0, 0) --Edit if u want custom positioning
	end
	local attachment1 = Instance.new("Attachment", part1)
	local weldpos = Instance.new("AlignPosition", part0)
	weldpos.Attachment0 = attachment0
	weldpos.Attachment1 = attachment1
	weldpos.RigidityEnabled = false
	weldpos.ReactionForceEnabled = false
	weldpos.ApplyAtCenterOfMass = false
	weldpos.MaxForce = 10000
	weldpos.MaxVelocity = 10000
	weldpos.Responsiveness = 10000
	local weldrot = Instance.new("AlignOrientation", part0)
	weldrot.Attachment0 = attachment0
	weldrot.Attachment1 = attachment1
	weldrot.ReactionTorqueEnabled = true
	weldrot.PrimaryAxisOnly = false
	weldrot.MaxTorque = 10000
	weldrot.MaxAngularVelocity = 10000
	weldrot.Responsiveness = 10000
end

local function invweld(part0)
	local attachment0 = Instance.new("Attachment", part0)
	local attachment1 = InvAtt
	local weldpos = Instance.new("AlignPosition", part0)
	weldpos.Enabled = false
	weldpos.Name = "InvPos"
	weldpos.Attachment0 = attachment0
	weldpos.Attachment1 = attachment1
	weldpos.RigidityEnabled = false
	weldpos.ReactionForceEnabled = false
	weldpos.ApplyAtCenterOfMass = false
	weldpos.MaxForce = 10000
	weldpos.MaxVelocity = 10000
	weldpos.Responsiveness = 10000
	local weldrot = Instance.new("AlignOrientation", part0)
	weldrot.Enabled = false
	weldrot.Name = "InvRot"
	weldrot.Attachment0 = attachment0
	weldrot.Attachment1 = attachment1
	weldrot.ReactionTorqueEnabled = true
	weldrot.PrimaryAxisOnly = false
	weldrot.MaxTorque = 10000
	weldrot.MaxAngularVelocity = 10000
	weldrot.Responsiveness = 10000
end

weld(hat.Handle, script.Gun.Handle)
invweld(hat.Handle)

local w = workspace[game.Players.LocalPlayer.Name].Sniper.Handle.Attachment

w.Position = Vector3.new(-1, -0.5, 0)
w.Rotation = Vector3.new(100, 270, 100)


	local AHB = Instance.new("BindableEvent")
	
	local FPS = 30
	
	local TimeFrame = 0
	
	local LastFrame = tick()
	local Frame = 1/FPS
	
	game:service'RunService'.Heartbeat:connect(function(s,p)
		TimeFrame = TimeFrame + s
		if(TimeFrame >= Frame)then
			for i = 1,math.floor(TimeFrame/Frame) do
				AHB:Fire()
			end
			LastFrame=tick()
			TimeFrame=TimeFrame-Frame*math.floor(TimeFrame/Frame)
		end
	end)


	function swait(dur)
		if(dur == 0 or typeof(dur) ~= 'number')then
			AHB.Event:wait()
		else
			for i = 1, dur*FPS do
				AHB.Event:wait()
			end
		end
	end
	
-- converter by Drahazar

--created by helkern
--some things might be taken from other scripts

if game:GetService("RunService"):IsStudio() then
wait(1)
else
wait(1/60)	
end

Player = game:GetService("Players").LocalPlayer
PlayerGui = Player.PlayerGui
Cam = workspace.CurrentCamera
Backpack = Player.Backpack
Character = game:GetService("Players").LocalPlayer.Character["Raw"]
Humanoid = Character.Humanoid
Mouse = Player:GetMouse()
RootPart = Character["HumanoidRootPart"]
Torso = Character["Torso"]
Head = Character["Head"]
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart["RootJoint"]
Neck = Torso["Neck"]
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]
local sick = Instance.new("Sound",Torso)

IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor


Animation_Speed = 3
Frame_Speed = 1 / 60 -- (1 / 30) OR (1 / 60)
local Speed = 45
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local DAMAGEMULTIPLIER = 1
local ANIM = "Idle"
local ATTACK = false
local EQUIPPED = false
local HOLD = false
local COMBO = 1
local Rooted = false
local SINE = 0
local KEYHOLD = false
local CHANGE = 2 / Animation_Speed
local WALKINGANIM = false
local VALUE1 = false
local VALUE2 = false
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
--ROBLOXIDLEANIMATION.Parent = Humanoid
local WEAPONGUI = IT("ScreenGui", PlayerGui)
WEAPONGUI.Name = "Weapon GUI"
local Effects = IT("Folder", Character.Parent)
Effects.Name = "Effects"
local ANIMATOR = Humanoid.Animator
local ANIMATE = Character.Animate
ANIMATOR:Destroy()
local UNANCHOR = true
local HITPLAYERSOUNDS = {--[["199149137", "199149186", "199149221", "199149235", "199149269", "199149297"--]]"263032172", "263032182", "263032200", "263032221", "263032252", "263033191"}

ArtificialHB = Instance.new("BindableEvent")
ArtificialHB.Name = "ArtificialHB"

frame = Frame_Speed
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
ArtificialHB:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				ArtificialHB:Fire()
			end
		lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)


function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function PositiveAngle(NUMBER)
	if NUMBER >= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function NegativeAngle(NUMBER)
	if NUMBER <= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, NUMBER do
			ArtificialHB.Event:wait()
		end
	end
end

function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
	local NEWMESH = IT(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or VT(0, 0, 0)
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end

function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end

	local function weldBetween(a, b)
	    local weldd = Instance.new("ManualWeld")
	    weldd.Part0 = a
	    weldd.Part1 = b
	    weldd.C0 = CFrame.new()
	    weldd.C1 = b.CFrame:inverse() * a.CFrame
	    weldd.Parent = a
	    return weldd
	end


function Clerp(a, b, t)
    return a:lerp(b,t)
end


function CreateFrame(PARENT, TRANSPARENCY, BORDERSIZEPIXEL, POSITION, SIZE, COLOR, BORDERCOLOR, NAME)
	local frame = IT("Frame")
	frame.BackgroundTransparency = TRANSPARENCY
	frame.BorderSizePixel = BORDERSIZEPIXEL
	frame.Position = POSITION
	frame.Size = SIZE
	frame.BackgroundColor3 = COLOR
	frame.BorderColor3 = BORDERCOLOR
	frame.Name = NAME
	frame.Parent = PARENT
	return frame
end

function CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)
	local label = IT("TextLabel")
	label.BackgroundTransparency = 1
	label.Size = UD2(1, 0, 1, 0)
	label.Position = UD2(0, 0, 0, 0)
	label.TextColor3 = TEXTCOLOR
	label.TextStrokeTransparency = STROKETRANSPARENCY
	label.TextTransparency = TRANSPARENCY
	label.FontSize = TEXTFONTSIZE
	label.Font = TEXTFONT
	label.BorderSizePixel = BORDERSIZEPIXEL
	label.TextScaled = false
	label.Text = TEXT
	label.Name = NAME
	label.Parent = PARENT
	return label
end

function NoOutlines(PART)
	PART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10
end

function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
	local NEWWELD = IT(TYPE)
	NEWWELD.Part0 = PART0
	NEWWELD.Part1 = PART1
	NEWWELD.C0 = C0
	NEWWELD.C1 = C1
	NEWWELD.Parent = PARENT
	return NEWWELD
end

local S = IT("Sound")
function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
	local NEWSOUND = nil
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.EmitterSize = 5*VOLUME
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			repeat wait(1) until NEWSOUND.Playing == false
			NEWSOUND:remove()
		end
	end))
	return NEWSOUND
end

function CFrameFromTopBack(at, top, back)
	local right = top:Cross(back)
	return CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
end

--WACKYEFFECT({EffectType = "", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
function WACKYEFFECT(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" then
			MSH = IT("BlockMesh",EFFECT)
			MSH.Scale = VT(SIZE.X,SIZE.X,SIZE.X)
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
			end
			local GROWTH = SIZE - ENDSIZE
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			for LOOP = 1, TIME+1 do
				Swait()
				MSH.Scale = MSH.Scale - GROWTH/TIME
				if TYPE == "Wave" then
					MSH.Offset = VT(0,0,-MSH.Scale.X/8)
				end
				EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
				else
					EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
				end
				if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation
					EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
					EFFECT.Orientation = ORI
				end
			end
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until SOUND.Playing == false
				EFFECT:remove()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until SOUND.Playing == false
				EFFECT:remove()
			end
		end
	end))
end

function WACKYEFFECT2(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	local ISCHAOS = (Table.Chaos or false)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC"a", "Effect", VT(1,1,1), true)
		EFFECT.Color = COLOR
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" or TYPE == "Box" then
			MSH = IT("BlockMesh",EFFECT)
			MSH.Scale = SIZE
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
			end
			local GROWTH = SIZE - ENDSIZE
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			for LOOP = 1, TIME+1 do
				Swait()
				MSH.Scale = MSH.Scale - GROWTH/TIME
				if ISCHAOS == true then
				EFFECT.Color = BrickColor.Random().Color
				end
				if TYPE == "Wave" then
					MSH.Offset = VT(0,0,-MSH.Scale.X/8)
				end
				EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
				
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
				else
					EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
				end
				if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation
					EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
					EFFECT.Orientation = ORI
				end
			end
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		end
	end))
end

function WACKYEFFECT2(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	local USEBOOMERANGMATH = (Table.UseBoomerangMath or false)
	local BOOMERANG = (Table.Boomerang or 0)
	local SIZEBOOMERANG = (Table.SizeBoomerang or 0)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" or TYPE == "Box" then
			MSH = IT("BlockMesh",EFFECT)
			MSH.Scale = SIZE
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "168892432", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local BOOMR1 = 1+BOOMERANG/50
			local BOOMR2 = 1+SIZEBOOMERANG/50
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				if USEBOOMERANGMATH == true then
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)*BOOMR1
				else
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)
				end
			end
			local GROWTH = nil
			if USEBOOMERANGMATH == true then
				GROWTH = (SIZE - ENDSIZE)*(BOOMR2+1)
			else
				GROWTH = (SIZE - ENDSIZE)
			end
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			if USEBOOMERANGMATH == true then
				for LOOP = 1, TIME+1 do
					Swait()
					MSH.Scale = MSH.Scale - (VT((GROWTH.X)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Y)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Z)*((1 - (LOOP/TIME)*BOOMR2)))*BOOMR2)/TIME
					if TYPE == "Wave" then
						MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-(MOVESPEED)*((1 - (LOOP/TIME)*BOOMR1)))
						EFFECT.Orientation = ORI
					end
				end
			else
				for LOOP = 1, TIME+1 do
					Swait()
					MSH.Scale = MSH.Scale - GROWTH/TIME
					if TYPE == "Wave" then
						MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
						EFFECT.Orientation = ORI
					end
				end
			end
			EFFECT.Transparency = 1
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		end
	end))
end

function MakeForm(PART,TYPE)
	if TYPE == "Cyl" then
		local MSH = IT("CylinderMesh",PART)
	elseif TYPE == "Ball" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Sphere"
	elseif TYPE == "Wedge" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Wedge"
	end
end

Debris = game:GetService("Debris")

function CastProperRay(StartPos, EndPos, Distance, Ignore)
	local DIRECTION = CF(StartPos,EndPos).lookVector
	return Raycast(StartPos, DIRECTION, Distance, Ignore)
end

function Gyro(PARENT)
	local GYRO = IT("BodyGyro",PARENT)
	GYRO.D = 750
	GYRO.P = 20000
	GYRO.MaxTorque = VT(0,40000000,0)
	return GYRO
end

function POSITION(PARENT)
	local grav = Instance.new("BodyPosition",PARENT)
	grav.D = 15
	grav.P = 20000
	grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
	return grav
end

function FacialShadow()
	local SHADOWS = {}
	for i = 1, 16 do
		local FACE = CreatePart(3, Effects, "Fabric", 0, 0+(i-1)/16.2, "Dark stone grey", "FaceGradient", VT(1.01,0.65,1.01),false)
		FACE.Color = C3(0,0,0)
		Head:FindFirstChildOfClass("SpecialMesh"):Clone().Parent = FACE
		CreateWeldOrSnapOrMotor("Weld", Head, Head, FACE, CF(0,0.35-(i-1)/25,0), CF(0, 0, 0))
		table.insert(SHADOWS,FACE)
	end
	local UNDO = function()
		for i = 1, #SHADOWS do
			SHADOWS[i]:remove()
		end
	end
	return UNDO
end

function GetRoot(MODEL,ROOT)
	if ROOT == true then
		return MODEL:FindFirstChild("HumanoidRootPart") or MODEL:FindFirstChild("Torso") or MODEL:FindFirstChild("UpperTorso")
	else
		return MODEL:FindFirstChild("Torso") or MODEL:FindFirstChild("UpperTorso")
	end
end

function CreateFlyingDebree(FLOOR,POSITION,AMOUNT,BLOCKSIZE,SWAIT,STRENGTH)
	if FLOOR ~= nil then
		for i = 1, AMOUNT do
			local DEBREE = CreatePart(3, Effects, "Neon", FLOOR.Reflectance, FLOOR.Transparency, "Peal", "Debree", BLOCKSIZE, false)
			DEBREE.Material = FLOOR.Material
			DEBREE.Color = FLOOR.Color
			DEBREE.CFrame = POSITION * ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)))
			DEBREE.Velocity = VT(MRANDOM(-STRENGTH,STRENGTH),MRANDOM(-STRENGTH,STRENGTH),MRANDOM(-STRENGTH,STRENGTH))
			coroutine.resume(coroutine.create(function()
				Swait(15)
				DEBREE.Parent = workspace
				DEBREE.CanCollide = true
				Debris:AddItem(DEBREE,SWAIT)
			end))
		end
	end
end

function SHAKECAM(POSITION,RANGE,INTENSITY,TIME)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						local CAMSHAKER = script.CamShake:Clone()
						CAMSHAKER.Shake.Value = INTENSITY
						CAMSHAKER.Timer.Value = TIME
						CAMSHAKER.Parent = CHILD
						CAMSHAKER.Disabled = false
					end
				end
			end
		end
	end
end

--Lightning({Material = "Neon", FadeIn = false, Color = C3(1,1,1), Start = Torso.Position, End = Mouse.Hit.p, SegmentL = 2, Thickness = 0.1, DoesFade = false, Ignore = Character, MaxDist = 400, Branches = false, FadeTime = 15, Thicken = false})
function Lightning(Table)
	local Color = Table.Color or C3(1,1,1)
	local StartPos = Table.Start or Torso.Position
	local EndPos = Table.End or Mouse.Hit.p
	local SegmentLength = Table.SegmentL or 2
	local Thickness = Table.Thickness or 0.1
	local Dissapear = Table.DoesFade or false
	local Parent = Table.Ignore or Character
	local MaxDist = Table.MaxDist or 400
	local Branches = Table.Branches or false
	local Thicken = Table.Thicken or false
	local FadeTime = Table.FadeTime or 15
	local FadeIn = Table.FadeIn or false
	local Material = Table.Material or "Neon"
	local HIT,HITPOS = CastProperRay(StartPos, EndPos, MaxDist, Parent)
	local DISTANCE = math.ceil((StartPos - HITPOS).Magnitude/((SegmentLength/SegmentLength)/1.5))
	local LIGHTNINGMODEL = IT("Model",Effects)
	LIGHTNINGMODEL.Name = "Lightning"
	local LastBolt = nil
	for E = 1, DISTANCE do
		local ExtraSize = 0
		if Thicken == true then
			ExtraSize = (DISTANCE-E)/15
		end
		local TRANSPARENCY = 0
		if FadeIn == true then
			TRANSPARENCY = 1-(E/(DISTANCE/1.5))
			if TRANSPARENCY < 0 then
				TRANSPARENCY = 0
			end
		end
		local PART = CreatePart(3, LIGHTNINGMODEL, Material, 0, TRANSPARENCY, BRICKC("Pearl"), "LightningPart"..E, VT(Thickness+ExtraSize,SegmentLength,Thickness+ExtraSize))
		PART.Color = Color
		--MakeForm(PART,"Cyl")
		if LastBolt == nil then
			PART.CFrame = CF(StartPos,HITPOS)*ANGLES(RAD(90),RAD(0),RAD(0))*CF(0,-PART.Size.Y/2,0)
		else
			PART.CFrame = CF(LastBolt.CFrame*CF(0,-LastBolt.Size.Y/2,0).p,CF(HITPOS)*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))*CF(0,0,DISTANCE-E).p)*ANGLES(RAD(90),RAD(0),RAD(0))*CF(0,-PART.Size.Y/2,0)
		end
		LastBolt = PART
		if Branches == true and E < (DISTANCE-5) then
			local CHOICE = MRANDOM(1,7+((DISTANCE-E)*2))
			if CHOICE == 1 then
				local LASTBRANCH = nil
				for i = 1, MRANDOM(2,5) do
					local ExtraSize2 = 0
					if Thicken == true then
						ExtraSize = ((DISTANCE-E)/25)/i
					end
					local PART = CreatePart(3, LIGHTNINGMODEL, Material, 0, TRANSPARENCY, BRICKC("Pearl"), "Branch"..E.."-"..i, VT(Thickness+ExtraSize2,SegmentLength,Thickness+ExtraSize2))
					PART.Color = Color
					MakeForm(PART,"Cyl")
					if LASTBRANCH == nil then
						PART.CFrame = CF(LastBolt.CFrame*CF(0,-LastBolt.Size.Y/2,0).p,LastBolt.CFrame*CF(0,-LastBolt.Size.Y/2,0)*ANGLES(RAD(0),RAD(0),RAD(MRANDOM(0,360)))*CF(0,Thickness*7,0)*CF(0,0,-1).p)*ANGLES(RAD(90),RAD(0),RAD(0))*CF(0,-PART.Size.Y/2,0)
					else
						PART.CFrame = CF(LASTBRANCH.CFrame*CF(0,-LASTBRANCH.Size.Y/2,0).p,LASTBRANCH.CFrame*CF(0,-LASTBRANCH.Size.Y/2,0)*ANGLES(RAD(0),RAD(0),RAD(MRANDOM(0,360)))*CF(0,Thickness*3,0)*CF(0,0,-1).p)*ANGLES(RAD(90),RAD(0),RAD(0))*CF(0,-PART.Size.Y/2,0)
					end
					LASTBRANCH = PART
				end
			end
		end
	end
	if Dissapear == true then
		coroutine.resume(coroutine.create(function()
			for i = 1, FadeTime do
				Swait()
				for _, c in pairs(LIGHTNINGMODEL:GetChildren()) do
					if c.ClassName == "Part" then
						c.Transparency = c.Transparency + (i/FadeTime)/10
					end
				end
			end
			LIGHTNINGMODEL:remove()
		end))
	elseif Dissapear == false then
		Debris:AddItem(LIGHTNINGMODEL,0.1)
	end
	return {Hit = HIT,Pos = HITPOS,End = LastBolt.CFrame*CF(0,0,-LastBolt.Size.Z).p,LastBolt = LastBolt,Model = LIGHTNINGMODEL}
end


--weap
local SONG = 590141342

local shotgunact = false
local gunact = true

for _, c in pairs(Character:GetChildren()) do
	if c and c.Parent then
		if c.ClassName == "Accessory" then
			local ACCESSORY = c
			local HANDLE = c.Handle
			HANDLE.Parent = Character
			if c then
				if HANDLE:FindFirstChild("HatAttachment") or HANDLE:FindFirstChild("HairAttachment") then
					local WLD = weldBetween(Head,HANDLE)
				elseif HANDLE:FindFirstChild("FaceFrontAttachment") then
					HANDLE:remove()
				else
					local WLD = weldBetween(Torso,HANDLE)
				end
			end
			ACCESSORY:remove()
		end
	end
end

local gun = script.Gun
for i,v in pairs(gun:GetChildren()) do
	v.Anchored = false
	v.Transparency = 1
end
local hole = gun.Hole
local gunw = CreateWeldOrSnapOrMotor("Weld",LeftArm,gun.Handle,LeftArm,CF(0,0,.5) * ANGLES(RAD(90),0,0),CF(0,0,0))
gun.Parent = Character

local shotgun = script.BShot
for i,v in pairs(shotgun:GetChildren()) do
	v.Anchored = false
	v.Transparency = 1
end
local sgw = CreateWeldOrSnapOrMotor("Weld",RightArm,shotgun.Main,RightArm,CF(0,.4,0),CF(0,0,0))
shotgun.Parent = nil

local fshot = script.FShot
for i,v in pairs(fshot:GetChildren()) do
	v.Anchored = false
	v.Transparency = 1
end
local fsw = CreateWeldOrSnapOrMotor("Weld",Torso,fshot.Main,Torso,CF(0,0,0),CF(0,0,0))
fshot.Parent = Character

local mascc = script.Mask
for i,v in pairs(mascc:GetChildren()) do
	v.Anchored = false
	v.Transparency = 1
end
local mw = CreateWeldOrSnapOrMotor("Weld",Head,mascc.Middle,Head,CF(0,0,0),CF(0,0,0))
mascc.Parent = Character

local fgun = script.FakeGun
for i,v in pairs(fgun:GetChildren()) do
	v.Anchored = false
	v.Transparency = 1
end
local fgunw = CreateWeldOrSnapOrMotor("Weld",Torso,fgun.Main,Torso,CF(0,0,0),CF(0,0,0))
fgun.Parent = nil

local hole2 = shotgun.Hole







--dmg

function poop(MODEL)
	MODEL:BreakJoints()
	for index, CHILD in pairs(MODEL:GetChildren()) do
		if CHILD:IsA("BasePart") and CHILD.Name ~= "HumanoidRootPart" then
			if CHILD.Name == "Head" then
					WACKYEFFECT2({Time = 120, EffectType = "Box", Size = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z), Size2 = (VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)), Transparency = CHILD.Transparency, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(MRANDOM(-30,30)/10,MRANDOM(-30,30)/10,MRANDOM(-30,30)/10), RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, SizeBoomerang = 0, Boomerang = 35})
				elseif CHILD.Name ~= "HumanoidRootPart" then
					WACKYEFFECT2({Time = 120, EffectType = "Box", Size = CHILD.Size, Size2 = CHILD.Size, Transparency = CHILD.Transparency, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(MRANDOM(-30,30)/10,MRANDOM(-30,30)/10,MRANDOM(-30,30)/10), RotationY = 0, RotationZ = 0 ,Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UseBoomerangMath = true, SizeBoomerang = 0, Boomerang = 35})
				end
				if CHILD.Name == "Torso" or CHILD.Name == "UpperTorso" then
					WACKYEFFECT2({Time = 60, EffectType = "Sphere", Size = VT(0.2,0.2,0.2)*CHILD.Size.Magnitude, Size2 = VT(6,6,6)*CHILD.Size.Magnitude, Transparency = 0.6, Transparency2 = 1, CFrame = CF(CHILD.Position), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = 301928691, SoundPitch = 2, SoundVolume = 10, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 50})
				end
			CHILD:remove()
		end
	end
	Debris:AddItem(MODEL,6)
end

function ApplyDamage(Humanoid,Damage)
	Damage = Damage * DAMAGEMULTIPLIER
	if Humanoid.Health < 2000 then
		if Humanoid.Health - Damage > 0 then
			Humanoid.Health = Humanoid.Health - Damage
		else
			poop(Humanoid.Parent)
		end
	else
		poop(Humanoid.Parent)
	end
end

function ApplyAeO(POSITION,RANGE,MINDMG,MAXDMG,FLING,INSTAKILL)
	for index, CHILD in pairs(workspace:GetDescendants()) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if INSTAKILL == true then
							poop(CHILD)
						else
							local DMG = MRANDOM(MINDMG,MAXDMG)
							ApplyDamage(HUM,DMG)
						end
						if FLING > 0 then
							for _, c in pairs(CHILD:GetChildren()) do
								if c:IsA("BasePart") then
									local bv = Instance.new("BodyVelocity") 
									bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
									bv.velocity = CF(POSITION,TORSO.Position).lookVector*FLING
									bv.Parent = c
									Debris:AddItem(bv,0.05)
								end
							end
						end
					end
				end
			end
		end
	end
end

--attacks

function cs()
if SONG == 590141342 then
SONG = 212377035
elseif SONG == 212377035 then
SONG = 589973177
elseif SONG == 589973177 then
SONG = 1833183591
elseif SONG == 1833183591 then
SONG = 2982966292
elseif SONG == 2982966292 then
SONG = 	616388964
elseif SONG == 616388964 then
SONG = 	1342763538
elseif SONG == 1342763538 then
SONG = 886085413
elseif SONG == 886085413 then
SONG = 3704092097
elseif SONG == 3704092097 then
SONG = 1589396874
elseif SONG == 1589396874 then
SONG = 168159280
elseif SONG == 168159280 then
SONG = 296659202
elseif SONG == 296659202 then
SONG = 608671887
elseif SONG == 608671887 then
SONG = 270719635
elseif SONG == 270719635 then
SONG = 3206925146
elseif SONG == 3206925146 then
SONG = 383141805
elseif SONG == 383141805 then
SONG = 590141342			
end
end

function swshotg()
ATTACK = true
if shotgunact == false then
for i = 0,20 do
local Alpha = .1
Swait()
RootJoint.C0 = RootJoint.C0:lerp(CF(0,1.2 + 0.5 * COS(SINE/35),0.1)*ANGLES(RAD(-79.3 + 7 * SIN(SINE/35)),RAD(0),RAD(-180)),Alpha)
if gunact == true then LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.6,0.1)*ANGLES(RAD(0.2),RAD(-84.8),RAD(-167.4)),Alpha);else LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.6,0.1)*ANGLES(RAD(-12.2),RAD(-73.3 ),RAD(-4.7)),.1);end
RightShoulder.C0 = RightShoulder.C0:lerp(CF(0.5,0.8,0.6)*ANGLES(RAD(57.3),RAD(56.6),RAD(-61.7)),Alpha)
Neck.C0 =Neck.C0:lerp(CF(0,1,0.1)*ANGLES(RAD(-104.3- 4 * SIN(SINE/35)),RAD(5.3),RAD(124.5)),Alpha)
LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1,-0.1)*ANGLES(RAD(-10.2),RAD(-86.3),RAD(0)),Alpha)
RightHip.C0 = RightHip.C0:lerp(CF(1,0,-0.6)*ANGLES(RAD(-7.7),RAD(84.7),RAD(0)),Alpha)
end	
shotgunact = true
else
for i = 0,20 do
local Alpha = .1
Swait()
RootJoint.C0 = RootJoint.C0:lerp(CF(0,1.2 + 0.5 * COS(SINE/35),0.1)*ANGLES(RAD(-79.3 + 7 * SIN(SINE/35)),RAD(0),RAD(-180)),Alpha)
if gunact == true then LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.6,0.1)*ANGLES(RAD(0.2),RAD(-84.8),RAD(-167.4)),Alpha);else LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.6,0.1)*ANGLES(RAD(-12.2),RAD(-73.3 ),RAD(-4.7)),.1);end
RightShoulder.C0 = RightShoulder.C0:lerp(CF(0.5,0.8,0.6)*ANGLES(RAD(57.3),RAD(56.6),RAD(-61.7)),Alpha)
Neck.C0 =Neck.C0:lerp(CF(0,1,0.1)*ANGLES(RAD(-104.3- 4 * SIN(SINE/35)),RAD(5.3),RAD(124.5)),Alpha)
LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1,-0.1)*ANGLES(RAD(-10.2),RAD(-86.3),RAD(0)),Alpha)
RightHip.C0 = RightHip.C0:lerp(CF(1,0,-0.6)*ANGLES(RAD(-7.7),RAD(84.7),RAD(0)),Alpha)
end	
shotgunact = false
end
ATTACK = false
end

function swgun()
ATTACK = true
if gunact == true then
for i = 0,20 do	
local Alpha = .1
Swait()
RootJoint.C0 = RootJoint.C0:lerp(CF(0,1.2 + 0.5 * COS(SINE/35),0.1)*ANGLES(RAD(-79.3 + 7 * SIN(SINE/35)),RAD(0),RAD(-180)),Alpha)
LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.8,-0.2)*ANGLES(RAD(-20.1),RAD(-30),RAD(44.7)),Alpha)
RightShoulder.C0 = RightShoulder.C0:lerp(CF(1,0.5,0)*ANGLES(RAD(-11.3),RAD(74.8),RAD(2.7)),Alpha)
Neck.C0 =Neck.C0:lerp(CF(0,1,0.1)*ANGLES(RAD(-100.7- 4 * SIN(SINE/35)),RAD(0),RAD(-139.4)),Alpha)
LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1,-0.1)*ANGLES(RAD(-10.2),RAD(-86.3),RAD(0)),Alpha)
RightHip.C0 = RightHip.C0:lerp(CF(1,0,-0.6)*ANGLES(RAD(-7.7),RAD(84.7),RAD(0)),Alpha)
end
gunact = false
else
for i = 0,20 do
local Alpha = .1
Swait()
RootJoint.C0 = RootJoint.C0:lerp(CF(0,1.2 + 0.5 * COS(SINE/35),0.1)*ANGLES(RAD(-79.3 + 7 * SIN(SINE/35)),RAD(0),RAD(-180)),Alpha)
LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.8,-0.2)*ANGLES(RAD(-20.1),RAD(-30),RAD(44.7)),Alpha)
RightShoulder.C0 = RightShoulder.C0:lerp(CF(1,0.5,0)*ANGLES(RAD(-11.3),RAD(74.8),RAD(2.7)),Alpha)
Neck.C0 =Neck.C0:lerp(CF(0,1,0.1)*ANGLES(RAD(-100.7- 4 * SIN(SINE/35)),RAD(0),RAD(-139.4)),Alpha)
LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1,-0.1)*ANGLES(RAD(-10.2),RAD(-86.3),RAD(0)),Alpha)
RightHip.C0 = RightHip.C0:lerp(CF(1,0,-0.6)*ANGLES(RAD(-7.7),RAD(84.7),RAD(0)),Alpha)
end	
gunact = true
end
ATTACK = false	
end

function gunsh()
ATTACK = true
for i = 0,25 do
Swait()
local Alpha = .1
RootJoint.C0 = RootJoint.C0:lerp(CF(0,1.2 + 0.5 * COS(SINE/35),0.1)*ANGLES(RAD(-79.3 + 7 * SIN(SINE/35)),RAD(0),RAD(-180)),Alpha)
LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.3,0)*ANGLES(RAD(-130.8),RAD(-85.3),RAD(151.3)),Alpha)
RightShoulder.C0 = RightShoulder.C0:lerp(CF(1,0.5,0)*ANGLES(RAD(-11.3),RAD(74.8),RAD(2.7)),Alpha)
Neck.C0 =Neck.C0:lerp(CF(0,1,0.1)*ANGLES(RAD(-100.7- 4 * SIN(SINE/35)),RAD(0),RAD(-180)),Alpha)
LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1,-0.1)*ANGLES(RAD(-10.2),RAD(-86.3),RAD(0)),Alpha)
RightHip.C0 = RightHip.C0:lerp(CF(1,0,-0.6)*ANGLES(RAD(-7.7),RAD(84.7),RAD(0)),Alpha)
end
	repeat
		for i=0, 0.25, 0.1 / Animation_Speed do
			Swait()
			  	local Alpha = .1
  	  	local Alpha = .1
	RootJoint.C0 = RootJoint.C0:lerp(CF(0,1.2 + 0.5 * COS(SINE/35),0.1)*ANGLES(RAD(-79.3 + 7 * SIN(SINE/35)),RAD(0),RAD(-180)),Alpha)
  	LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.1,0)*ANGLES(RAD(-130.8),RAD(-85.3),RAD(103)),Alpha)
  	RightShoulder.C0 = RightShoulder.C0:lerp(CF(1,0.5,0)*ANGLES(RAD(-11.3),RAD(74.8),RAD(2.7)),Alpha)
  	Neck.C0 =Neck.C0:lerp(CF(0,1,0.1)*ANGLES(RAD(-100.7- 4 * SIN(SINE/35)),RAD(0),RAD(-180)),Alpha)
  	LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1,-0.1)*ANGLES(RAD(-10.2),RAD(-86.3),RAD(0)),Alpha)
  	RightHip.C0 = RightHip.C0:lerp(CF(1,0,-0.6)*ANGLES(RAD(-7.7),RAD(84.7),RAD(0)),Alpha)
		end
		--coroutine.resume(coroutine.create(function()
		local HIT,POS = CastProperRay(hole.Position,  Mouse.Hit.p, 500, Character)
		local DISTANCE = (POS - hole.Position).Magnitude
		if HIT then	
		
		WACKYEFFECT2({Time = MRANDOM(90,110), EffectType = "Sphere", Size = Vector3.new(0,0,0), Size2 = Vector3.new(7,7,7), Transparency = 0, Transparency2 = 1, CFrame = CF(POS), MoveToPos = nil, RotationX = nil, RotationY = nil, RotationZ = nil, Material = "Neon", Color = Color3.new(1,0,0), SoundID = nil, SoundPitch = 1, SoundVolume = 1,Chaos = false,UseBoomerangMath = true, SizeBoomerang = 25})	
		end
		for i = 1,6 do
		WACKYEFFECT2({Time = MRANDOM(60,70), EffectType = "Round Slash", Size = Vector3.new(0.01,0.01,0.01) * MRANDOM(.5,1.5), Size2 = Vector3.new(0,0,0), Transparency = 0.3, Transparency2 = 1, CFrame = hole.CFrame * ANGLES(RAD(MRANDOM(0,360)), RAD(0), RAD(MRANDOM(60,120))) * CF(0,0,0), MoveToPos = nil, RotationX = nil, RotationY = nil, RotationZ = nil, Material = "Glass", Color = Color3.new(1,0,0), SoundID = nil, SoundPitch = MRANDOM(7,8)/10, SoundVolume = 8,UseBoomerangMath = true, SizeBoomerang = 15})
		end
		WACKYEFFECT2({Time = MRANDOM(60,70), EffectType = "Sphere", Size = Vector3.new(0,0,0), Size2 = Vector3.new(1,1,1), Transparency = 0, Transparency2 = 1, CFrame = CF(hole.Position), MoveToPos = nil, RotationX = nil, RotationY = nil, RotationZ = nil, Material = "Neon", Color = Color3.new(1,0,0), SoundID = nil, SoundPitch = 1, SoundVolume = 1,Chaos = false,UseBoomerangMath = true, SizeBoomerang = 15})
		WACKYEFFECT2({Time = MRANDOM(60,70), EffectType = "Box", Size = Vector3.new(0,0,DISTANCE), Size2 = Vector3.new(.6,.6,DISTANCE), Transparency = 0, Transparency2 = 1, CFrame = CF(hole.Position,POS)*CF(0,0,-DISTANCE/2), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(1,0,0), SoundID = 419268760, SoundPitch = MRANDOM(9,11)/10, SoundVolume = 8, Chaos = false,UseBoomerangMath = true, SizeBoomerang = 15})
		--Lightning({Material = "Neon", FadeIn = false, Color = C3(1,0,0), Start = hole.Position, End = POS, SegmentL = 2, Thickness = .5, DoesFade = true, Ignore = Character, MaxDist = 5, Branches = true, FadeTime = 150, Thicken = false})
		for i=0, 0.2, 0.1 / Animation_Speed do
		Swait()
		  local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0,1.2 + 0.5 * COS(SINE/35),0.1)*ANGLES(RAD(-79.3 + 7 * SIN(SINE/35)),RAD(0),RAD(-180)),Alpha)
  	LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.6,0.1)*ANGLES(RAD(-130.8),RAD(-85.3),RAD(160)),Alpha)
  	RightShoulder.C0 = RightShoulder.C0:lerp(CF(1,0.5,0)*ANGLES(RAD(-11.3),RAD(74.8),RAD(2.7)),Alpha)
  	Neck.C0 =Neck.C0:lerp(CF(0,1,0.1)*ANGLES(RAD(-100.7- 4 * SIN(SINE/35)),RAD(0),RAD(-180)),Alpha)
  	LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1,-0.1)*ANGLES(RAD(-10.2),RAD(-86.3),RAD(0)),Alpha)
  	RightHip.C0 = RightHip.C0:lerp(CF(1,0,-0.6)*ANGLES(RAD(-7.7),RAD(84.7),RAD(0)),Alpha)
	end
	if shotgunact == true then break end
	until HOLD ==  false
ATTACK = false	
end
		
function shotgunsh()
ATTACK = true
CreateSound(1498950813,RightArm,5,0.8,false)
for i = 0,26 do
Swait()
local Alpha = .1
sgw.C1 = sgw.C1:lerp(CF(0,-1,.3)*ANGLES(RAD(90),RAD(0),RAD(0)),.1)
RootJoint.C0 = RootJoint.C0:lerp(CF(0,1.2 + 0.5 * COS(SINE/35),0.1)*ANGLES(RAD(-79.3 + 7 * SIN(SINE/35)),RAD(0),RAD(-180)),Alpha)
if gunact == true then LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.6,0.1)*ANGLES(RAD(0.2),RAD(-84.8),RAD(-167.4)),Alpha);else LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.6,0.1)*ANGLES(RAD(-12.2),RAD(-73.3 ),RAD(-4.7)),.1);end
RightShoulder.C0 = RightShoulder.C0:lerp(CF(0.9,0.4,-0.2)*ANGLES(RAD(-169.7),RAD(83.4),RAD(-105.4)),Alpha)
Neck.C0 =Neck.C0:lerp(CF(0,1,0.1)*ANGLES(RAD(-100.7- 4 * SIN(SINE/35)),RAD(0),RAD(-180)),Alpha)
LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1,-0.1)*ANGLES(RAD(-10.2),RAD(-86.3),RAD(0)),Alpha)
RightHip.C0 = RightHip.C0:lerp(CF(1,0,-0.6)*ANGLES(RAD(-7.7),RAD(84.7),RAD(0)),Alpha)	
end
CreateSound(1835530642,RightArm,7,.7,false)
for i = 1,6 do
local p1 = CF(hole2.Position,Mouse.Hit.p)*CF(0,0,-45).p
local ap = CF(hole2.Position,p1) * CF(0,0,-45) * ANGLES(RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360)))*CF(0,0,MRANDOM(5,75)/10).p
local HIT,POS = CastProperRay(hole2.Position,ap,1000,Character)
local DISTANCE = (POS - hole2.Position).Magnitude
if HIT then	
-- xd(POS,4,0,0,0,true)
WACKYEFFECT2({Time = MRANDOM(90,110), EffectType = "Sphere", Size = Vector3.new(0,0,0), Size2 = Vector3.new(7,7,7), Transparency = 0, Transparency2 = 1, CFrame = CF(POS), MoveToPos = nil, RotationX = nil, RotationY = nil, RotationZ = nil, Material = "Neon", Color = Color3.new(1,0,0), SoundID = nil, SoundPitch = 1, SoundVolume = 1,Chaos = false,UseBoomerangMath = true, SizeBoomerang = 25})		
end
for i = 1,6 do
WACKYEFFECT2({Time = MRANDOM(60,70), EffectType = "Round Slash", Size = Vector3.new(0.01,0.01,0.01) * MRANDOM(.5,1.5), Size2 = Vector3.new(0,0,0), Transparency = 0.3, Transparency2 = 1, CFrame = hole2.CFrame * ANGLES(RAD(MRANDOM(0,360)), RAD(0), RAD(MRANDOM(60,120))) * CF(0,0,0), MoveToPos = nil, RotationX = nil, RotationY = nil, RotationZ = nil, Material = "Glass", Color = Color3.new(1,0,0), SoundID = nil, SoundPitch = MRANDOM(7,8)/10, SoundVolume = 8,UseBoomerangMath = true, SizeBoomerang = 15})
end
WACKYEFFECT2({Time = MRANDOM(60,70), EffectType = "Sphere", Size = Vector3.new(0,0,0), Size2 = Vector3.new(1,1,1), Transparency = 0, Transparency2 = 1, CFrame = CF(hole2.Position), MoveToPos = nil, RotationX = nil, RotationY = nil, RotationZ = nil, Material = "Neon", Color = Color3.new(1,0,0), SoundID = nil, SoundPitch = 1, SoundVolume = 1,Chaos = false,UseBoomerangMath = true, SizeBoomerang = 15})
WACKYEFFECT2({Time = MRANDOM(60,70), EffectType = "Box", Size = Vector3.new(0,0,DISTANCE), Size2 = Vector3.new(.6,.6,DISTANCE), Transparency = 0, Transparency2 = 1, CFrame = CF(hole2.Position,POS)*CF(0,0,-DISTANCE/2), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(1,0,0), SoundID = nil, SoundPitch = MRANDOM(9,11)/10, SoundVolume = 8, Chaos = false,UseBoomerangMath = true, SizeBoomerang = 15})
end
for i = 0,35 do
local Alpha = .2
Swait()
sgw.C1 = sgw.C1:lerp(CF(0,-1,.3)*ANGLES(RAD(90),RAD(0),RAD(0)),.1)
RootJoint.C0 = RootJoint.C0:lerp(CF(0,1.2 + 0.5 * COS(SINE/35),0.1)*ANGLES(RAD(-79.3 + 7 * SIN(SINE/35)),RAD(0),RAD(-180)),Alpha)
if gunact == true then LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.6,0.1)*ANGLES(RAD(0.2),RAD(-84.8),RAD(-167.4)),Alpha);else LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.6,0.1)*ANGLES(RAD(-12.2),RAD(-73.3 ),RAD(-4.7)),.1);end
RightShoulder.C0 = RightShoulder.C0:lerp(CF(1.1,0.3,-0.1)*ANGLES(RAD(-169.7),RAD(83.4),RAD(-55.3)),Alpha)
Neck.C0 =Neck.C0:lerp(CF(0,1,0.1)*ANGLES(RAD(-100.7- 4 * SIN(SINE/35)),RAD(0),RAD(-180)),Alpha)
LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1,-0.1)*ANGLES(RAD(-10.2),RAD(-86.3),RAD(0)),Alpha)
RightHip.C0 = RightHip.C0:lerp(CF(1,0,-0.6)*ANGLES(RAD(-7.7),RAD(84.7),RAD(0)),Alpha)	
end
ATTACK = false	
end

function magic1()
ATTACK = true
local a = false
for i = 0,35 do
Swait()
local Alpha = .1
RootJoint.C0 = RootJoint.C0:lerp(CF(-0.1,1.2+ 0.5 * COS(SINE/35),0)*ANGLES(RAD(-83.2+ 7 * SIN(SINE/35)),RAD(8.3),RAD(-129.6)),Alpha)
LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.6,0)*ANGLES(RAD(-8.3),RAD(-74.4),RAD(-175.8)),Alpha)
RightShoulder.C0 = RightShoulder.C0:lerp(CF(1,0.5,0)*ANGLES(RAD(-11.3),RAD(74.8),RAD(2.7)),Alpha)
Neck.C0 =Neck.C0:lerp(CF(-0.2,1,0.1)*ANGLES(RAD(-100.7- 4 * SIN(SINE/35)),RAD(0),RAD(129.1)),Alpha)
LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1,-0.1)*ANGLES(RAD(-10.2),RAD(-86.3),RAD(0)),Alpha)
RightHip.C0 = RightHip.C0:lerp(CF(1,0,-0.6)*ANGLES(RAD(-7.7),RAD(84.7),RAD(0)),Alpha)	
end
local sp = CreatePart(3,Effects,"Neon",0,0,"Really red","magic lol",VT(7.5,7.5,7.5),true)
MakeForm(sp,"Ball")
sp.CFrame = LeftArm.CFrame * CF(0,-3,0)
WACKYEFFECT2({Time = 90, EffectType = "Sphere", Size = VT(.2,.2,.2)*sp.Size.Magnitude, Size2 = VT(15,15,15), Transparency = 0.6, Transparency2 = 1, CFrame = CF(sp.Position) --[[* CF(2,-15.3,-3)]], MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = 203691785, SoundPitch = 1, SoundVolume = 8, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 35})
coroutine.resume(coroutine.create(function()
repeat
Swait()
WACKYEFFECT2({Time = 30, EffectType = "Ring", Size = Vector3.new(.56,.56,.56), Size2 = Vector3.new(.56,.56,.56), Transparency = 0.3, Transparency2 = 1, CFrame = sp.CFrame * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0,0,0), MoveToPos = nil, RotationX = MRANDOM(-60, 60), RotationY = MRANDOM(-50, 50), RotationZ = MRANDOM(-60, 60), Material = "Neon", Color = Color3.fromRGB(255, 0, 0), SoundID = nil, SoundPitch = 1, SoundVolume = 5, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 80})
until a == true
end))
--swait(.5)
coroutine.resume(coroutine.create(function()	
sp.CFrame = CF(sp.Position,Mouse.Hit.p)
for i = 1,250 do
Swait()
sp.CFrame = sp.CFrame * CF(0,0,-2)
local hit,pos = Raycast(sp.Position,sp.CFrame.lookVector,5,Character)
if hit then break end	
end
-- xd(sp.Position,12,0,0,0,true)
for i = 1,15 do
WACKYEFFECT2({Time = MRANDOM(80,90), EffectType = "Sphere", Size = VT(1,10,1), Size2 = VT(5.5,55,5.5), Transparency = 0, Transparency2 = 1, CFrame = CF(sp.Position) * ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360))) --[[* CF(2,-15.3,-3)]], MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = 1, SoundVolume = 8, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 35})	
end
WACKYEFFECT2({Time = 60, EffectType = "Sphere", Size = VT(.2,.2,.2)*sp.Size.Magnitude, Size2 = VT(5,5,5)*sp.Size.Magnitude, Transparency = 0.6, Transparency2 = 1, CFrame = CF(sp.Position) --[[* CF(2,-15.3,-3)]], MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = 231917970, SoundPitch = 1, SoundVolume = 8, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 35})
sp:Destroy()
a = true 
end))
for i = 0,20 do
Swait()
  	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0.1,1.2+ 0.5 * COS(SINE/35),0.1)*ANGLES(RAD(-82.1+ 7 * SIN(SINE/35)),RAD(-7.2),RAD(137.8)),Alpha)
  	LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-0.5,0.6,-0.9)*ANGLES(RAD(97.5),RAD(-35.9),RAD(60.9)),Alpha)
  	RightShoulder.C0 = RightShoulder.C0:lerp(CF(1,0.5,0)*ANGLES(RAD(-11.3),RAD(74.8),RAD(2.7)),Alpha)
  	Neck.C0 =Neck.C0:lerp(CF(0.1,1,0.1)*ANGLES(RAD(-100.7- 4 * SIN(SINE/35)),RAD(0),RAD(-137.3)),Alpha)
  	LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1,-0.1)*ANGLES(RAD(-10.2),RAD(-86.3),RAD(0)),Alpha)
  	RightHip.C0 = RightHip.C0:lerp(CF(1,0,-0.6)*ANGLES(RAD(-7.7),RAD(84.7),RAD(0)),Alpha)	
end
ATTACK = false
end

function magic2()
ATTACK = true
local first = false
local stuck = false
coroutine.resume(coroutine.create(function()
repeat
	Swait()
  	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0,1.2 + 0.5 * COS(SINE/35),0.1)*ANGLES(RAD(-79.3 + 7 * SIN(SINE/35)),RAD(0),RAD(-180)),Alpha)
  	LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1.3,-0.2,0.3)*ANGLES(RAD(-101.3),RAD(-1.8),RAD(-84.9)),Alpha)
  	RightShoulder.C0 = RightShoulder.C0:lerp(CF(1.4,-0.2,0.2)*ANGLES(RAD(-97.5),RAD(-1.2),RAD(92.2)),Alpha)
  	Neck.C0 =Neck.C0:lerp(CF(0,1,0.1)*ANGLES(RAD(-100.7- 4 * SIN(SINE/35)),RAD(0),RAD(-180)),Alpha)
  	LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1,-0.1)*ANGLES(RAD(-10.2),RAD(-86.3),RAD(0)),Alpha)
RightHip.C0 = RightHip.C0:lerp(CF(1,0,-0.6)*ANGLES(RAD(-7.7),RAD(84.7),RAD(0)),Alpha)	
until	 first == true
end))
local sp1 = CreatePart(3,nil,"Neon",0,0,"Really red","magic lol",VT(2.89, 2.89, 2.89),true)
MakeForm(sp1,"Ball")
local sp2 = CreatePart(3,nil,"Neon",0,0,"Really red","magic lol",VT(2.89, 2.89, 2.89),true)
MakeForm(sp2,"Ball")
sp1.CFrame = LeftArm.CFrame * CF(0,-1,0)
sp2.CFrame = RightArm.CFrame * CF(0,-1,0)
WACKYEFFECT2({Time = 90, EffectType = "Sphere", Size = VT(.2,.2,.2)*sp1.Size.Magnitude, Size2 = VT(10,10,10), Transparency = 0.6, Transparency2 = 1, CFrame = CF(sp1.Position) --[[* CF(2,-15.3,-3)]], MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = 203691785, SoundPitch = 1, SoundVolume = 10, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 35})
WACKYEFFECT2({Time = 90, EffectType = "Sphere", Size = VT(.2,.2,.2)*sp2.Size.Magnitude, Size2 = VT(10,10,10), Transparency = 0.6, Transparency2 = 1, CFrame = CF(sp2.Position) --[[* CF(2,-15.3,-3)]], MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = 1, SoundVolume = 8, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 35})
swait(.3)
coroutine.resume(coroutine.create(function()
repeat
Swait()
pcall(function()
sp1.Parent = Effects
sp2.Parent = Effects
end)
sp1.CFrame = LeftArm.CFrame * CF(0,-1,0)
sp2.CFrame = RightArm.CFrame * CF(0,-1,0)
WACKYEFFECT2({Time = 30, EffectType = "Ring", Size = Vector3.new(.2,.2,.2), Size2 = Vector3.new(.2,.2,.2), Transparency = 0.3, Transparency2 = 1, CFrame = sp1.CFrame * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0,0,0), MoveToPos = nil, RotationX = MRANDOM(-60, 60), RotationY = MRANDOM(-50, 50), RotationZ = MRANDOM(-60, 60), Material = "Neon", Color = Color3.fromRGB(255, 0, 0), SoundID = nil, SoundPitch = 1, SoundVolume = 5, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 80})
WACKYEFFECT2({Time = 30, EffectType = "Ring", Size = Vector3.new(.2,.2,.2), Size2 = Vector3.new(.2,.2,.2), Transparency = 0.3, Transparency2 = 1, CFrame = sp2.CFrame * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0,0,0), MoveToPos = nil, RotationX = MRANDOM(-60, 60), RotationY = MRANDOM(-50, 50), RotationZ = MRANDOM(-60, 60), Material = "Neon", Color = Color3.fromRGB(255, 0, 0), SoundID = nil, SoundPitch = 1, SoundVolume = 5, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 80})
until stuck == true
end))
first = true
for i = 0,20 do
Swait()
  	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0,1.2 + 0.5 * COS(SINE/35),0.3)*ANGLES(RAD(-64.9+ 7 * SIN(SINE/35)),RAD(0),RAD(-180)),Alpha)
  	LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1.3,-0.2,0.3)*ANGLES(RAD(-101.3),RAD(-1.8),RAD(-68.5)),Alpha)
  	RightShoulder.C0 = RightShoulder.C0:lerp(CF(1.4,-0.2,0.3)*ANGLES(RAD(-97.5),RAD(-1.2),RAD(71.5)),Alpha)
  	Neck.C0 =Neck.C0:lerp(CF(0,1,0.1)*ANGLES(RAD(-100.7- 4 * SIN(SINE/35)),RAD(0),RAD(-180)),Alpha)
  	LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1.1,-0.1)*ANGLES(RAD(-24.6),RAD(-86.3),RAD(0)),Alpha)
  	RightHip.C0 = RightHip.C0:lerp(CF(1,-0.2,-0.8)*ANGLES(RAD(-22.1),RAD(84.7),RAD(0)),Alpha)	
end
for i = 1,15 do
WACKYEFFECT2({Time = MRANDOM(80,90), EffectType = "Sphere", Size = VT(1,10,1), Size2 = VT(1.5,15,1.5), Transparency = 0, Transparency2 = 1, CFrame = CF(RootPart.Position) * CF(0,0,-2) * ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360))) --[[* CF(2,-15.3,-3)]], MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = 1, SoundVolume = 8, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 35})		
end
WACKYEFFECT2({Time = 120, EffectType = "Sphere", Size = VT(.2,.2,.2)*Torso.Size.Magnitude, Size2 = VT(12,12,12), Transparency = 0.6, Transparency2 = 1, CFrame = CF(RootPart.Position) * CF(0,0,-2), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = 231917970, SoundPitch = 1, SoundVolume = 8, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 35})
-- xd(sp1.Position,14,0,0,0,true)
sp1:Destroy()
sp2:Destroy()
stuck = true
for i = 0,26 do
Swait()
  	local Alpha = .2
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0,1.1 + 0.5 * COS(SINE/35),0.1)*ANGLES(RAD(-84.9+ 7 * SIN(SINE/35)),RAD(0),RAD(-180)),Alpha)
  	LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1.4,-0.3,-0.3)*ANGLES(RAD(-101.3),RAD(-1.8),RAD(117.1)),Alpha)
  	RightShoulder.C0 = RightShoulder.C0:lerp(CF(1.5,-0.2,-0.2)*ANGLES(RAD(-97.5),RAD(-1.2),RAD(-120.2)),Alpha)
  	Neck.C0 =Neck.C0:lerp(CF(0,1,0.1)*ANGLES(RAD(-100.7- 4 * SIN(SINE/35)),RAD(0),RAD(-180)),Alpha)
  	LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-0.9,-0.3)*ANGLES(RAD(-4.5),RAD(-86.3),RAD(0)),Alpha)
  	RightHip.C0 = RightHip.C0:lerp(CF(1,0.2,-0.6)*ANGLES(RAD(-2),RAD(84.7),RAD(0)),Alpha)	
end
ATTACK = false	
end	

function magic3()
ATTACK = true
local b = false
for i = 0,20 do
	Swait()
  	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(CF(-0.1,1.2 + 0.5 * COS(SINE/35),0)*ANGLES(RAD(-82.9+ 7 * SIN(SINE/35)),RAD(8),RAD(-131.9)),Alpha)
  	LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.5,0)*ANGLES(RAD(-3.9),RAD(-78.7),RAD(3.4)),Alpha)
  	RightShoulder.C0 = RightShoulder.C0:lerp(CF(0.9,0.8,0)*ANGLES(RAD(-11.3),RAD(74.8),RAD(170.3)),Alpha)
  	Neck.C0 =Neck.C0:lerp(CF(-0.2,1,0.1)*ANGLES(RAD(-100.7),RAD(0),RAD(131.4)),Alpha)
  	LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1,-0.1)*ANGLES(RAD(-10.2),RAD(-86.3),RAD(0)),Alpha)
  	RightHip.C0 = RightHip.C0:lerp(CF(1,0,-0.6)*ANGLES(RAD(-7.7),RAD(84.7),RAD(0)),Alpha)	
end
local sph = CreatePart(3,Effects,"Neon",0,0,"Really red","magic lol",VT(2.31, 2.31, 2.31)*2,true)
MakeForm(sph,"Ball")
sph.CFrame = RightArm.CFrame * CF(0,-3,0)
WACKYEFFECT2({Time = 90, EffectType = "Sphere", Size = VT(.2,.2,.2)*sph.Size.Magnitude, Size2 = VT(5,5,5)*2, Transparency = 0.6, Transparency2 = 1, CFrame = CF(sph.Position) --[[* CF(2,-15.3,-3)]], MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = 203691785, SoundPitch = 1, SoundVolume = 8, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 35})
coroutine.resume(coroutine.create(function()
repeat
Swait()
sph.CFrame = RightArm.CFrame * CF(0,-3,0)
WACKYEFFECT2({Time = 30, EffectType = "Ring", Size = Vector3.new(.5,.5,.5), Size2 = Vector3.new(.5,.5,.5), Transparency = 0.3, Transparency2 = 1, CFrame = sph.CFrame * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0,0,0), MoveToPos = nil, RotationX = MRANDOM(-60, 60), RotationY = MRANDOM(-50, 50), RotationZ = MRANDOM(-60, 60), Material = "Neon", Color = Color3.fromRGB(255, 0, 0), SoundID = nil, SoundPitch = 1, SoundVolume = 5, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 80})
until b == true
end))
for i = 0,20 do
	Swait()
  	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(CF(-0.1,1.2 + 0.5 * COS(SINE/35),0.2)*ANGLES(RAD(-67.2+ 7 * SIN(SINE/35)),RAD(8),RAD(-131.9)),Alpha)
  	LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.5,0)*ANGLES(RAD(-3.9),RAD(-78.7),RAD(3.4)),Alpha)
  	RightShoulder.C0 = RightShoulder.C0:lerp(CF(1,0.8,-0.2)*ANGLES(RAD(-8.7),RAD(71.8),RAD(-167.5)),Alpha)
  	Neck.C0 =Neck.C0:lerp(CF(-0.2,1,0.1)*ANGLES(RAD(-100.7),RAD(0),RAD(131.4)),Alpha)
  	LeftHip.C0 = LeftHip.C0:lerp(CF(-1.1,-0.9,-0.1)*ANGLES(RAD(-88.8),RAD(-77.4),RAD(-68.6)),Alpha)
  	RightHip.C0 = RightHip.C0:lerp(CF(1.1,-0.4,-0.6)*ANGLES(RAD(49.1),RAD(77.3),RAD(-67.7)),Alpha)	
end
for i = 1,15 do
WACKYEFFECT2({Time = MRANDOM(40,50), EffectType = "Sphere", Size = VT(1,10,1), Size2 = VT(1.5,15,1.5), Transparency = 0, Transparency2 = 1, CFrame = RootPart.CFrame * CF(1,-3,0) * ANGLES(RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360)),RAD(MRANDOM(-360,360))) --[[* CF(2,-15.3,-3)]], MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = 1, SoundVolume = 8, UseBoomerangMath = true, Boomerang = 0, SizeBoomerang = 35})		
end
WACKYEFFECT2({Time = 40, EffectType = "Sphere", Size = VT(.2,.01,.2)*sph.Size.Magnitude, Size2 = VT(3.5,0.1,3.5)*sph.Size.Magnitude, Transparency = 0.6, Transparency2 = 1, CFrame = RootPart.CFrame * CF(1,-3,0) * ANGLES(RAD(0),RAD(0),RAD(0)) --[[* CF(2,-15.3,-3)]], MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = 231917970, SoundPitch = 1, SoundVolume = 8, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 35})
sph:Destroy()
b = true
local hf,hp = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 3.7, Character)
if hf then
coroutine.resume(coroutine.create(function()
for i = 0,6 do
local po = RootPart.CFrame*CF(0,0,-i*22)
local hf2,hp2 = Raycast(po.p+VT(0,1,0), (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 3.7, Character)
if hf then
local ab = CF(hp2) * ANGLES(RAD(0), RAD(MRANDOM(0,360)), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0))
WACKYEFFECT2({Time = 120, EffectType = "Sphere", Size = VT(5,10,5), Size2 = VT(30,50,30), Transparency = 0.6, Transparency2 = 1, CFrame = ab --[[* CF(2,-15.3,-3)]], MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = 231917970, SoundPitch = 1, SoundVolume = 8, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 35})
WACKYEFFECT2({Time = 120, EffectType = "Sphere", Size = VT(5,10,5), Size2 = VT(15,35,15), Transparency = 0.6, Transparency2 = 1, CFrame = ab --[[* CF(2,-15.3,-3)]], MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(.7,0,0), SoundID = nil, SoundPitch = 1, SoundVolume = 8, UseBoomerangMath = false, Boomerang = 0, SizeBoomerang = 35})
WACKYEFFECT2({Time = 50, EffectType = "Wave", Size = VT(5,5,5), Size2 = VT(20.5,2,20.5), Transparency = 0.25, Transparency2 = 1, CFrame = ab, MoveToPos = nil, RotationX = 0, RotationY = 15, RotationZ = 0, Material = "Neon", Color = BRICKC"Really red".Color, SoundID = nil, SoundPitch = MRANDOM(9,11)/12, SoundVolume = 2})
-- xd(ab.p,15,0,0,0,true)
swait(.1)
end
end		
end))
end
for i = 0,26 do
Swait()
  	local Alpha = .2
  	RootJoint.C0 = RootJoint.C0:lerp(CF(-0.1,-1.2,0.3)*ANGLES(RAD(-108.9),RAD(8),RAD(-131.9)),Alpha)
  	LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-0.9,0.1,0.2)*ANGLES(RAD(-84.3),RAD(-48.5),RAD(-59.8)),Alpha)
  	RightShoulder.C0 = RightShoulder.C0:lerp(CF(1.2,0.1,-0.1)*ANGLES(RAD(-144.2),RAD(53.2),RAD(165.1)),Alpha)
  	Neck.C0 =Neck.C0:lerp(CF(-0.1,1,0.1)*ANGLES(RAD(-100.7),RAD(0),RAD(144.5)),Alpha)
  	LeftHip.C0 = LeftHip.C0:lerp(CF(-1,0.1,-0.6)*ANGLES(RAD(-10.2),RAD(-86.3),RAD(-9.5)),Alpha)
  	RightHip.C0 = RightHip.C0:lerp(CF(1,-1,-0.9)*ANGLES(RAD(-7.7),RAD(84.7),RAD(-85.1)),Alpha)	
end
ATTACK = false	
end

function tuant()
ATTACK = true
CreateSound(3724749130,Head,8,1,false)
for i = 0,75 do
Swait()
  	local Alpha = .4
  	RootJoint.C0 = RootJoint.C0:lerp(CF(0,1.2 + 0.07 * COS(SINE/5) + 0.5 * COS(SINE/35),0.3)*ANGLES(RAD(-59.8),RAD(0),RAD(-180)),Alpha)
  	LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.4 + 0.1 * SIN(SINE/5),0.1)*ANGLES(RAD(0.2),RAD(-84.8),RAD(33.8)),Alpha)
  	RightShoulder.C0 = RightShoulder.C0:lerp(CF(1,0.5+ 0.1 * SIN(SINE/5),0)*ANGLES(RAD(-11.3),RAD(74.8),RAD(-20.1)),Alpha)
  	Neck.C0 =Neck.C0:lerp(CF(0,1,-0.1)*ANGLES(RAD(-81),RAD(0),RAD(-180)),Alpha)
  	LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1.2,0.1)*ANGLES(RAD(-29.6),RAD(-86.3),RAD(0)),Alpha)
  	RightHip.C0 = RightHip.C0:lerp(CF(1,-0.4,-0.7)*ANGLES(RAD(-27.1),RAD(84.7),RAD(0)),Alpha)
end
ATTACK = false	
end


--keys
function MouseDown(Mouse)
	HOLD = true
	if ATTACK == false then
	if shotgunact == true and gunact == true then
	if COMBO == 1 then
	gunsh()
	COMBO = 2
	elseif COMBO == 2 then
	shotgunsh()
	COMBO = 1		
	end
	elseif shotgunact == true and gunact == false then
	shotgunsh()
	elseif shotgunact == false and gunact == true then
	gunsh()		
	end
	end
end

function MouseUp(Mouse)
HOLD = false
end
function KeyDown(Key)
	KEYHOLD = true
	if Key == "q" and ATTACK == false then
		swshotg()
	end
	
	if Key == "e" and ATTACK == false then
		print("removed xd")
	end

	if Key == "z" and ATTACK == false and shotgunact == false and gunact == false then
	magic1()	
	end
	
	if Key == "x" and ATTACK == false and shotgunact == false and gunact == false then
	magic2()	
	end
	
	if Key == "c" and ATTACK == false and shotgunact == false and gunact == false then
		magic3()	
	end
	
	if Key == "t" and ATTACK == false then
		tuant()
	end
	
	if Key == "m" then
		cs()
	end

	if Key == "]" and ATTACK == false then
		if sick.Parent ~= Character then
			sick = IT("Sound",Torso)
			sick.SoundId = "rbxassetid://"..SONG
		end
	end
end

function KeyUp(Key)
	KEYHOLD = false
end

	Mouse.Button1Down:connect(function(NEWKEY)
		MouseDown(NEWKEY)
	end)
	Mouse.Button1Up:connect(function(NEWKEY)
		MouseUp(NEWKEY)
	end)
	Mouse.KeyDown:connect(function(NEWKEY)
		KeyDown(NEWKEY)
	end)
	Mouse.KeyUp:connect(function(NEWKEY)
		KeyUp(NEWKEY)
	end)

function unanchor()
	for _, c in pairs(Character:GetChildren()) do
		if c:IsA("BasePart") and c ~= RootPart then
			c.Anchored = false
		end
	end
	if UNANCHOR == true then
		RootPart.Anchored = false
	else
		RootPart.Anchored = true
	end
end

--if gunact == true then LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.6,0.1)*ANGLES(RAD(0.2),RAD(-84.8),RAD(-167.4)),Alpha);else LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.6,0.1)*ANGLES(RAD(-12.2),RAD(-73.3 ),RAD(-4.7)),.1);end


--loop stuff

Humanoid.Changed:connect(function(Jump)
	if Jump == "Jump" and (Disable_Jump == true) then
		Humanoid.Jump = false
	end
end)

while true do
	Swait()
	script.Parent = WEAPONGUI
	ANIMATE.Parent = nil
	for _,v in next, Humanoid:GetPlayingAnimationTracks() do
	    v:Stop();
	end
	SINE = SINE + CHANGE*2
	local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
	local TORSOVERTICALVELOCITY = RootPart.Velocity.y
	local HITFLOOR,HITPOS,NORMAL = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4+Humanoid.HipHeight, Character)
	local WALKSPEEDVALUE = 12 / (Humanoid.WalkSpeed / 16)
	if TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil then
		ANIM = "Jump"
		if ATTACK == false then
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(-5), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(-25), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-35), RAD(0), RAD(25 + 10 * COS(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-35), RAD(0), RAD(-25 - 10 * COS(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.4, -0.6) * ANGLES(RAD(1), RAD(90), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
	elseif TORSOVERTICALVELOCITY < -1 and HITFLOOR == nil then
		ANIM = "Fall"
		if ATTACK == false then
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(15), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(15), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(35 - 4 * COS(SINE / 6)), RAD(0), RAD(45 + 10 * COS(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(35 - 4 * COS(SINE / 6)), RAD(0), RAD(-45 - 10 * COS(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.3, -0.7) * ANGLES(RAD(-25 + 5 * SIN(SINE / 12)), RAD(90), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.8, -0.3) * ANGLES(RAD(-10), RAD(-80), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
	elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then
		ANIM = "Idle"
		if ATTACK == false then
		local Alpha = .1
  		RootJoint.C0 = RootJoint.C0:lerp(CF(0,1.2 + 0.5 * COS(SINE/35),0.1)*ANGLES(RAD(-79.3 + 7 * SIN(SINE/35)),RAD(0),RAD(-180)),Alpha)
  		if gunact == true then LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.6 + 0.07 * SIN(SINE/35),0.1)*ANGLES(RAD(0.2 + 5 * COS(SINE/35)),RAD(-84.8 + 2 * SIN(SINE/35)),RAD(-167.4)),Alpha);else LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.6 + 0.07 * SIN(SINE/35),0.1)*ANGLES(RAD(-12.2 + 5 * COS(SINE/35)),RAD(-73.3 + 2 * SIN(SINE/35)),RAD(-4.7)),.1);end
  		RightShoulder.C0 = RightShoulder.C0:lerp(CF(1,0.5 + 0.07 * SIN(SINE/35),0)*ANGLES(RAD(-11.3 + 5 * COS(SINE/35)),RAD(74.8 - 2 * SIN(SINE/35)),RAD(2.7)),Alpha)
  		Neck.C0 =Neck.C0:lerp(CF(0,1,0.1)*ANGLES(RAD(-100.7 - 4 * SIN(SINE/35)),RAD(0),RAD(-180)),Alpha)
  		LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1,-0.1)*ANGLES(RAD(-10.2 - 4 * COS(SINE/35)),RAD(-86.3),RAD(0)),Alpha)
  		RightHip.C0 = RightHip.C0:lerp(CF(1,0,-0.6)*ANGLES(RAD(-7.7 - 4 * COS(SINE/35)),RAD(84.7),RAD(0)),Alpha)
		end
	elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
		ANIM = "Walk"
		if ATTACK == false then
		local Alpha = .1
  		RootJoint.C0 = RootJoint.C0:lerp(CF(0,1.2 + 0.5 * COS(SINE/35),0.1)*ANGLES(RAD(-149.3 + 7 * SIN(SINE/35)),RAD(0),RAD(-180)),Alpha)
  		if gunact == true then LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.6 + 0.07 * SIN(SINE/35),0.1)*ANGLES(RAD(0.2 + 5 * COS(SINE/35)),RAD(-84.8 + 2 * SIN(SINE/35)),RAD(-167.4)),Alpha)
		else
		LeftShoulder.C0 = LeftShoulder.C0:lerp(CF(-1,0.6 + 0.07 * SIN(SINE/35),0.1)*ANGLES(RAD(-12.2 + 5 * COS(SINE/35)),RAD(-73.3 + 2 * SIN(SINE/35)),RAD(-4.7)),.1)
		end
  		RightShoulder.C0 = RightShoulder.C0:lerp(CF(1,0.5 + 0.07 * SIN(SINE/35),0)*ANGLES(RAD(-11.3 + 5 * COS(SINE/35)),RAD(74.8 - 2 * SIN(SINE/35)),RAD(2.7)),Alpha)
  		Neck.C0 =Neck.C0:lerp(CF(0,1,0.1)*ANGLES(RAD(-30.7 - 4 * SIN(SINE/35)),RAD(0),RAD(-180)),Alpha)
  		LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1,-0.1)*ANGLES(RAD(-10.2 - 4 * COS(SINE/35)),RAD(-86.3),RAD(0)),Alpha)
  		RightHip.C0 = RightHip.C0:lerp(CF(1,0,-0.6)*ANGLES(RAD(-7.7 - 4 * COS(SINE/35)),RAD(84.7),RAD(0)),Alpha)
		end
	end
	if shotgunact == false then
	shotgun.Parent = nil
	fshot.Parent = Character
	else
	shotgun.Parent = Character
	fshot.Parent = nil
	end
	
	if gunact == false then
	gun.Parent = nil
	fgun.Parent = Character
	else
	gun.Parent = Character
	fgun.Parent = nil	
	end
	if ATTACK == false then
	sgw.C1 = sgw.C1:lerp(CF(0,0,0),.1)
	gunw.C1 = gunw.C1:lerp(CF(0,0,0),.1)
	end
	
	local CFRAME2 = CF(RootPart.Position) * ANGLES(RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360)), RAD(0)) * CF(0, MRANDOM(2,6), MRANDOM(6,10))
	local POSITION = CF(HITPOS)*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(MRANDOM(3,6),-.6,0).p
	local SPHEREFLOOR,SPHEREPOS = Raycast(POSITION+VT(0,1,0), (CF(POSITION, POSITION + VT(0, -5, 0))).lookVector, 25, Character)
	if MRANDOM(1,15) == 1 then
		WACKYEFFECT2({Time = MRANDOM(50,90), EffectType = "Sphere", Size = VT(.7,.7,.7), Size2 = VT(0,.7,0), Transparency = 0, Transparency2 = 1, CFrame = CF(SPHEREPOS-VT(0,0,0))*ANGLES(RAD(MRANDOM(0,0)),RAD(MRANDOM(0,0)),RAD(MRANDOM(0,0))), MoveToPos = SPHEREPOS+VT(0,MRANDOM(15,25)/1.2,0), MRANDOM(-25,25)/12, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,0,0),SoundID = nil, SoundPitch = MRANDOM(12,16)/10, SoundVolume = 2})
	end

	
	unanchor()
	Humanoid.MaxHealth = 1e4
	Humanoid.Health = 1e4
	if Rooted == false then
		Disable_Jump = false
		Humanoid.WalkSpeed = Speed
	elseif Rooted == true then
		Disable_Jump = true
		Humanoid.WalkSpeed = 0
	end
	sick.SoundId = "rbxassetid://"..SONG
	sick.Looped = true
	if SONG == 383141805 then
	sick.Pitch = .88
	else
	sick.Pitch = 1
	end
	sick.Volume = 3
	sick.Playing = true
end

--//=================================\\
--\\=================================//





--//====================================================\\--
--||			  		 END OF SCRIPT
--\\====================================================//--
	else
		game.StarterGui:SetCore("ChatMakeSystemMessage", {
			Text = "[WARNING]: YOU ARE NOT REANIMATED! PLEASE REANIMATE TO USE THIS SCRIPT.",
			Color = Color3.fromRGB(255, 0, 0),
			TextSize = 20,
			Font = Enum.Font.Cartoon
		});
	end
 end)



